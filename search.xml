<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python3]]></title>
    <url>%2F2018%2F03%2F13%2Fpython3%2F</url>
    <content type="text"><![CDATA[基础语法 注释 单行注释：#号 多行注释：&#39;&#39;&#39;和&quot;&quot;&quot; 行与缩进 使用缩进来表示代码块，不需要使用大括号{}。同一个代码块的语句必须包含相同的缩进空格数 多行语句 12345678# 使用反斜杠(\)来实现多行语句total = item_one + \ item_two + \ item_three# 在 [], &#123;&#125;, 或 () 中的多行语句，不需要使用反斜杠(\) total = ['item_one', 'item_two', 'item_three', 'item_four', 'item_five'] 数字(Number)类型python中数字有四种类型：整数、长整数、浮点数和复数。 int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 bool (布尔),如 true。 float (浮点数), 如 1.23、3E-2 complex (复数), 如 1 + 2j、 1.1 + 2.2j 字符串(String) 12345678910111213141516171819202122# python中单引号和双引号使用完全相同。word = '字符串'sentence = "这是一个句子。"# 使用三引号('''或""")可以指定一个多行字符串。paragraph = """这是一个段落，可以由多行组成"""str='Runoob'print(str) # 输出字符串print(str[0:-1]) # 输出第一个到倒数第二个的所有字符print(str[0]) # 输出字符串第一个字符print(str[2:5]) # 输出从第三个开始到第五个的字符print(str[2:]) # 输出从第三个开始的后的所有字符print(str * 2) # 输出字符串两次print(str + '你好') # 连接字符串print('------------------------------')print('hello\nrunoob') # 使用反斜杠(\)+n转义特殊字符print(r'hello\nrunoob') # 在字符串前面添加一个 r，表示原始字符串，不会发生转义 等待用户输入input(&quot;\n\n按下 enter 键后退出。&quot;) Print 输出 123456y="b"# 换行输出print( y )print('---------')# 不换行输出print( y, end=" " ) import 与 from…import 1234将整个模块(somemodule)导入，格式为： import somemodule从某个模块中导入某个函数,格式为： from somemodule import somefunction从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc将某个模块中的全部函数导入，格式为： from somemodule import *]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云nginx配置https]]></title>
    <url>%2F2018%2F03%2F01%2Fnginx-https%2F</url>
    <content type="text"><![CDATA[一、阿里云申请免费证书这里有个坑，找这个免费证书要先选择保护类型为“一个域名”，然后选择品牌为“Symantec”，证书类型中才会出现免费的选项。 二、下载证书申请要过一段时间，才能在我的列表中看到，然后补全信息，过几分钟审核通过了，就可以下载了。下载好了，上传到服务器解压，有两个文件：12/usr/local/nginx/cert/214524977110083.pem/usr/local/nginx/cert/214524977110083.key 三、配置 NGINX 的 HTTPS1234567891011121314151617181920server &#123; listen 443; server_name www.lightquant.com; ssl on; root html; index index.html; ssl_certificate /usr/local/nginx/cert/214524977110083.pem ssl_certificate_key /usr/local/nginx/cert/214524977110083.pem ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL; ssl_prefer_server_ciphers on;&#125;server &#123; listen 80; server_name lightquant.com; return 301 https://$server_name$request_uri;&#125; 完成！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[activeMQ]]></title>
    <url>%2F2018%2F02%2F12%2FactiveMQ%2F</url>
    <content type="text"><![CDATA[安装部署：wget http：//archive.apache.org/dist/activemq/apache-activemq/5.9.0/apache-activemq-5.9.0-bin.tar.gz解压运行：activemq start（1）普通启动./activemq start（2）启动并指定日志文件./activemq start&gt; tmp / smlog（3）后台启动方式nohup ./activemq start&gt; / tmp / smlog管理后台为：http://ip:8161/admin/连接默认端口61616 安全配置jetty.xml中&lt;property name=&quot;authenticate&quot; value=&quot;true&quot; /&gt; //开启认证&lt;property name=&quot;port&quot; value=&quot;8191&quot; /&gt; //修改端口jetty-realm.properties中修改密码 username: password [,rolename …]用户名 : 密码 ,角色名如：admin: admin, admin 依赖123&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt; &lt;/dependency&gt; springMVC12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-core&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; 配置123456789101112131415#==================activemq Config Start==================spring.activemq.broker-url=tcp://127.0.0.1:61616?jms.prefetchPolicy.all=2spring.activemq.in-memory=truespring.activemq.password=adminspring.activemq.user=admin#如果为True，则是Topic；如果是false或者默认，则是queuespring.jms.pub-sub-domain=false spring.activemq.packages.trust-all=falsespring.activemq.packages.trusted=spring.activemq.pool.configuration.*=spring.activemq.pool.enabled=falsespring.activemq.pool.expiry-timeout=0spring.activemq.pool.idle-timeout=30000spring.activemq.pool.max-connections=1#==================activemq Config End ================== springMVC配置1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;context:annotation-config /&gt; &lt;amq:connectionFactory id="amqConnectionFactory" brokerURL="tcp://localhost:61616" userName="admin" password="admin" /&gt; &lt;!-- 配置JMS连接工长 --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory"&gt; &lt;constructor-arg ref="amqConnectionFactory" /&gt; &lt;property name="sessionCacheSize" value="100" /&gt; &lt;/bean&gt; &lt;!--spring jms 为我们提供的连接池--&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory" /&gt; &lt;/bean&gt; &lt;!--一个队列的目的地，点对点的--&gt; &lt;bean id="queueDestionation" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="queue" /&gt; &lt;/bean&gt; &lt;!--一个主题，发布订阅--&gt; &lt;bean id="topicDestionation" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="topic" /&gt; &lt;/bean&gt; &lt;!-- 配置JMS模板（Queue），Spring提供的JMS工具类，它发送、接收消息。 --&gt; &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="defaultDestination" ref="demoQueueDestination" /&gt; &lt;property name="receiveTimeout" value="10000" /&gt; &lt;!-- true是topic，false是queue，默认是false，此处显示写出false --&gt; &lt;property name="pubSubDomain" value="false" /&gt; &lt;/bean&gt; &lt;bean class="com.imooc.jms.producer.ProducerServiceImpl"&gt;&lt;/bean&gt; &lt;!--加入监听器 --&gt; &lt;bean id="queueMessageListener" class="com.qqw.active.QueueMessageListener" /&gt; &lt;!-- 显示注入消息监听容器（Queue），配置连接工厂，监听的目标是demoQueueDestination，监听器是上面定义的监听器 --&gt; &lt;bean id="queueListenerContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="queueDestionation" /&gt; &lt;property name="messageListener" ref="queueMessageListener" /&gt; &lt;/bean&gt; 监听1234 @JmsListener(destination="SPEED_DOWN")public void receive(String msg) &#123; System.out.println(msg);&#125; 12345678910111213141516171819202122public class QueueMessageListener implements MessageListener &#123; //当收到消息后，自动调用该方法 @Override public void onMessage(Message message) &#123; TextMessage tm = (TextMessage) message; try &#123; System.out.println("QueueMessageListener监听到了文本消息：\t" + tm.getText()); Person fromJson = JSON.parseObject(tm.getText(), Person.class); System.out.println(fromJson.toString()); //do something ... &#125; catch (JMSException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 发送123Destination destination = new ActiveMQQueue("SPEED_DOWN");// 这里定义了Queue的keyjsmTemplate.convertAndSend(destination, string+price);//首先要注入jmsTemplate springMVC12345678910111213141516171819实现类public class ProducerServiceImpl implements ProducerService &#123; @Autowired JmsTemplate jmsTemplate; @Resource(name = "queueDestionation") Destination destination; @Override public void sendMessage(final String message) &#123; jmsTemplate.send(destination, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; TextMessage textMessage = session.createTextMessage(message); System.out.println("发送消息："+textMessage.getText()); return textMessage; &#125; &#125;); &#125;&#125; 其他队列模式：生产者先发送消息，消费者后消费消息，消息被平均消费掉主题模式：消费者先订阅消息，生产者产出的消息才可以被消费者接收到，而且是全部接收到的]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>activeMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBoot]]></title>
    <url>%2F2018%2F02%2F11%2FspringBoot%2F</url>
    <content type="text"><![CDATA[thymeleaf依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 配置:12345678910111213141516171819202122232425# THYMELEAF (ThymeleafAutoConfiguration)#开启模板缓存（默认值：true）spring.thymeleaf.cache=true #Check that the template exists before rendering it.spring.thymeleaf.check-template=true #检查模板位置是否正确（默认值:true）spring.thymeleaf.check-template-location=true#Content-Type的值（默认值：text/html）spring.thymeleaf.content-type=text/html#开启MVC Thymeleaf视图解析（默认值：true）spring.thymeleaf.enabled=true#模板编码spring.thymeleaf.encoding=UTF-8#要被排除在解析之外的视图名称列表，用逗号分隔spring.thymeleaf.excluded-view-names=#要运用于模板之上的模板模式。另见StandardTemplate-ModeHandlers(默认值：HTML5)spring.thymeleaf.mode=HTML5#在构建URL时添加到视图名称前的前缀（默认值：classpath:/templates/）spring.thymeleaf.prefix=classpath:/templates/#在构建URL时添加到视图名称后的后缀（默认值：.html）spring.thymeleaf.suffix=.html#Thymeleaf模板解析器在解析器链中的顺序。默认情况下，它排第一位。顺序从1开始，只有在定义了额外的TemplateResolver Bean时才需要设置这个属性。spring.thymeleaf.template-resolver-order=#可解析的视图名称列表，用逗号分隔spring.thymeleaf.view-names= 常见使用：1、在html页面中引入thymeleaf命名空间，即&lt;html xmlns:th=http://www.thymeleaf.org&gt;&lt;/html&gt;，此时在html模板文件中动态的属性使用th:命名空间修饰 2、引用静态资源文件，比如CSS和JS文件，语法格式为”@{}”，如@{/js/blog/blog.js}会引入/static目录下的/js/blog/blog.js文件 3、访问spring-mvc中model的属性，语法格式为”${}”，如${user.id}可以获取model里的user对象的id属性 4、循环12345678910&lt;tr th:each="collect,iterStat : $&#123;collects&#125;"&gt; &lt;th scope="row" th:text="$&#123;collect.id&#125;"&gt;1&lt;/th&gt; &lt;td &gt; &lt;img th:src="$&#123;collect.webLogo&#125;"/&gt; &lt;/td&gt; &lt;td th:text="$&#123;collect.url&#125;"&gt;Mark&lt;/td&gt; &lt;td th:text="$&#123;collect.title&#125;"&gt;Otto&lt;/td&gt; &lt;td th:text="$&#123;collect.description&#125;"&gt;@mdo&lt;/td&gt; &lt;td th:text="$&#123;terStat.index&#125;"&gt;index&lt;/td&gt;&lt;/tr&gt; iterStat称作状态变量，属性有：index:当前迭代对象的index（从0开始计算）count: 当前迭代对象的index(从1开始计算)size:被迭代对象的大小current:当前迭代变量even/odd:布尔值，当前循环是否是偶数/奇数（从0开始计算）first:布尔值，当前循环是否是第一个last:布尔值，当前循环是否是最后一个 5、判断，在html标签中，加入th:if=”表达式”可以根据条件显示html元素123&lt;span th:if="$&#123;not #lists.isEmpty(blog.publishTime)&#125;"&gt;&lt;span id="publishtime" th:text="$&#123;#dates.format(blog.publishTime, 'yyyy-MM-dd HH:mm:ss')&#125;"&gt;&lt;/span&gt; &lt;/span&gt; 以上代码表示若blog.publishTime时间不为空，则显示时间 6、时间的格式化，1$&#123;#dates.format(blog.publishTime,&apos;yyyy-MM-dd HH:mm:ss&apos;)&#125; 表示将时间格式化为”yyyy-MM-dd HH:mm:ss”格式化写法与Java格式化Date的写法是一致的。 7、字符串拼接，有两种形式比如拼接这样一个URL:/blog/delete/{blogId}第一种：th:href=&quot;&#39;/blog/delete/&#39; + ${blog.id }&quot;第二种：th:href=&quot;${&#39;/blog/delete/&#39; + blog.id }&quot; 8、布局定义代码片段：123&lt;footer th:fragment="copy"&gt; ? 2016&lt;/footer&gt; 在页面任何地方引入：12345&lt;body&gt; &lt;div th:include="footer :: copy"&gt;&lt;/div&gt; &lt;div th:replace="footer :: copy"&gt;&lt;/div&gt; &lt;div th:insert="footer :: copy"&gt;&lt;/div&gt; &lt;/body&gt; th:include 和 th:replace区别，include只是加载，replace是替换 也可以在引用模版的时候传参:1&lt;head th:include="layout :: htmlhead" th:with="title='Hello'"&gt;&lt;/head&gt; layout 是文件地址，如果有文件夹可以这样写 fileName/layout:htmlheadhtmlhead 是指定义的代码片段 如 th:fragment=”copy” 下面是一个常用的后台页面布局，将整个页面分为头部，尾部、菜单栏、隐藏栏，点击菜单只改变content区域的页面123456789&lt;body class="layout-fixed"&gt; &lt;div th:fragment="navbar" class="wrapper" role="navigation"&gt; &lt;div th:replace="fragments/header :: header"&gt;Header&lt;/div&gt; &lt;div th:replace="fragments/left :: left"&gt;left&lt;/div&gt; &lt;div th:replace="fragments/sidebar :: sidebar"&gt;sidebar&lt;/div&gt; &lt;div layout:fragment="content" id="content" &gt;&lt;/div&gt; &lt;div th:replace="fragments/footer :: footer"&gt;footer&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 任何页面想使用这样的布局值只需要替换中见的 content模块即可1234&lt;html xmlns:th="http://www.thymeleaf.org" layout:decorator="layout"&gt; &lt;body&gt; &lt;div layout:fragment="content"&gt;我是内容&lt;/div&gt; &lt;/body&gt; 9、点击事件：th:onclick=&quot;&#39;javascript:toxueqiu(\&#39;&#39;+${todayBuy.code}+&#39;\&#39;)&#39;&quot;JS中使用1234&lt;script th:inline="javascript"&gt;var data = [[$&#123;data&#125;]]//var dd="&amp;&amp;"+"&lt;";&lt;/script&gt; 10、th:style根据属性值改变背景1&lt;div class="media-object resource-card-image" th:style="'background:url(' + @&#123;($&#123;collect.webLogo&#125;=='' ? 'img/favicon.png' : $&#123;collect.webLogo&#125;)&#125; + ')'" &gt;&lt;/div&gt; 11、内嵌变量为了模板更加易用，Thymeleaf还提供了一系列Utility对象（内置于Context中），可以通过#直接访问： dates ： java.util.Date的功能方法类。calendars : 类似#dates，面向java.util.Calendarnumbers : 格式化数字的功能方法类strings : 字符串对象的功能类，contains,startWiths,prepending/appending等等。objects: 对objects的功能类操作。bools: 对布尔值求值的功能方法。arrays：对数组的功能类方法。lists: 对lists功能类方法setsmaps…举例：123456789101112131415161718$&#123;#dates.format(date, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.arrayFormat(datesArray, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.listFormat(datesList, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.setFormat(datesSet, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.createNow()&#125;$&#123;#dates.createToday()&#125;$&#123;#strings.isEmpty(name)&#125;$&#123;#strings.arrayIsEmpty(nameArr)&#125;$&#123;#strings.listIsEmpty(nameList)&#125;$&#123;#strings.setIsEmpty(nameSet)&#125;$&#123;#strings.startsWith(name,&apos;Don&apos;)&#125; $&#123;#strings.endsWith(name,endingFragment)&#125; $&#123;#strings.length(str)&#125;$&#123;#strings.equals(str)&#125;$&#123;#strings.equalsIgnoreCase(str)&#125;$&#123;#strings.concat(str)&#125;$&#123;#strings.concatReplaceNulls(str)&#125;$&#123;#strings.randomAlphanumeric(count)&#125; AOP添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 代码实例1234567891011121314151617181920212223242526272829303132333435363738394041424344@Aspect@Componentpublic class HttpAspect &#123; private final static Logger logger = LoggerFactory.getLogger(HttpAspect.class); @Pointcut("execution(public * com.gjd.controller.GirlController.*(..))") //该类下所有方法 public void log()&#123; //定义一个全局的切入点 下面 可以直接 log()引用 &#125; @Before("log()") public void doBefore(JoinPoint joinPoint)&#123; //之前执行 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); //获取request对象 //url logger.info("url=&#123;&#125;", request.getRequestURL()); //method logger.info("method=&#123;&#125;", request.getMethod()); //ip logger.info("ip=&#123;&#125;", request.getRemoteAddr()); //类方法 logger.info("class_method=&#123;&#125;", joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName()); //通过JoinPoint对象获取类方法的对象 //参数 logger.info("args=&#123;&#125;", joinPoint.getArgs()); //通过JoinPoint对象获取传入的对象 &#125; @After("log()") public void doAfter() &#123; //之后执行 logger.info("222222222222"); &#125; @AfterReturning(returning = "object", pointcut = "log()") //获取调用方法返回的信息 public void doAfterReturning(Object object) &#123; logger.info("response=&#123;&#125;", object.toString()); &#125;&#125; 日志一、设置项目启动的日志等级1 在运行命令后加入–debug标志，如：$ java -jar springTest.jar –debug2 在application.properties中配置debug=true，该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。 二、日志输出路径默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性。 1 logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log 2 logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log 如果只配置 logging.file，会在项目的当前路径下生成一个 xxx.log 日志文件。 如果只配置 logging.path，在 /var/log文件夹生成一个日志文件为 spring.log 注：二者不能同时使用，如若同时使用，则只有logging.file生效 三、日志级别控制 1 logging.level.com.dudu=DEBUG：com.dudu包下所有class以DEBUG级别输出2 logging.level.root=WARN：root日志以WARN级别输出 四、自定义日志配置使用logback，建议使用官方名称logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy；spring boot可以为它添加一些spring boot特有的配置项。如果你即想完全掌控日志配置，但又不想用logback.xml作为Logback配置的名字，可以通过logging.config属性指定自定义的名字：logging.config=classpath:logging-config.xml 五、logback例子1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name="log.path" value="E:\\test\\logback.log" /&gt; &lt;!--输出到控制台--&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt;--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;log.path&#125;&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;logback.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;!--表示只保留最近30天的日志--&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;!--设置为1GB的话，那么到了这个值，就会删除旧的日志。--&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="info"&gt; &lt;appender-ref ref="console" /&gt; &lt;appender-ref ref="file" /&gt; &lt;/root&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name="com.dudu.controller"/&gt; &lt;!--logback.LogbackDemo：类的全路径 --&gt; &lt;logger name="com.dudu.controller.LearnController" level="WARN" additivity="false"&gt; &lt;appender-ref ref="console"/&gt; &lt;/logger&gt;&lt;/configuration&gt; 注：scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 2 表示对日志进行编码：%d{HH: mm:ss.SSS}——日志输出时间%thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用%-5level——日志级别，并且使用5个字符靠左对齐%logger{36}——日志输出者的名字%msg——日志消息%n——平台的换行符 六、开发，测试环境切换1 必须在该文件名logback-spring.xml文件写12345678&lt;!-- 测试环境+开发环境. 多个使用逗号隔开. --&gt;&lt;springProfile name="test,dev"&gt; &lt;logger name="com.dudu.controller" level="info" /&gt;&lt;/springProfile&gt;&lt;!-- 生产环境. --&gt;&lt;springProfile name="prod"&gt; &lt;logger name="com.dudu.controller" level="ERROR" /&gt;&lt;/springProfile&gt; 2 可以启动服务的时候指定 profile （如不指定使用默认），如指定prod 的方式为：java -jar xxx.jar –spring.profiles.active=prod 热部署pom文件添加12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 加载文件资源文件12@Configuration@PropertySource("classpath:test.properties") xml文件123@Configuration@ImportResource(locations=&#123;"classpath:application-bean.xml"&#125;)//locations= &#123;"file:d:/test/application-bean1.xml"&#125; 文件上传跟springMVC类似 配置从xml转向注解1234567891011@Bean public MultipartConfigElement multipartConfigElement() &#123; MultipartConfigFactory factory = new MultipartConfigFactory(); //// 设置文件大小限制 ,超了，页面会抛出异常信息，这时候就需要进行异常信息的处理了; factory.setMaxFileSize("128KB"); //KB,MB /// 设置总上传数据总大小 factory.setMaxRequestSize("256KB"); //Sets the directory location where files will be stored. //factory.setLocation("路径地址"); returnfactory.createMultipartConfig(); &#125;]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>springBoot</tag>
        <tag>categories</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2F2018%2F02%2F11%2Fnginx%2F</url>
    <content type="text"><![CDATA[一、nginx依赖的包 gcc安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：yum install gcc-c++ PCREPCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。yum install -y pcre pcre-devel注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。 zlibzlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。yum install -y zlib zlib-devel opensslOpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。yum install -y openssl openssl-devel或者wget https://www.openssl.org/source/openssl-1.1.0g.tar.gz//https://www.openssl.org/source 二、安装步骤 第一步：把nginx的源码上传到linux系统第二步：把压缩包解压缩。第三步：进行configure。第四步：make第五步：make install同时编译nginx+openssl:./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_gzip_static_module --with-http_ssl_module --with-openssl=/usr/local/openssl-1.1.0g make &amp;&amp; make install生成证书：openssl req -new -x509 -nodes -out server.crt -keyout server.key 三、启停服务关闭nginx：可以使用kill命令，但是不推荐使用。推荐使用：./nginx -s stop刷新配置：./nginx -s reload 四、配置文件配置文件主要由四部分组成：main(全区设置)，server(主机配置)，upstream(负载均衡服务器设置)，和location(URL匹配特定位置设置)。1）全局变量12345678910111213141516171819202122#Nginx的worker进程运行用户以及用户组#user nobody nobody;#Nginx开启的进程数worker_processes 1;#worker_processes auto;#以下参数指定了哪个cpu分配给哪个进程，一般来说不用特殊指定。如果一定要设的话，用0和1指定分配方式.#这样设就是给1-4个进程分配单独的核来运行，出现第5个进程是就是随机分配了。eg:#worker_processes 4 #4核CPU #worker_cpu_affinity 0001 0010 0100 1000#定义全局错误日志定义类型，[debug|info|notice|warn|crit]#error_log logs/error.log info;#指定进程ID存储文件位置#pid logs/nginx.pid;#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n的值保持一致。#vim /etc/security/limits.conf# * soft nproc 65535# * hard nproc 65535# * soft nofile 65535# * hard nofile 65535worker_rlimit_nofile 65535; 2）事件配置123456789events &#123; #use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。 use epoll; #每个进程可以处理的最大连接数，理论上每台nginx服务器的最大连接数为worker_processes*worker_connections。理论值：worker_rlimit_nofile/worker_processes #注意：最大客户数也由系统的可用socket连接数限制（~ 64K），所以设置不切实际的高没什么好处 worker_connections 65535; #worker工作方式：串行（一定程度降低负载，但服务器吞吐量大时，关闭使用并行方式） #multi_accept on; &#125; 3）http参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream;#日志相关定义 #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #定义日志的格式。后面定义要输出的内容。 #1.$remote_addr 与$http_x_forwarded_for 用以记录客户端的ip地址； #2.$remote_user ：用来记录客户端用户名称； #3.$time_local ：用来记录访问时间与时区； #4.$request ：用来记录请求的url与http协议； #5.$status ：用来记录请求状态； #6.$body_bytes_sent ：记录发送给客户端文件主体内容大小； #7.$http_referer ：用来记录从那个页面链接访问过来的； #8.$http_user_agent ：记录客户端浏览器的相关信息 #连接日志的路径，指定的日志格式放在最后。 #access_log logs/access.log main; #只记录更为严重的错误日志，减少IO压力 error_log logs/error.log crit; #关闭日志 #access_log off; #默认编码 #charset utf-8; #服务器名字的hash表大小 server_names_hash_bucket_size 128; #客户端请求单个文件的最大字节数 client_max_body_size 8m; #指定来自客户端请求头的hearerbuffer大小 client_header_buffer_size 32k; #指定客户端请求中较大的消息头的缓存最大数量和大小。 large_client_header_buffers 4 64k; #开启高效传输模式。 sendfile on; #防止网络阻塞 tcp_nopush on; tcp_nodelay on; #客户端连接超时时间，单位是秒 keepalive_timeout 60; #客户端请求头读取超时时间 client_header_timeout 10; #设置客户端请求主体读取超时时间 client_body_timeout 10; #响应客户端超时时间 send_timeout 10;#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k;#gzip模块设置 #开启gzip压缩输出 gzip on; #最小压缩文件大小 gzip_min_length 1k; #压缩缓冲区 gzip_buffers 4 16k; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_http_version 1.0; #压缩等级 1-9 等级越高，压缩效果越好，节约宽带，但CPU消耗大 gzip_comp_level 2; #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_types text/plain application/x-javascript text/css application/xml; #前端缓存服务器缓存经过压缩的页面 gzip_vary on; 4）虚拟主机基本设置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#虚拟主机定义 server &#123; #监听端口 listen 80; #访问域名 server_name localhost; #编码格式，若网页格式与此不同，将被自动转码 #charset koi8-r; #虚拟主机访问日志定义 #access_log logs/host.access.log main; #对URL进行匹配 location / &#123; #访问路径，可相对也可绝对路径 root html; #首页文件。以下按顺序匹配 index index.html index.htm; &#125;#错误信息返回页面 #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;#访问URL以.php结尾则自动转交给127.0.0.1 # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125;#php脚本请求全部转发给FastCGI处理 # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125;#禁止访问.ht页面 （需ngx_http_access_module模块） # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125;#HTTPS虚拟主机定义 # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; 5）Nignx状态监控123456789101112#Nginx运行状态，StubStatus模块获取Nginx自启动的工作状态（编译时要开启对应功能） #location /NginxStatus &#123; # #启用StubStatus的工作访问状态 # stub_status on; # #指定StubStaus模块的访问日志文件 # access_log logs/Nginxstatus.log; # #Nginx认证机制（需Apache的htpasswd命令生成） # #auth_basic "NginxStatus"; # #用来认证的密码文件 # #auth_basic_user_file ../htpasswd; #&#125;访问：http://IP/NginxStatus(测试就不加密码验证相关) 6）反向代理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#以下配置追加在HTTP的全局变量中#nginx跟后端服务器连接超时时间(代理连接超时)proxy_connect_timeout 5;#后端服务器数据回传时间(代理发送超时)proxy_send_timeout 5;#连接成功后，后端服务器响应时间(代理接收超时)proxy_read_timeout 60;#设置代理服务器（nginx）保存用户头信息的缓冲区大小proxy_buffer_size 16k;#proxy_buffers缓冲区，网页平均在32k以下的话，这样设置proxy_buffers 4 32k;#高负荷下缓冲大小（proxy_buffers*2）proxy_busy_buffers_size 64k;#设定缓存文件夹大小，大于这个值，将从upstream服务器传proxy_temp_file_write_size 64k;#反向代理缓存目录proxy_cache_path /data/proxy/cache levels=1:2 keys_zone=cache_one:500m inactive=1d max_size=1g;#levels=1:2 设置目录深度，第一层目录是1个字符，第2层是2个字符#keys_zone:设置web缓存名称和内存缓存空间大小#inactive:自动清除缓存文件时间。#max_size:硬盘空间最大可使用值。#指定临时缓存文件的存储路径(路径需和上面路径在同一分区)proxy_temp_path /data/proxy/temp#服务配置server &#123; #侦听的80端口 listen 80; server_name localhost; location / &#123; #反向代理缓存设置命令(proxy_cache zone|off,默认关闭所以要设置) proxy_cache cache_one; #对不同的状态码缓存不同时间 proxy_cache_valid 200 304 12h; #设置以什么样参数获取缓存文件名 proxy_cache_key $host$uri$is_args$args; #后7端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #代理设置 proxy_pass http://IP; #文件过期时间控制 expires 1d; &#125; #配置手动清楚缓存(实现此功能需第三方模块 ngx_cache_purge) #http://www.123.com/2017/0316/17.html访问 #http://www.123.com/purge/2017/0316/17.html清楚URL缓存 location ~ /purge(/.*) &#123; allow 127.0.0.1; deny all; proxy_cache_purge cache_one $host$1$is_args$args; &#125; #设置扩展名以.jsp、.php、.jspx结尾的动态应用程序不做缓存 location ~.*\.(jsp|php|jspx)?$ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://http://IP; &#125; 7）负载均衡12345678910111213141516171819202122#负载均衡服务器池upstream my_server_pool &#123; #调度算法 #1.轮循（默认）（weight轮循权值） #2.ip_hash：根据每个请求访问IP的hash结果分配。（会话保持） #3.fair:根据后端服务器响应时间最短请求。（upstream_fair模块） #4.url_hash:根据访问的url的hash结果分配。（需hash软件包） #参数： #down：表示不参与负载均衡 #backup:备份服务器 #max_fails:允许最大请求错误次数 #fail_timeout:请求失败后暂停服务时间。 server 192.168.1.109:80 weight=1 max_fails=2 fail_timeout=30; server 192.168.1.108:80 weight=2 max_fails=2 fail_timeout=30;&#125;#负载均衡调用server &#123; ... location / &#123; proxy_pass http://my_server_pool; &#125;&#125; 8）URL重写123456789101112#根据不同的浏览器URL重写if($http_user_agent ~ Firefox)&#123;rewrite ^(.*)$ /firefox/$1 break; &#125;if($http_user_agent ~ MSIE)&#123;rewrite ^(.*)$ /msie/$1 break; &#125;#实现域名跳转location / &#123; rewrite ^/(.*)$ https://web8.example.com$1 permanent;&#125; 9）IP限制1234567#限制IP访问location / &#123; deny 192.168.0.2； allow 192.168.0.0/24; allow 192.168.1.1; deny all;&#125; 10）Nginx相关命令123456#启动nginxnginx #关闭nginxnginx -s stop#平滑重启kill -HUP `cat /usr/local/nginx/logs/nginx.pid` 11）Nginx启动脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#!/bin/bash#chkconfig: 2345 80 90#description:auto_runPATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATH# Check if user is rootif [ $(id -u) != "0" ]; then echo "Error: You must be root to run this script!\n" exit 1fiNGINXDAEMON=/usr/local/nginx/sbin/nginxPIDFILE=/usr/local/nginx/logs/nginx.pidfunction_start()&#123; echo -en "\033[32;49;1mStarting nginx......\n" echo -en "\033[39;49;0m" if [ -f $PIDFILE ]; then printf "Nginx is runing!\n" exit 1 else $NGINXDAEMON printf "Nginx is the successful start!\n" fi&#125;function_stop()&#123; echo -en "\033[32;49;1mStoping nginx......\n" echo -en "\033[39;49;0m" if [ -f $PIDFILE ]; then kill `cat $PIDFILE` printf "Nginx program is stoped\n" else printf "Nginx program is not runing!\n" fi&#125;function_reload()&#123; echo -en "\033[32;49;1mReload nginx......\n" echo -en "\033[39;49;0m" function_stop function_start&#125;function_restart()&#123; echo -en "\033[32;49;1mRestart nginx......\n" echo -en "\033[39;49;0m" printf "Reload Nginx configure...\n" $NGINXDAEMON -t kill -HUP `cat $PIDFILE` printf "Nginx program is reloding!\n"&#125;function_kill()&#123; killall nginx&#125;function_status()&#123; if ! ps -ef|grep -v grep|grep 'nginx:' &gt; /dev/null 2&gt;&amp;1 then printf "Nginx is down!!!\n" else printf "Nginx is running now!\n" fi&#125;if [ "$1" = "start" ]; then function_startelif [ "$1" = "stop" ]; then function_stopelif [ "$1" = "reload" ]; then function_reloadelif [ "$1" = "restart" ]; then function_restartelif [ "$1" = "kill" ]; then function_killelif [ "$1" = "status" ]; then function_statuselse echo -en "\033[32;49;1m Usage: nginx &#123;start|stop|reload|restart|kill|status&#125;\n" echo -en "\033[39;49;0m"fi]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合]]></title>
    <url>%2F2018%2F02%2F10%2FSSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[配置文件web.xml配置12345678910111213141516171819202122232425262728293031&lt;!-- 配置Spring字符编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml,spring-service.xml,spring-web.xml Mybatis - &gt; spring -&gt; springmvc --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;!-- 默认匹配所有的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; spring配置springMVC配置1234567891011121314151617181920&lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven validator="validator"/&gt; &lt;!-- &lt;mvc:annotation-driven /&gt; --&gt; &lt;!-- 2.静态资源默认servlet配置 (1)加入对静态资源的处理：js,gif,png (2)允许使用"/"做整体映射 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--2.获取使用下面的：配置静态资源的访问映射，此配置中的文件，将不被前端控制器拦截 --&gt; &lt;mvc:resources mapping="/js/**" location="/js/"/&gt; &lt;mvc:resources mapping="/css/**" location="/css/"/&gt; &lt;mvc:resources mapping="/fonts/**" location="/fonts/"/&gt; &lt;mvc:resources mapping="/images/**" location="/images/"/&gt; &lt;!-- 3.配置jsp 显示ViewResolver --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; spring-dao配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!-- 加载数据库资源文件 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 配置数据库连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name="maxPoolSize" value="30" /&gt; &lt;property name="minPoolSize" value="10" /&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name="autoCommitOnClose" value="false" /&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name="checkoutTimeout" value="10000" /&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name="acquireRetryAttempts" value="2" /&gt; &lt;/bean&gt; &lt;!-- 配置sqlSessionFactory对象 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml" /&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="com.gao.entity" /&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml" /&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="com.gao.dao" /&gt; &lt;/bean&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package="com.gao.service"/&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" &gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; mybatis配置1234567891011&lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name="useGeneratedKeys" value="true" /&gt; &lt;!-- 使用列别名替换列名 默认:true --&gt; &lt;setting name="useColumnLabel" value="true" /&gt; &lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;/settings&gt; mybatis配置建议使用注解方式:12345@Mapperpublic interface UserMapper &#123; @Select("select * from `user` where username=#&#123;name&#125; and status=0") public User query(String name);&#125; 代码编写Controller代码123456789@Controller @RequestMapping("/mvc") public class mvcController &#123; @RequestMapping("/hello") public String hello()&#123; return "hello"; &#125; &#125; 常用注解@Controller负责注册一个bean 到spring 上下文中@RequestMapping注解为控制器指定可以处理哪些 URL 请求@ResponseBody返回json@ModelAttribute在方法定义上使用@ModelAttribute注解：Spring MVC 在调用目标处理方法前，会先逐个调用在方法级上标注了@ModelAttribute 的方法在方法的入参前使用 @ModelAttribute 注解：可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数 –绑定到对象中，再传入入参将方法入参对象添加到模型中@RequestParam 在处理方法入参处使用 @RequestParam 可以把请求参 数传递给请求方法@RequestParam(value=&quot;name&quot;,defaultValue=&quot;Guest&quot;)//修饰在方法参数里面@PathVariable绑定 URL 占位符到入参123456@RequestMapping("/path/&#123;language&#125;/&#123;id&#125;") public String documentView(Model model, @PathVariable(value = "language") String language, @PathVariable(value = "id") Long id ) &#123; &#125; @ExceptionHandler注解到方法上，出现异常时会执行该方法 @ControllerAdvice使一个Contoller成为全局的异常处理类，类中用@ExceptionHandler方法注解的方法可以处理所有Controller发生的异常@Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。@Component组件@EnableScheduling启动定时任务 传递参数123456789@RequestMapping("/show") public String showPerson(Map&lt;String,Object&gt; map)&#123; Person p =new Person(); map.put("p", p); p.setAge(20); p.setName("jayjay"); return "show";&#125;//前台可在Request域中取到"p" Model model这个放在方法里面的参数，然后就可以model.addAttibute(“key”,value);页面可以获取到Model model, Map model2, ModelMap model3都是同一个对象 request传统方式 123public String view(HttpServletRequest req,HttpSession session)&#123;&#125; 使用redirect方式处理请求12345//redirect @RequestMapping("/redirect")public String redirect()&#123; return "redirect:hello";&#125; 异常的处理12345678@ExceptionHandler(value = UnauthorizedException.class) // 处理访问方法时权限不足问题 public String handle(Exception e) &#123; ModelAndView mv = new ModelAndView("error"); mv.addObject("exception", ex); System.out.println("in testExceptionHandler"); return mv; &#125; //ModelAndView 跳转加设置参数 自定义拦截器创建一个MyInterceptor类，并实现HandlerInterceptor接口123456789101112131415161718建一个MyInterceptor类，并实现HandlerInterceptor接口 @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; System.out.println("afterCompletion"); &#125; @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; System.out.println("postHandle"); &#125; @Override public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, //先執行, Object arg2) throws Exception &#123; System.out.println("preHandle"); return true; &#125; 编写拦截器类实现接口HandlerInterceptor，重写方法afterCompletion，postHandler，preHandler(执行时三种方法的执行步骤为，controller方法前执行preHandler，执行controller方法后执行postHandler、afterCompletion) 将拦截器注册到springMVC框架中（springmvc配置文件）：12345678910&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;bean class="com.gao.interceptor.LoginInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/news/del"/&gt; &lt;bean class="com.gao.interceptor.LimitInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 数据效验12345678910111213141516171819202122&lt;!-- 配置校验器 --&gt;&lt;bean id="validator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"&gt; &lt;!-- 校验器，使用hibernate校验器 --&gt; &lt;property name="providerClass" value="org.hibernate.validator.HibernateValidator"/&gt; &lt;!-- 指定校验使用的资源文件，在文件中配置校验错误信息，如果不指定则默认使用classpath下面的ValidationMessages.properties文件 --&gt; &lt;property name="validationMessageSource" ref="messageSource"/&gt;&lt;/bean&gt;&lt;!-- 校验错误信息配置文件 --&gt;&lt;bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt; &lt;!-- 资源文件名 --&gt; &lt;property name="basenames"&gt; &lt;list&gt; &lt;value&gt;classpath:CustomValidationMessage&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 资源文件编码格式 --&gt; &lt;property name="fileEncodings" value="utf-8"/&gt; &lt;!-- 对资源文件内容缓存时间，单位秒 --&gt; &lt;property name="cacheSeconds" value="120"/&gt;&lt;/bean&gt;&lt;!--注入--&gt;&lt;mvc:annotation-driven validator="validator"/&gt; 实体类1234 @Size(min=3,max=10,message="&#123;errors.title&#125;")private String tTitle;@NotNull(message="&#123;errors.content&#125;")private String tContent; controller12345678910111213@RequestMapping(value="/add",method=RequestMethod.POST)public String add(@Validated News news,BindingResult br,Model model)&#123; //@validated 是@valid一次封装 if(br.hasErrors())&#123; List&lt;ObjectError&gt; errors = br.getAllErrors(); model.addAttribute("errors", errors); //errors.get(0).getDefaultMessage(); FieldError name = br.getFieldError("tTitle"); System.out.println(name.getDefaultMessage()); return "addnews"; &#125; &#125; 文件上传12345678910111213141516171819&lt;!-- 文件上传的配置 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 指定所上传文件的总大小不能超过200KB。注意maxUploadSize属性的限制不是针对单个文件，而是所有文件的容量之和 --&gt; &lt;property name="maxUploadSize" value="200000" /&gt; &lt;property name="defaultEncoding" value="UTF-8"/&gt; &lt;/bean&gt; &lt;!-- 该异常是SpringMVC在检查上传的文件信息时抛出来的，而且此时还没有进入到Controller方法中 --&gt; &lt;bean id="exceptionResolver" class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;!-- 遇到MaxUploadSizeExceededException异常时，自动跳转到WebContent目录下的error.jsp页面 --&gt; &lt;prop key="org.springframework.web.multipart.MaxUploadSizeExceededException"&gt;404&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; controller123456789101112131415161718192021222324252627282930313233343536373839404142@RequestMapping(value="/upload") public String upload(@RequestParam MultipartFile[] myfile,HttpServletRequest request) throws Exception&#123; for (MultipartFile multipartFile : myfile) &#123; if(multipartFile.isEmpty())&#123; System.out.println("文件未上传"); &#125;else&#123; String fileName = multipartFile.getOriginalFilename(); String path1 = request.getSession().getServletContext().getRealPath("image")+File.separator; String path = path1 + new SimpleDateFormat("yyyyMMddHHmmss").format(new Date())+fileName; System.out.println(path); File localFile = new File(path); multipartFile.transferTo(localFile); &#125; &#125; return ""; &#125; @RequestMapping("/download") public String download(String fileName, HttpServletRequest request, HttpServletResponse response) throws Exception&#123; response.setCharacterEncoding("utf-8"); response.setContentType("multipart/form-data"); response.setHeader("Content-Disposition", "attachment;fileName=" + fileName); String path = request.getSession().getServletContext().getRealPath ("image")+File.separator; InputStream inputStream = new FileInputStream(new File(path + fileName)); OutputStream os = response.getOutputStream(); byte[] b = new byte[2048]; int length; while ((length = inputStream.read(b)) &gt; 0) &#123; os.write(b, 0, length); &#125; // 这里主要关闭。 os.close(); inputStream.close(); return null; &#125;]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务中的隔离级别]]></title>
    <url>%2F2018%2F01%2F21%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[来自： 数据库事务中的隔离级别和锁+spring Transactional注解 数据库事务中的隔离级别和锁 数据库事务在后端开发中占非常重要的地位，如何确保数据读取的正确性、安全性也是我们需要研究的问题。ACID首先总结一下数据库事务正确执行的四个要素（ACID）： 原子性（Atomicity）：即事务是不可分割的最小工作单元，事务内的操作要么全做，要么全不做，不能只做一部分；一致性（Consistency）：在事务执行前数据库的数据处于正确的状态，而事务执行完成后数据库的数据还是处于正确的状态，即数据完整性约束没有被破坏；比如我们做银行转账的相关业务，A转账给B，要求A转的钱B一定要收到。如果A转了钱而B没有收到，那么数据库数据的一致性就得不到保障，在做高并发业务时要注意合理的设计。隔离性（Isolation）：并发事务执行之间无影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性；持久性（Durability）：事务一旦执行成功，它对数据库的数据的改变必须是永久的，不会因各种异常导致数据不一致或丢失。事务隔离级别大部分数据库事务操作都是并发执行的，这就可能遇到下面的几种问题： 丢失更新：两个事务同时更新一行数据，最后一个事务的更新会覆盖掉第一个事务的更新，从而导致第一个事务更新的数据丢失，后果比较严重。一般是由于没加锁的原因造成的。脏读（Dirty reads）：一个事务A读取到了另一个事务B还没有提交的数据，并在此基础上进行操作。如果B事务rollback，那么A事务所读取到的数据就是不正确的，会带来问题。不可重复读（Non-repeatable reads）：在同一事务范围内读取两次相同的数据，所返回的结果不同。比如事务B第一次读数据后，事务A更新数据并commit，那么事务B第二次读取的数据就与第一次是不一样的。幻读（Phantom reads）：一个事务A读取到了另一个事务B新提交的数据。比如，事务A对一个表中所有行的数据按照某规则进行修改（整表操作），同时，事务B向表中插入了一行原始数据，那么后面事务A再对表进行操作时，会发现表中居然还有一行数据没有被修改，就像发生了幻觉，飘飘欲仙一样。注意：不可重复读和幻读的区别是，不可重复读对应的表的操作是更改(UPDATE)，而幻读对应的表的操作是插入(INSERT)，两种的应对策略不一样。对于不可重复读，只需要采用行级锁防止该记录被更新即可，而对于幻读必须加个表级锁，防止在表中插入数据。有关锁的问题，下面会讨论。 为了处理这几种问题，SQL定义了下面的4个等级的事务隔离级别： 未提交读（READ UNCOMMITTED ）：最低隔离级别，一个事务能读取到别的事务未提交的更新数据，很不安全，可能出现丢失更新、脏读、不可重复读、幻读；提交读（READ COMMITTED）：一个事务能读取到别的事务提交的更新数据，不能看到未提交的更新数据，不会出现丢失更新、脏读，但可能出现不可重复读、幻读；可重复读（REPEATABLE READ）：保证同一事务中先后执行的多次查询将返回同一结果，不受其他事务影响，不可能出现丢失更新、脏读、不可重复读，但可能出现幻读；序列化（SERIALIZABLE）：最高隔离级别，不允许事务并发执行，而必须串行化执行，最安全，不可能出现更新、脏读、不可重复读、幻读，但是效率最低。隔离级别越高，数据库事务并发执行性能越差，能处理的操作越少。所以一般地，推荐使用REPEATABLE READ级别保证数据的读一致性。对于幻读的问题，可以通过加锁来防止。MySQL支持这四种事务等级，默认事务隔离级别是REPEATABLE READ。Oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别，所以Oracle数据库不支持脏读。Oracle数据库默认的事务隔离级别是READ COMMITTED。 各种锁下面总结一下MySQL中的锁，有好几种分类。其它RDBMS也差不多是这样。首先最重要的分类就是乐观锁(Optimistic Lock)和悲观锁(Pessimistic Lock)，这实际上是两种锁策略。乐观锁，顾名思义就是非常乐观，非常相信真善美，每次去读数据都认为其它事务没有在写数据，所以就不上锁，快乐的读取数据，而只在提交数据的时候判断其它事务是否搞过这个数据了，如果搞过就rollback。乐观锁相当于一种检测冲突的手段，可通过为记录添加版本或添加时间戳来实现。悲观锁，对其它事务抱有保守的态度，每次去读数据都认为其它事务想要作祟，所以每次读数据的时候都会上锁，直到取出数据。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性，但随之而来的是各种开销。悲观锁相当于一种避免冲突的手段。选择标准：如果并发量不大，或数据冲突的后果不严重，则可以使用乐观锁；而如果并发量大或数据冲突后果比较严重（对用户不友好），那么就使用悲观锁。 从读写角度，分共享锁（S锁，Shared Lock）和排他锁（X锁，Exclusive Lock），也叫读锁（Read Lock）和写锁（Write Lock）。理解： 持有S锁的事务只读不可写。如果事务A对数据D加上S锁后，其它事务只能对D加上S锁而不能加X锁。持有X锁的事务可读可写。如果事务A对数据D加上X锁后，其它事务不能再对D加锁，直到A对D的锁解除。从锁的粒度角度，主要分为表级锁（Table Lock）和行级锁（Row Lock）。表级锁将整个表加锁，性能开销最小。用户可以同时进行读操作。当一个用户对表进行写操作时，用户可以获得一个写锁，写锁禁止其他的用户读写操作。写锁比读锁的优先级更高，即使有读操作已排在队列中，一个被申请的写锁仍可以排在所队列的前列。行级锁仅对指定的记录进行加锁，这样其它进程可以对同一个表中的其它记录进行读写操作。行级锁粒度最小，开销大，能够支持高并发，可能会出现死锁。 MySQL的MyISAM引擎使用表级锁，而InnoDB支持表级锁和行级锁，默认是行级锁。还有BDB引擎使用页级锁，即一次锁定一组记录，并发性介于行级锁和表级锁之间。 三级锁协议三级加锁协议是为了保证正确的事务并发操作，事务在读、写数据库对象是需要遵循的加锁规则。 一级封锁协议：事务T在修改数据R之前必须对它加X锁，直到事务结束方可释放。而若事务T只是读数据，不进行修改，则不需加锁，因此一级加锁协议下可能会出现脏读和不可重复读。二级加锁协议：在一级加锁协议的基础上，加上这样一条规则——事务T在读取数据R之前必须对它加S锁，直到读取完毕以后释放。二级加锁协议下可能会出现不可重复读。三级加锁协议：在一级加锁协议的基础上，加上这样一条规则——事务T在读取数据R之前必须对它加S锁，直到事务结束方可释放。三级加锁协议避免了脏读和不可重复读的问题。 spring @Transactional注解参数详解 事物注解方式: @Transactional 当标于类前时, 标示类中所有方法都进行事物处理 , 例子: 1 @Transactional public class TestServiceBean implements TestService {}当类中某些方法不需要事物时: 1234567891011@Transactional public class TestServiceBean implements TestService &#123; private TestDao dao; public void setDao(TestDao dao) &#123; this.dao = dao; &#125; @Transactional(propagation =Propagation.NOT_SUPPORTED)public List getAll() &#123; return null; &#125; &#125; 事物传播行为介绍: 123456789101112@Transactional(propagation=Propagation.REQUIRED) ;//如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)@Transactional(propagation=Propagation.NOT_SUPPORTED) ;//容器不为这个方法开启事务@Transactional(propagation=Propagation.REQUIRES_NEW) ;//不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务@Transactional(propagation=Propagation.MANDATORY) ;//必须在一个已有的事务中执行,否则抛出异常@Transactional(propagation=Propagation.NEVER) ;//必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)@Transactional(propagation=Propagation.SUPPORTS) ;//如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务. 事物超时设置: @Transactional(timeout=30) //默认是30秒 事务隔离级别: @Transactional(isolation = Isolation.READ_UNCOMMITTED)：读取未提交数据(会出现脏读, 不可重复读) 基本不使用 @Transactional(isolation = Isolation.READ_COMMITTED)：读取已提交数据(会出现不可重复读和幻读) @Transactional(isolation = Isolation.REPEATABLE_READ)：可重复读(会出现幻读) @Transactional(isolation = Isolation.SERIALIZABLE)：串行化 MYSQL: 默认为REPEATABLE_READ级别 SQLSERVER: 默认为READ_COMMITTED 脏读 : 一个事务读取到另一事务未提交的更新数据不可重复读 : 在同一事务中, 多次读取同一数据返回的结果有所不同, 换句话说,后续读取可以读到另一事务已提交的更新数据. 相反, “可重复读”在同一事务中多次读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事务已提交的更新数据幻读 : 一个事务读到另一个事务已提交的insert数据 @Transactional注解中常用参数说明 参数名称 功能描述 readOnly 该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。例如：@Transactional(readOnly=true) rollbackFor 该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。例如： 指定单一异常类：@Transactional(rollbackFor=RuntimeException.class) 指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class}) rollbackForClassName 该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。例如： 指定单一异常类名称：@Transactional(rollbackForClassName=“RuntimeException”) 指定多个异常类名称：@Transactional(rollbackForClassName={“RuntimeException”,”Exception”}) noRollbackFor 该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。例如： 指定单一异常类：@Transactional(noRollbackFor=RuntimeException.class) 指定多个异常类：@Transactional(noRollbackFor={RuntimeException.class, Exception.class}) noRollbackForClassName 该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。例如： 指定单一异常类名称：@Transactional(noRollbackForClassName=“RuntimeException”) 指定多个异常类名称： @Transactional(noRollbackForClassName={“RuntimeException”,”Exception”}) propagation 该属性用于设置事务的传播行为，具体取值可参考表6-7。 例如：@Transactional(propagation=Propagation.NOT_SUPPORTED,readOnly=true) isolation 该属性用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置 timeout 该属性用于设置事务的超时秒数，默认值为-1表示永不超时 注意的几点: 1、@Transactional 只能被应用到public方法上, 对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能. 2、用 spring 事务管理器,由spring来负责数据库的打开,提交,回滚.默认遇到运行期例外(throw new RuntimeException(“注释”);)会回滚，即遇到不受检查（unchecked）的例外时回滚；而遇到需要捕获的例外(throw new Exception(“注释”);)不会回滚,即遇到受检查的例外（就是非运行时抛出的异常，编译器会检查到的异常叫受检查例外或说受检查异常）时，需我们指定方式来让事务回滚要想所有异常都回滚,要加上 @Transactional( rollbackFor={Exception.class,其它异常}) .如果让unchecked例外不回滚：@Transactional(notRollbackFor=RunTimeException.class)如下: 12345678@Transactional(rollbackFor=Exception.class) //指定回滚,遇到异常Exception时回滚public void methodName() &#123; throw new Exception("注释");&#125;@Transactional(noRollbackFor=Exception.class)//指定不回滚,遇到运行期例外(throw new RuntimeException("注释");)会回滚public ItimDaoImpl getItemDaoImpl() &#123; throw new RuntimeException("注释");&#125; 3、@Transactional 注解应该只被应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。 4、@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。然而，请注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅 是一种元数据，能够被可以识别 @Transactional 注解和上述的配置适当的具有事务行为的beans所使用。上面的例子中，其实正是 元素的出现 开启 了事务行为。 5、Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因此，请接受Spring团队的建议并且在具体的类上使用 @Transactional 注解。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centOS 7]]></title>
    <url>%2F2018%2F01%2F19%2FcentOs7%2F</url>
    <content type="text"><![CDATA[FTP的搭建和使用https://help.aliyun.com/knowledge_detail/60152.htmlcentos7通过yum安装JDK1.8 安装之前先检查一下系统有没有自带open-jdk命令：rpm -qa |grep javarpm -qa |grep jdkrpm -qa |grep gcj 如果没有输入信息表示没有安装。如果安装可以使用rpm -qa | grep java | xargs rpm -e –nodeps 批量卸载所有带有Java的文件 这句命令的关键字是java首先检索包含java的列表 yum list java* 检索1.8的列表 yum list java-1.8* 安装1.8.0的所有文件 yum install java-1.8.0-openjdk* -y 使用命令检查是否安装成功 java -version CentOS7安装ActiveMQ1、下载activemq，下载地址：http://archive.apache.org/dist/activemq。测试版本为apache-activemq-5.14.1。 2、在/ursr/local/目录下新建activemq文件夹，并进入该文件夹，执行如下命令解压文件。123cd /ursr/localmkdir activemqtar -xzvf apache-activemq-5.14.1-bin.tar.gz 3、在/etc/init.d/目录增加增加activemq文件，文件内容为：12cd /etc/init.d/vi activemq 12345678910111213141516171819202122232425262728293031#!/bin/sh## /etc/init.d/activemq# chkconfig: 345 63 37# description: activemq servlet container.# processname: activemq 5.14.3 # Source function library.#. /etc/init.d/functions# source networking configuration.#. /etc/sysconfig/network #export JAVA_HOME=/usr/local/jdk1.8.0_121export CATALINA_HOME=/usr/local/activemq/apache-activemq-5.14.3 case $1 in start) sh $CATALINA_HOME/bin/activemq start ;; stop) sh $CATALINA_HOME/bin/activemq stop ;; restart) sh $CATALINA_HOME/bin/activemq stop sleep 1 sh $CATALINA_HOME/bin/activemq start ;; esacexit 0 4、对activemq文件授予权限。 hmod 777 activemq5、设置开机启动并启动activemq hkconfig activemq onervice activemq start 5、访问地址：http://IP地址:8161/。 访问成功，ActiveMQ安装完毕。默认用户名密码为：admin/admin。 6、其他 查看activemq状态service activemq status其他和关闭activemq服务12service activemq startservice activemq stop 设置开机启动或不启动activemq服务12chkconfig activemq onchkconfig activemq off Linux系统下yum命令查看安装了哪些软件包：$yum list installed //列出所有已安装的软件包yum针对软件包操作常用命令：1.使用YUM查找软件包命令：yum search2.列出所有可安装的软件包命令：yum list3.列出所有可更新的软件包命令：yum list updates4.列出所有已安装的软件包命令：yum list installed5.列出所有已安装但不在 Yum Repository 内的软件包命令：yum list extras6.列出所指定的软件包命令：yum list7.使用YUM获取软件包信息命令：yum info8.列出所有软件包的信息命令：yum info9.列出所有可更新的软件包信息命令：yum info updates10.列出所有已安装的软件包信息命令：yum info installed11.列出所有已安装但不在 Yum Repository 内的软件包信息命令：yum info extras12.列出软件包提供哪些文件命令：yum provides如何查看yum安装的软件路径 rpm -qa|grep 软件包名 rpm -ql 软件包名 (l是L的小写,不是坚线) rpm常用命令1.安装一个包rpm -ivh2.升级一个包rpm -Uvh3.移走一个包rpm -e4.安装参数–force 即使覆盖属于其它包的文件也强迫安装–nodeps 如果该RPM包的安装依赖其它包，即使其它包没装，也强迫安装。5.查询一个包是否被安装rpm -q &lt; rpm package name&gt;6.得到被安装的包的信息rpm -qi &lt; rpm package name&gt;7.列出该包中有哪些文件rpm -ql &lt; rpm package name&gt;8.列出服务器上的一个文件属于哪一个RPM包rpm -qf9.可综合好几个参数一起用rpm -qil &lt; rpm package name&gt;10.列出所有被安装的rpm packagerpm -qa11.列出一个未被安装进系统的RPM包文件中包含有哪些文件？rpm -qilp &lt; rpm package name&gt; apt-get常用命令apt-cache search package 搜索软件包apt-cache show package 获取包的相关信息，如说明、大小、版本等sudo apt-get install package 安装包sudo apt-get install package –reinstall 重新安装包sudo apt-get -f install 修复安装sudo apt-get remove package 删除包sudo apt-get remove package –purge 删除包，包括配置文件等sudo apt-get update 更新源sudo apt-get upgrade 更新已安装的包sudo apt-get dist-upgrade 升级系统apt-cache depends package 了解使用该包依赖那些包apt-cache rdepends package 查看该包被哪些包依赖sudo apt-get build-dep package 安装相关的编译环境apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包sudo apt-get check 检查是否有损坏的依赖 其他源码安装1 ./configure 相关库文人件以及配置参数并生成make file2 make 对源码进行编译，生成可执行文件3 make install 将生成的可执行文件安装到当前计算机中rpm 基础命令安装软件 ： rpm -i software.rpm卸装软件 : rpm -e software升级形式安装: rpm -U software-new.rpmrpm支持通过http,ftp协议安装软件rpm -lvh http://www.linuxcast.net/software.rpm可以加入以下参数-v显示相关信息-h显示进度条 通常都会加上参数eg: rpm -ivh software.rpm 使用service 管理cd /etc/init.d新建 文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA注解]]></title>
    <url>%2F2018%2F01%2F15%2FJAVA%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. 注解的定义注解通过 @interface 关键字进行定义。12public @interface TestAnnotation &#123;&#125; 2. 注解的应用123@TestAnnotationpublic class Test &#123;&#125; 3. 元注解元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种 1、@RetentionRetention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。 它的取值如下： RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 我们可以这样的方式来加深理解，@Retention 去给一张标签解释的时候，它指定了这张标签张贴的时间。@Retention 相当于给一张标签上面盖了一张时间戳，时间戳指明了标签张贴的时间周期。123@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123;&#125; 2、Documented顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。 3、@TargetTarget 是目标的意思，@Target 指定了注解运用的地方。 你可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。 类比到标签，原本标签是你想张贴到哪个地方就到哪个地方，但是因为 @Target 的存在，它张贴的地方就非常具体了，比如只能张贴到方法上、类上、方法参数上等等。@Target 有下面的取值 ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 4、@Inherited被@Inherited注解过的类，子类继承它，同时子类也拥有该注解 5、@RepeatableRepeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。 什么样的注解会多次应用呢？通常是注解的值可以同时取多个。 举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。123456789101112131415@interface Persons &#123; Person[] value();&#125;@Repeatable(Persons.class)@interface Person&#123; String role default "";&#125;@Person(role="artist")@Person(role="coder")@Person(role="PM")public class SuperMan&#123;&#125; 4. 注解的属性12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; int id(); String msg(); int age() default 18; //默认值&#125; 使用：1234@TestAnnotation(id=3,msg="hello annotation") //age默认值18public class Test &#123; &#125; 如果该注解只有value一个属性 那可以直接使用@TestAnnotation(“value”) 5. Java 预置的注解1、@Deprecated过时的方法、过时的类、过时的成员变量 2、@SuppressWarnings忽略@Deprecated这种警告 3、@FunctionalInterface函数式接口注解，这个是 Java 1.8 版本引入的新特性。函数式编程很火，所以 Java 8 也及时添加了这个特性。 5. 注解与反射。(如何被使用)1、通过反射获取注解解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {} 然后通过 getAnnotation() 方法来获取 Annotation 对象。public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {} 或者是 getAnnotations() 方法。public Annotation[] getAnnotations() {} 前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了。比如1234567891011121314151617@TestAnnotation()public class Test &#123; public static void main(String[] args) &#123; boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class); if ( hasAnnotation ) &#123; TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class); System.out.println("id:"+testAnnotation.id()); System.out.println("msg:"+testAnnotation.msg()); &#125; &#125;&#125; 2、属性、方法上的注解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@TestAnnotation(msg="hello")public class Test &#123; @Check(value="hi") int a; @Perform public void testMethod()&#123;&#125; @SuppressWarnings("deprecation") public void test1()&#123; Hero hero = new Hero(); hero.say(); hero.speak(); &#125; public static void main(String[] args) &#123; boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class); if ( hasAnnotation ) &#123; TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class); //获取类的注解 System.out.println("id:"+testAnnotation.id()); System.out.println("msg:"+testAnnotation.msg()); &#125; try &#123; Field a = Test.class.getDeclaredField("a"); a.setAccessible(true); //获取一个成员变量上的注解 Check check = a.getAnnotation(Check.class); if ( check != null ) &#123; System.out.println("check value:"+check.value()); &#125; Method testMethod = Test.class.getDeclaredMethod("testMethod"); if ( testMethod != null ) &#123; // 获取方法中的注解 Annotation[] ans = testMethod.getAnnotations(); for( int i = 0;i &lt; ans.length;i++) &#123; System.out.println("method testMethod annotation:"+ans[i].annotationType().getSimpleName()); &#125; &#125; &#125; catch (NoSuchFieldException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(e.getMessage()); &#125; catch (SecurityException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(e.getMessage()); &#125; catch (NoSuchMethodException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(e.getMessage()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA泛型]]></title>
    <url>%2F2018%2F01%2F15%2FJAVA%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、介绍泛型只在编译阶段有效。泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。Java泛型中常用的标记符含义： E - Element (在集合中使用，因为集合中存放的是元素) T - Type（Java 类） K - Key（键） V - Value（值） N - Number（数值类型） ? - 表示不确定的java类型 泛型判断：T instanceof Object 二、泛型的使用1. 泛型类泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。 举例：123456789101112public class Test&lt;T&gt;&#123; private T key; public Test(T key) &#123; this.key = key; &#125; public T getKey()&#123; return key; &#125;&#125; 2. 泛型接口泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子： 定义一个泛型接口123public interface Generator&lt;T&gt; &#123; public T next();&#125; 当实现泛型接口的类，也要定义泛型，不然会报错1234567891011/**java * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot; */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125; 传入泛型实参就不会123public class FruitGenerator implements Generator&lt;String&gt; &#123; //...&#125; 3. 泛型通配符定义一个泛型通配符方法123public void showKeyValue1(Generic&lt;?&gt; obj)&#123; Log.d("泛型测试","key value is " + obj.getKey());&#125; ?代表 当具体类型不确定的时候，这个通配符就是 ?123List&lt;? extends Number&gt; eList = null;eList = new ArrayList&lt;Integer&gt;();eList = new ArrayList&lt;Long&gt;(); 4. 泛型方法定义一个泛型方法12345678910111213141516171819/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 * 泛型的数量也可以为任意多个 * 如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; * ... * &#125; */public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException , IllegalAccessException&#123; T instance = tClass.newInstance(); return instance;&#125; 5. 泛型方法与可变参数T… args 6. 静态方法与泛型如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。 参考:http://blog.csdn.net/s10461/article/details/53941091/]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql常用]]></title>
    <url>%2F2018%2F01%2F11%2FMySql%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[常用1. 常用函数 DATE_ADD(date,INTERVAL i keyword)返回date加上 i 时期keyword可以为：SECONDMINUTEHOURDAYWEEKMONTHQUARTERYEAR DATE_SUB(date,INTERVAL i keyword) 与上面相反 DATE_FORMAT(create_date,’%H%i’)时间格式化：%Y %D %M %h:%i:%s %Y%m%d MONTHNAME(date) 返回date的月份名(英语月份，如October)DAYNAME(date) 返回date的星期名(英语星期几，如Saturday)NOW() 返回当前的日期和时间 如：2016-10-08 18:57:39CURDATE()或CURRENT_DATE() 返回当前的日期CURTIME()或CURRENT_TIME() 返回当前的时间QUARTER(date) 返回date在一年中的季度(1~4)WEEK(date) 返回日期date为一年中第几周(0~53)DAYOFYEAR(date) 返回date是一年的第几天(1~366)DAYOFMONTH(date) 返回date是一个月的第几天(1~31)DAYOFWEEK(date) 返回date所代表的一星期中的第几天(1~7)YEAR(date) 返回日期date的年份(1000~9999)MONTH(date) 返回date的月份值(1~12)DAY(date) 返回date的天数部分HOUR(time) 返回time的小时值(0~23)MINUTE(time) 返回time的分钟值(0~59)SECOND(time) 返回time的秒值（0-59）DATE(datetime) 返回datetime的日期值TIME(datetime) 返回datetime的时间值 TO_DAYS(create_date)返回从0年开始 到date之间的天数 2.系统表 DATABASE() 返回当前数据库名BENCHMARK(count,expr) 将表达式expr重复运行count次CONNECTION_ID() 返回当前客户的连接IDFOUND_ROWS() 返回最后一个SELECT查询进行检索的总行数USER()或SYSTEM_USER() 返回当前登陆用户名VERSION() 返回MySQL服务器的版本 MySQL常用系统表大全：http://blog.csdn.net/xlxxcc/article/details/51754524 3.连接查询 INNER JOIN：如果表中有至少一个匹配，则返回行LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行FULL JOIN：只要其中一个表中存在匹配，则返回行 4.优化速度MySQL数据库优化的八种方式(经典必看)https://www.cnblogs.com/zhyunfe/p/6209074.html centOS 7 安装mysql1.使用安装命令 ：yum -y install mysql mysql-server mysql-devel安装完成却发现Myserver安装缺失，在网上找原因，原来是因为CentOS 7上把MySQL从默认软件列表中移除了，用MariaDB来代替，所以这导致我们必须要去官网上进行下载，找到链接，用wget打开： a. wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm b. rpm -ivh mysql-community-release-el7-5.noarch.rpm c. yum -y install mysql mysql-server mysql-devel，安装成功。 启动服务service mysqld start 进入客户端mysql -u root -p 输入密 常用数据库操作 mysql数据库使用总结本文主要记录一些mysql日常使用的命令，供以后查询。1.更改root密码mysqladmin -uroot password ‘yourpassword’2.远程登陆mysql服务器mysql -uroot -p -h192.168.137.10 -P33063.查询数据库show databases;4.进入某个数据库use databasename;5.列出数据库中的表show tables;6.查看某个表全部字段desc slow_log;show create table slow_log\G; （不仅可以显示表信息，还可以显示建表语句）7.查看当前用户select user();8.查看当前所在数据库select database();9.创建新数据库（可以指定字符集）create database db1 charset utf8;10.创建新表create table t1 (id int(4), name char(40));11.查看数据库版本select version();12.查看数据库状态show status; 当前会话状态show global status; 全局数据库状态show slave status\G; 查看主从数据库状态信息13.查询数据库参数show variables;14.修改数据库参数show variables like ‘max_connect%’;set global max_connect_errors = 1000;（重启数据库会失效，要在配置文件中修改）15.查看当前数据库队列show processlist;16.创建普通用户并授权给某个数据库grant all on databasename. to ‘user1’@’localhost’ identified by ‘123456’;17.查询表数据select from mysql.db; //查询该表中的所有字段select count() from mysql.user; //count()表示表中有多少行select db,user from mysql.db; //查询表中的多个字段select * from mysql.db where host like ‘10.0.%’;在查询语句中可以使用万能匹配 “%”18.插入一行数据insert into db1.t1 values (1, ‘abc’);19.更改表的某一行数据update db1.t1 set name=’aaa’ where id=1;20.清空表数据truncate table db1.t1;21.删除表drop table db1.t1;22.清空数据库中的所有表（数据库名是eab12）mysql -N -s information_schema -e “SELECT CONCAT(‘TRUNCATE TABLE ‘,TABLE_NAME,’;’) FROM TABLES WHERE TABLE_SCHEMA=’eab12’” | mysql -f eab1223.删除数据库drop database db1;24.数据库备份mysqldump -uroot -p’yourpassword’ mysql &gt;/tmp/mysql.sql25.数据库恢复mysql -uroot -p’yourpassword’ mysql &lt;/tmp/mysql.sql26.新建普通用户CREATE USER name IDENTIFIED BY ‘ssapdrow’;27.更改普通用户密码SET PASSWORD FOR name=PASSWORD(‘fdddfd’);28.查看name用户权限SHOW GRANTS FOR name;29.脚本中执行mysql命令mysql -uuser -ppasswd -e”show databases”echo “show databases”|mysql -uuser -ppassword以下是执行大量mysql语句采用的方式mysql -uuser -hhostname -ppasswd &lt;&lt; EOFmysql语句EOF 原文链接：https://www.cnblogs.com/suxiaoman/p/7693066.html MySQL创建用户与授权一. 创建用户命令: CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;说明： username：你将创建的用户名host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器例子：12345CREATE USER 'dog'@'localhost' IDENTIFIED BY '123456';CREATE USER 'pig'@'192.168.1.101_' IDENDIFIED BY '123456';CREATE USER 'pig'@'%' IDENTIFIED BY '123456';CREATE USER 'pig'@'%' IDENTIFIED BY '';CREATE USER 'pig'@'%'; 二. 授权:命令: GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;说明: privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALLdatabasename：数据库名tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用表示，如.*例子:12GRANT SELECT, INSERT ON test.user TO &apos;pig&apos;@&apos;%&apos;;GRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;; 注意: 用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令: GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39; WITH GRANT OPTION; 三.设置与更改用户密码命令: SET PASSWORD FOR &#39;username&#39;@&#39;host&#39; = PASSWORD(&#39;newpassword&#39;);如果是当前登陆用户用: SET PASSWORD = PASSWORD(“newpassword”);例子: SET PASSWORD FOR &#39;pig&#39;@&#39;%&#39; = PASSWORD(&quot;123456&quot;); 四. 撤销用户权限命令: REVOKE privilege ON databasename.tablename FROM &#39;username&#39;@&#39;host&#39;;说明: privilege, databasename, tablename：同授权部分 例子: REVOKE SELECT ON *.* FROM &#39;pig&#39;@&#39;%&#39;;注意: 假如你在给用户’pig’@’%’授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO ‘pig’@’%’，则在使用REVOKE SELECT ON . FROM ‘pig’@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON . TO ‘pig’@’%’;则REVOKE SELECT ON test.user FROM ‘pig’@’%’;命令也不能撤销该用户对test数据库中user表的Select权限。 具体信息可以用命令SHOW GRANTS FOR ‘pig’@’%’; 查看。 五.删除用户命令: DROP USER &#39;username&#39;@&#39;host&#39;; 原文链接：https://www.jianshu.com/p/d7b9c468f20d]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle常用]]></title>
    <url>%2F2018%2F01%2F10%2FOracle%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、基本常用语句1. 索引、主键、序列、权限 索引新建索引：create index 索引名 on 表名(列名,……)删除索引：drop index ttt;新建唯一索引：create unique index 索引名 on 表名（列名……）唯一索引用途：一个数据列，不能作为主键，而且允许为空，但是业务上要求唯一特性，这个时候用唯一性索引就是最好的旋转 主键新建主键：alter table 表名 add constraint 主键名 primary key(主键列)删除主键/外键：alter table drop constraint 主键名新建外键：alter table add constraint 外键名 foreign key(外键列) 序列创建序列：create sequence squ_tstart with 1minvalue 1maxvalue 999increment by 1nocycle //是否循环，建议不使用nocache; //是否启用缓存。使用缓存可以提高sequence的访问效率序列属性：1.nextval : 返回下一个可用的序列值。就算是被不同的用户调用，每次也返回一个唯一的值。2.currval ：获取序列当前的值。在currval调用之前，必须保证nextval已经获取过一次值。删除序列：drop sequence squ_t 权限：grant 权限等级(select,insert,update,delete) on 权限内容（table,视图，sequence,index） to (aaaaa)aaaaaa:public:对所有用户开放权限group 分组名:对该组所有用户开放权限username:对指定用户开放权限grant select on tablename to scott回收权限：revoke select on tablename from scott exists in区别：IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情 2.常用函数 nvl(x1,x2)当x1为null时返回X2,否则返回x1 instr(C1,C2,i,j)C1 被搜索的字符串C2 希望搜索的字符串I 搜索的开始位置,默认为1J 出现的位置,默认为1i为负数，从右边开始算起 length()字符串长度 ltrim(‘’,’’)左截取，对应右截取rtrim(‘’,’’)trim() 修剪 substr(s,i,j) abs() 绝对值 add_months(date,i)返回日期date加上i月的结果。i小数，直接向下取整 last_day(d)返回d月的最后一天日期 trunc(date,format)1.select trunc(sysdate) from dual –2011-3-18 今天的日期为2011-3-182.select trunc(sysdate, ‘mm’) from dual –2011-3-1 返回当月第一天.3.select trunc(sysdate,’yy’) from dual –2011-1-1 返回当年第一天4.select trunc(sysdate,’dd’) from dual –2011-3-18 返回当前年月日5.select trunc(sysdate,’yyyy’) from dual –2011-1-1 返回当年第一天6.select trunc(sysdate,’d’) from dual –2011-3-13 (星期天)返回当前星期的第一天7.select trunc(sysdate, ‘hh’) from dual –2011-3-18 14:00:00 当前时间为14:418.select trunc(sysdate, ‘mi’) from dual –2011-3-18 14:41:00 TRUNC()函数没有秒的精确Number 需要截尾取整的数字。Num_digits 用于指定取整精度的数字Num_digits 的默认值为 0。TRUNC()函数截取时不进行四舍五入 to_char(data,format)to_char(oper_time,’yyyyMMddhh24’) DECODE(x,y,z,k,j,i)if (x==y) :z else if(x==k) :j else :i 3.其他常用： SQL执行顺序(8) SELECT (9) DISTINCT (11) (1) FROM (3) JOIN (2) ON (4) WHERE (5) GROUP BY (6) WITH {CUBE | ROLLUP}(7) HAVING (10) ORDER BY 二、系统内置表：https://www.cnblogs.com/jiangxinnju/p/5840420.html 三、提高oracle查询效率https://www.2cto.com/database/201301/181269.html]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本常用]]></title>
    <url>%2F2018%2F01%2F09%2Fshell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一.内部常用命令 echo 在屏幕上输出-n 不会换行-e 会识别换行符\n printf 产生各种格式的输出 export 定义全局变量 export 变量名=变量值 read 读入数据read -p “我是提示语句” file-t 指定等待时间-n指定字符串长度-s 隐藏输入的数据-p：输入提示符 exec如：exec echo $ashell里，作为独立进程去执行该命令 exprexpr length “this is a test”expr substr “this is a test” 3 5expr index “sarasara” aexpr 10 + 10 //+、-、、/、%expr 30 \ 3 //乘用 反斜杠*表示 二、控制、循环语句1. if语句1234567891011#!/bin/bashcd ..if [ -f test1.txt ]then echo test.txt is a fail; cat test1.txtelif [ -d shell ]then echo in shell is dir; dir shell #打印出shell目录中的内容fi 注意： 数值判断： -eq 等于 -ge 大于等于 -gt 大于 -le 小于等于 -lt 小于 -ne 不等于字符串判断（两边有个空格） = 等于 != 不等于 -z 字符串长度为零 -n 字符串长度不为零文件测试 -d 如果文件存在且为目录，则为真 -e 如果文件存在 -f 如果文件存在且为普通文件 -r ….且可读 -w ….且可写 -x ….且可执行 -s ….且至少有一个字符 2.switch语句123456789101112#!/bin/bashcd ..echo "please choice to display is file";echo "1:display test.txt";echo "2:display test1.txt";echo enter your choice;read -p "please in num:" varcase $var in 1) cat test.txt;; 2) cat test1.txt;; *) echo error;;esac 3.for语句123456#!/bin/bashfor num in 1 2 3 4 5 6 7 8 9 10 do echo $num is: expr $num \* $numdone 4.while语句123456789#!/bin/bashecho "please input number(gt 100 will quit)"; read num;while [ $num -lt 100 ]do echo result: expr $num \* $num; read num; done 5. until语句12345678910#!/bin/bash echo "please input fileName:" read filename; echo "please input fileContent(in 'end! quit!!!'):" read fileContent; until [ $fileContent = "end!" ] do $fileContent &gt;&gt; $filename #写内容到这个文件去 echo "please input fileContent(in 'end! quit!!!'):" read fileContent done 三、其他常用 引号含义：反引号：shell中 会首先执行反引号的代码单引号：不是解释，原封不动打印出来双引号：解释变量，而且保留空格没有引号：解释变量，不会保留空格 $符号含义$#表示用户输入参数的个数$0 是脚本本身的名字$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误$$ 是脚本运行的当前进程ID号$@$*$! 后台运行程序的pid都是代表说有， $@每一个会被区别对待num# 8# 16# 2# 代表进制 运算sum=$(($sum$i)) 等于 let “sum=sumi” == s$i == ${i} 小括号，中括号，双括号，大括号区别if ($i&lt;5) 12345678if [ $i -lt 5 ] if [ $a -ne 1 -a $a != 2 ] if [ $a -ne 1] &amp;&amp; [ $a != 2 ] if [[ $a != 1 &amp;&amp; $a != 2 ]] for i in $(seq 0 4);do echo $i;done for i in `seq 0 4`;do echo $i;done for ((i=0;i&lt;5;i++));do echo $i;done for i in &#123;0..4&#125;;do echo $i;done 注意shell脚本对空格有严格的规定，赋值语句等号两边不能有空格，而字符串比较，等号两边必须有空格]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux高级]]></title>
    <url>%2F2018%2F01%2F09%2Flinux%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[sed命令sed命令行格式为： sed [-nefri] ‘command’ 输入文本 常用选项： -n∶使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。 set -n ‘20,30p’ 文件 常与p结合使用 set -参数 ‘/条件/ c\ sfdasf’ 文件 -e∶直接在指令列模式上进行 sed 的动作编辑； set -e -n 20,30p’ a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～ sed ‘/100/ a bbb’ 文件 c ∶取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！ d ∶删除，因为是删除啊，所以 d 后面通常不接任何咚咚； sed ‘/^9/d’ count.log sed ‘100d’ count.log sed ‘2,$d’ count.log i ∶插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)； p ∶列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作～ s ∶取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！ 要替换时，如果“原内容”或“新内容”中含有特殊字符（比如”/”或者”#”等），可以使用其它符号把各部分隔开，比如以下几种格式都是正确的 sed -i ‘s,原内容,新内容,g’ 文件 sed -i ‘s#原内容#新内容#g’ 文件 sed -i ‘s:原内容:新内容:g’ 文件 sed -i ‘s~原内容~新内容~g’ 文件 匹配规则： . 匹配任意一个字符 * 匹配0 个或多个*前的字符 ^ 匹配行开头 $ 匹配行结尾 awk命令 格式 格式:awk -F: ‘BEGIN {处理文件前执行的代码块} ｛处理文件过程中执行的代码块} END {处理文件后执行的代码块}’ filename如：cat count.log|awk ‘BEGIN{a=1;b=2}{print $(a+b)}END{print $1}’awk -F: ‘BEGIN {print “这是第一行”} {print $0} END {print “这是最后一行”}’print $1,$2 打印多个用逗号，$0代表整行。其中+和?只适用于awk而不适用于grep或sed:+ 匹配一个或一个以上前面的单字符? 匹配0个或一个前面的单字符举例:/XY+Z/ 匹配XYZ、XYYYYZ/XY?Z/ 匹配XYZ、XZ~ 匹配正则表达式!~ 不匹配正则表达式 awk有许多内置变量用来设置环境信息，常用的有 ARGC 命令行参数个数ARGV 命令行参数排列ENVIRON 支持队列中系统环境变量的使用FILENAME awk读取的文件名FNR 当前文件已处理的记录行数FS 设置域分隔符，相当于-FNF 域的列数echo ‘/user/apache/conf/httpd.conf’|awk -F/ ‘{print $NF}’NR 已处理的记录总行数OFS 设置输出字段域分隔符RS/ORS 换行符 举例 awk ‘{name=$1;belts=$4;if(belts ~ /Yellow/) print name “is belt “belts}’ grade.txtawk ‘{if($1==”ley”)$7=$7-40; print $0}’ grade.txtawk ‘BEGIN{print “Name\tDifference”}{if ($6&lt;$7){$8=$7-$6;print $1,$8}}’ gra //模拟第8列出来awk ‘BEGIN {print “Name\tDifference”} {if ($6 &lt; $7) {diff = $7 - $6; print $1,diff}}’ grade.txt //同上，不模拟列，直接给变量awk ‘total+=$6;END{print total}’ gradeawk ‘{total+=$6;END{print total}}’ grade*//区别： 上面的所有内容就将会打印出来，下面的只会打印结果 函数 awk有很多强大的字符串函数:gsub(r,s,t) 在整个字符串t中用字符串s替代所有满足正则表达式r的字符串（如没指定t则默认为$0）index(s,t) 返回字符串s中字符串t第一次出现的位置（如不存在则为0）length(s) 返回s字符串的长度（如没指定s则默认为$0）match(s,r) 返回第一个满足正则表达式r的字符串在s字符串里面的位置（如无匹配的则为0）split(s,a,sep) 使用sep将字符串s分隔成为数组a的元素，返回数组元素的数量（如果没指定分隔符则默认与FS相同用法）sprint(“fmt”,exp) 使用printf的格式说明对表达式exp 进行格式化输出sub(r,s,t) 在字符串t中用s字符串替换满足正则表达式r的第一个字符串，返回1如果成功，否则返回0（如没指定t则默认为$0）substr(s,p,n) 返回字符串s中以p位置开始长度为n的字符串（如果没指定n则返回从p位置开始的所有字符串）tolower(s) 将字符串s中的所有大写字母转换为小写，返回转换后的字符串toupper(s) 将字符串s中的所有小写字母转换为大写，返回转换后的字符串 vim 插入命令 i 在当前位置生前插入I 在当前行首插入a 在当前位置后插入A 在当前行尾插入o 在当前行之后插入一行O 在当前行之前插入一行 查找命令 ngg 12gg 跳转12行 或者 :12/xxx ?xxx 向上查找 向下查找ctrl + f 向下翻页 同 page down.ctrl + b 向上翻页 同 page up.ctrl + d 向下翻半页 此比较有用ctrl + u 向上翻半页 此比较有用ctrl + e 向下翻一行ctrl + y 向上一行跳到文本的最后一行：按“G”,即“shift+g” 其他常用 u 撤销（Undo）Ctrl + r 重做（Rx 删除当前字符edo），即撤销的撤销。x 删除当前字符dd 删除当前行10d 删除当前行开始的10行。 其他常用 加载文件顺序 etc/profile–&gt;~/.bash_profile–&gt;~/.bashrc–&gt;/etc/bashrc source /etc/profile 重新加载该文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令进阶]]></title>
    <url>%2F2018%2F01%2F09%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[df命令（查看磁盘情况） 12345678df -i 以inode模式来显示磁盘使用情况df -t ext3 显示指定类型磁盘df -ia 列出各文件系统的i节点使用情况df -h 以更易读的方式显示目前磁盘空间和使用情况 du命令 12345678du log30.tar.gz log31.tar.gz显示多个文件所占空间du -s 只显示总和的大小du -ah test文件和目录都显示du -c log30.tar.gz log31.tar.gz显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和 cp -R 连目录一起复制 chmod命令 12345678u ：目录或者文件的当前的用户g ：目录或者文件的当前的群组o ：除了目录或者文件的当前用户或群组之外的用户或者群组a ：所有的用户及群组chmod 751 file 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限chmod u=rwx,g=rx,o=x file 同上 chown命令 1234567chown [选项]... [所有者][:[组]] 文件...chown mail:mail log2012.log 改变拥有者和群组chown :mail log2012.log 改变文件群组chown -R root:mail test6 改变指定目录以及其子目录下的所有文件的拥有者和群组 ftp命令 123456789ftp 192.168.1.1get 路径 //下载文件mget *.* //下载多个文件put 1.htm /usr/your/2.htm 把本地的1.htm传送到远端主机/usr/your,并改名为2.htmmput *.htm 将本地主机中一批文件传送至远端主机。bye 断开连接 tar 123 -v ：压缩的过程中显示文件！这个常用-c 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。相当于打包。-f ：使用档名，请留意，在 f 之后要立即接档 grep 参数 查找条件 文件名。 12345678910111213141516171819202122主要参数： －c：只输出匹配行的计数。 －I：不区分大 小写(只适用于单字符。 －l：查询多文件时只输出包含匹配字符的文件名。 －n：显示匹配行及 行号。 －s：不显示不存在或无匹配文本的错误信息。 －v：显示不包含匹配文本的所有行。 grep: . 匹配任意一个字符 * 匹配0 个或多个*前的字符 ^ 匹配行开头 $ 匹配行结尾 [options]主要参数： \： 忽略正则表达式中特殊字符的原有含义。 ^：匹配正则表达式的开始行。 $: 匹配正则表达式的结束行。 \&lt;：从匹配正则表达 式的行开始。 \&gt;：到匹配正则表达式的行结束。 [ ]：单个字符，如[A]即A符合要求 。 [ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。 .：所有的单个字符。 * ：有字符，长度可以为0。 env 显示当前用户变量，set显示全局变量 cut 12-f列号：提取第几列-d分隔符：按照指定分隔符分隔列（默认是一个制表符当分隔符） sort排序 123456789sort [选项]-f 忽略大小写-n 以数值型进行排序-r 反向排序-t 指定分隔符,默认是制表符-k n[,m] 按照指定的字段范围排序.从第n字段开始,m字段结束(默认到行尾) sort -n -t &quot;:&quot; -k 3,3 /etc/passwd sort -t &quot;:&quot; -k 3,3 /etc/passwd sort -r /etc/passwd find 12345678910111213141516171819find . -size 25k 查找文件大小是25K的文件 -25K 小于 25K 等于25K +25K 大于find /etc -size +20K -a -size 50k 查找/etc下，大于20K并且小于50K文件 -a 逻辑与 and -o 逻辑或 orfind /etc -size +20K -a -size -50k -exec ls -lh &#123;&#125; \; -exec 命令 &#123;&#125; \; 对搜索结果执行操作find /var/log/ -mtime +10 查找10天前修改的文件 -10 10天内修改文件 10 10天当天修改的文件 +10 10天前修改的文件 atime 文件访问时间 ctime 改变文件属性 mtime 修改文件内容 crontab命令选项: 1234-u指定一个用户-l列出某个用户的任务计划-r删除某个用户的任务-e编辑某个用户的任务 ssh 123456ssh ip/用户名@ip 两种方式ssh ip -p 222 指定端口SCP[-r] 用户名@ip：文件路径 本地路径下载文件scp [-r] 本地文件 用户名@ip：上传路径上传文件 nohup]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用 150 个命令汇总]]></title>
    <url>%2F2018%2F01%2F08%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[命令 功能说明 线上查询及帮助命令 (2 个) man 查看命令帮助，命令的词典，更复杂的还有 info，但不常用。 help 查看 Linux 内置命令的帮助，比如 cd 命令。 文件和目录操作命令 (18 个) ls 全拼 list，功能是列出目录的内容及其内容属性信息。 cd 全拼 change directory，功能是从当前工作目录切换到指定的工作目录。 cp 全拼 copy，其功能为复制文件或目录。 find 查找的意思，用于查找目录及目录下的文件。 mkdir 全拼 make directories，其功能是创建目录。 mv 全拼 move，其功能是移动或重命名文件。 pwd 全拼 print working directory，其功能是显示当前工作目录的绝对路径。 rename 用于重命名文件。 rm 全拼 remove，其功能是删除一个或多个文件或目录。 rmdir 全拼 remove empty directories，功能是删除空目录。 touch 创建新的空文件，改变已有文件的时间戳属性。 tree 功能是以树形结构显示目录下的内容。 basename 显示文件名或目录名。 dirname 显示文件或目录路径。 chattr 改变文件的扩展属性。 lsattr 查看文件扩展属性。 file 显示文件的类型。 md5sum 计算和校验文件的 MD5 值。 查看文件及内容处理命令（21 个） cat 全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。 tac tac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。 more 分页显示文件内容。 less 分页显示文件内容，more 命令的相反用法。 head 显示文件内容的头部。 tail 显示文件内容的尾部。 cut 将文件的每一行按指定分隔符分割并输出。 split 分割文件为不同的小片段。 paste 按行合并文件内容。 sort 对文件的文本内容排序。 uniq 去除重复行。oldboy wc 统计文件的行数、单词数或字节数。 iconv 转换文件的编码格式。 dos2unix 将 DOS 格式文件转换成 UNIX 格式。 diff 全拼 difference，比较文件的差异，常用于文本文件。 vimdiff 命令行可视化文件比较工具，常用于文本文件。 rev 反向输出文件内容。 grep/egrep 过滤字符串，三剑客老三。 join 按两个文件的相同字段合并。 tr 替换或删除字符。 vi/vim 命令行文本编辑器。 文件压缩及解压缩命令（4 个） tar 打包压缩。oldboy unzip 解压文件。 gzip gzip 压缩工具。 zip 压缩工具。 信息显示命令（11 个） uname 显示操作系统相关信息的命令。 hostname 显示或者设置当前系统的主机名。 dmesg 显示开机信息，用于诊断系统故障。 uptime 显示系统运行时间及负载。 stat 显示文件或文件系统的状态。 du 计算磁盘空间使用情况。 df 报告文件系统磁盘空间的使用情况。 top 实时显示系统资源使用情况。 free 查看系统内存。 date 显示与设置系统时间。 cal 查看日历等时间信息。 搜索文件命令（4 个） which 查找二进制命令，按环境变量 PATH 路径查找。 find 从磁盘遍历查找文件或目录。 whereis 查找二进制命令，按环境变量 PATH 路径查找。 locate 从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用 updatedb 更新库。 用户管理命令（10 个） useradd 添加用户。 usermod 修改系统已经存在的用户属性。 userdel 删除用户。 groupadd 添加用户组。 passwd 修改用户密码。 chage 修改用户密码有效期限。 id 查看用户的 uid,gid 及归属的用户组。 su 切换用户身份。 visudo 编辑 / etc/sudoers 文件的专属命令。 sudo 以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。 基础网络操作命令（11 个） telnet 使用 TELNET 协议远程登录。 ssh 使用 SSH 加密协议远程登录。 scp 全拼 secure copy，用于不同主机之间复制文件。 wget 命令行下载文件。 ping 测试主机之间网络的连通性。 route 显示和设置 linux 系统的路由表。 ifconfig 查看、配置、启用或禁用网络接口的命令。 ifup 启动网卡。 ifdown 关闭网卡。 netstat 查看网络状态。 ss 查看网络状态。 深入网络操作命令（9 个） nmap 网络扫描命令。 lsof 全名 list open files，也就是列举系统中已经被打开的文件。 mail 发送和接收邮件。 mutt 邮件管理命令。 nslookup 交互式查询互联网 DNS 服务器的命令。 dig 查找 DNS 解析过程。 host 查询 DNS 的命令。 traceroute 追踪数据传输路由状况。 tcpdump 命令行的抓包工具。 有关磁盘与文件系统的命令（16 个） mount 挂载文件系统。 umount 卸载文件系统。 fsck 检查并修复 Linux 文件系统。 dd 转换或复制文件。 dumpe2fs 导出 ext2/ext3/ext4 文件系统信息。 dump ext2/3/4 文件系统备份工具。 fdisk 磁盘分区命令，适用于 2TB 以下磁盘分区。 parted 磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。 mkfs 格式化创建 Linux 文件系统。 partprobe 更新内核的硬盘分区表信息。 e2fsck 检查 ext2/ext3/ext4 类型文件系统。 mkswap 创建 Linux 交换分区。 swapon 启用交换分区。 swapoff 关闭交换分区。 sync 将内存缓冲区内的数据写入磁盘。 resize2fs 调整 ext2/ext3/ext4 文件系统大小。 系统权限及用户授权相关命令（4 个） chmod 改变文件或目录权限。 chown 改变文件或目录的属主和属组。 chgrp 更改文件用户组。 umask 显示或设置权限掩码。 查看系统用户登陆信息的命令（7 个） whoami 显示当前有效的用户名称，相当于执行 id -un 命令。 who 显示目前登录系统的用户信息。 w 显示已经登陆系统的用户列表，并显示用户正在执行的指令。 last 显示登入系统的用户。 lastlog 显示系统中所有用户最近一次登录信息。 users 显示当前登录系统的所有用户的用户列表。 finger 查找并显示用户信息。 内置命令及其它（19 个） echo 打印变量，或直接输出指定的字符串 printf 将结果格式化输出到标准输出。 rpm 管理 rpm 包的命令。 yum 自动化简单化地管理 rpm 包的命令。 watch 周期性的执行给定的命令，并将命令的输出以全屏方式显示。 alias 设置系统别名。 unalias 取消系统别名。 date 查看或设置系统时间。 clear 清除屏幕，简称清屏。 history 查看命令执行的历史纪录。 eject 弹出光驱。 time 计算命令执行时间。 nc 功能强大的网络工具。 xargs 将标准输入转换成命令行参数。 exec 调用并执行指令的命令。 export 设置或者显示环境变量。 unset 删除变量或函数。 type 用于判断另外一个命令是否是内置命令。 bc 命令行科学计算器 系统管理与性能监视命令 (9 个) chkconfig 管理 Linux 系统开机启动项。 vmstat 虚拟内存统计。 mpstat 显示各个可用 CPU 的状态统计。 iostat 统计系统 IO。 sar 全面地获取系统的 CPU、运行队列、磁盘 I/O、分页（交换区）、内存、 CPU 中断和网络等性能数据。 ipcs 用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。 ipcrm 用来删除一个或更多的消息队列、信号量集或者共享内存标识。 strace 用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。 ltrace 命令会跟踪进程的库函数调用, 它会显现出哪个库函数被调用。 关机 / 重启 / 注销和查看系统信息的命令（6 个） shutdown 关机。 halt 关机。 poweroff 关闭电源。 logout 退出当前登录的 Shell。 exit 退出当前登录的 Shell。 Ctrl+d 退出当前登录的 Shell 的快捷键。 进程管理相关命令（15 个） bg 将一个在后台暂停的命令，变成继续执行 （在后台执行）。 fg 将后台中的命令调至前台继续运行。 jobs 查看当前有多少在后台运行的命令。 kill 终止进程。 killall 通过进程名终止进程。 pkill 通过进程名终止进程。 crontab 定时任务命令。 ps 显示进程的快照。 pstree 树形显示进程。 nice/renice 调整程序运行的优先级。 nohup 忽略挂起信号运行指定的命令。 pgrep 查找匹配条件的进程。 runlevel 查看系统当前运行级别。 init 切换运行级别。 service 启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。 来源：banana 童www.cnblogs.com/bananaaa/p/7774467.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro在SpringBoot中配置]]></title>
    <url>%2F2018%2F01%2F08%2FShiro%E5%9C%A8SpringBoot%E4%B8%AD%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一、什么是Shiro​ Shiro是一个很易用与Java项目的的安全框架，主要提供了提供了认证、授权、加密、会话管理功能。 二、Shiro主要记住哪些 ShiroFilterFactory Shiro核心类 SecurityManager 用于管理所有的Subject Subject 当前用户操作 Realms 用于进行权限信息的验证，也是我们需要自己实现的。 三、步骤：1.pom.xml中添加Shiro依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; 2.注入ShiroFilterFactory和SecurityManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/** * shiro配置 * * @Description: * @author: gaojindeng * @Time: 2018年1月6日 下午4:31:00 * */@Configurationpublic class ShiroConfig &#123; /** * ShiroFilterFactoryBean 处理拦截资源文件问题。 * 注意：单独一个ShiroFilterFactoryBean配置是或报错的，以为在 * 初始化ShiroFilterFactoryBean的时候需要注入：SecurityManager * * Filter Chain定义说明 1、一个URL可以配置多个Filter，使用逗号分隔 2、当设置多个过滤器时，全部验证通过，才视为通过 * 3、部分过滤器可指定参数，如perms，roles * */ @Bean public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 必须设置 SecurityManager shiroFilterFactoryBean.setSecurityManager(securityManager); // 如果不设置默认会自动寻找Web工程根目录下的"/login.jsp"页面 shiroFilterFactoryBean.setLoginUrl("/login"); // 登录成功后要跳转的链接 shiroFilterFactoryBean.setSuccessUrl("/index"); // 未授权界面; shiroFilterFactoryBean.setUnauthorizedUrl("/error"); // 拦截器. Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;(); // 配置不会被拦截的链接 顺序判断 // 配置退出过滤器,其中的具体的退出代码Shiro已经替我们实现了 filterChainDefinitionMap.put("/logout", "logout"); filterChainDefinitionMap.put("/css/**", "anon"); filterChainDefinitionMap.put("/fonts/**", "anon"); filterChainDefinitionMap.put("/image/**", "anon"); filterChainDefinitionMap.put("/js/**", "anon"); filterChainDefinitionMap.put("/favicon.ico", "anon"); filterChainDefinitionMap.put("/", "anon"); filterChainDefinitionMap.put("/register", "anon"); filterChainDefinitionMap.put("/index/**", "anon"); // 首页 filterChainDefinitionMap.put("/charts/**", "anon");// 图表 filterChainDefinitionMap.put("/statistics/**", "anon");// 统计 filterChainDefinitionMap.put("/about/**", "anon");// 关于 // filterChainDefinitionMap.put("/setup/**", "authc"); // filterChainDefinitionMap.put("/capital/entrustment", // "perms[user:admin:*]"); // filterChainDefinitionMap.put("/capital/entrustment", "authc"); // &lt;!-- 过滤链定义，从上向下顺序执行，一般将 /**放在最为下边 --&gt;:这是一个坑呢，一不小心代码就不好使了; // &lt;!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问--&gt; filterChainDefinitionMap.put("/**", "authc"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); System.out.println("Shiro拦截器工厂类注入成功"); return shiroFilterFactoryBean; &#125; @Bean public SecurityManager securityManager() &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 设置realm. securityManager.setRealm(myShiroRealm()); return securityManager; &#125; /** * 身份认证realm; (这个需要自己写，账号密码校验；权限等) * * @return */ @Bean public MyShiroRealm myShiroRealm() &#123; MyShiroRealm myShiroRealm = new MyShiroRealm(); myShiroRealm.setCredentialsMatcher(hashedCredentialsMatcher()); return myShiroRealm; &#125; /** * 开启shiro aop注解支持. 使用代理方式;所以需要开启代码支持; * * @param securityManager * @return */ @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) &#123; AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; &#125; /** * 该方法不加上，权限认证也可以通过 * * @return */ /* @Bean public static LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() &#123; return new LifecycleBeanPostProcessor(); &#125;*/ /** * 不加上这个 权限注解通过不了 * * @return */ @Bean public static DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() &#123; return new DefaultAdvisorAutoProxyCreator(); &#125; /** * 凭证匹配器 （由于我们的密码校验交给Shiro的SimpleAuthenticationInfo进行处理了 * 所以我们需要修改下doGetAuthenticationInfo中的代码; ） * * @return */ @Bean public HashedCredentialsMatcher hashedCredentialsMatcher() &#123; HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher(); hashedCredentialsMatcher.setHashAlgorithmName("md5");// 散列算法:这里使用MD5算法; hashedCredentialsMatcher.setHashIterations(2);// 散列的次数，比如散列两次，相当于 // md5(md5("")); return hashedCredentialsMatcher; &#125;&#125;注入ShiroFactory==&gt;SecurityManager==&gt;RealmRealm是实现权限认证、授权的，所有要自己手动新建这个类### 3.Realm代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class MyShiroRealm extends AuthorizingRealm &#123; @Autowired private IUserSV userSV; /** * 认证信息.(身份验证) : Authentication 是用来验证用户身份 * * @param token * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; // 获取用户的输入的账号. String username = (String) token.getPrincipal(); // 通过username从数据库中查找 User对象，如果找到，没找到. // 实际项目中，这里可以根据实际情况做缓存，如果不做，Shiro自己也是有时间间隔机制，2分钟内不会重复执行该方法 User userInfo = userSV.queryByName(username); if (userInfo == null) &#123; return null; &#125; // 加密方式; // 交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配，如果觉得人家的不好可以自定义实现 SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(userInfo, // 用户名 userInfo.getPassword(), // 密码 ByteSource.Util.bytes(userInfo.getSalt()), // //salt=username+salt getName() // realm name ); // 明文: 若存在，将此用户存放到登录认证info中，无需自己做密码对比，Shiro会为我们进行密码对比校验 // SimpleAuthenticationInfo authenticationInfo = new // SimpleAuthenticationInfo( // userInfo, //用户名 // userInfo.getPassword(), //密码 // getName() //realm name // ); return authenticationInfo; &#125; /** * 此方法调用 hasRole,hasPermission的时候才会进行回调. * * 权限信息.(授权): 1、如果用户正常退出，缓存自动清空； 2、如果用户非正常退出，缓存自动清空； * 3、如果我们修改了用户的权限，而用户不退出系统，修改的权限无法立即生效。 （需要手动编程进行实现；放在service进行调用） * 在权限修改后调用realm中的方法，realm已经由spring管理，所以从spring中获取realm实例， 调用clearCached方法； * :Authorization 是授权访问控制，用于对用户进行的操作授权，证明该用户是否允许进行当前操作，如访问某个链接，某个资源文件等。 * * @param principals * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; /* * 当没有使用缓存的时候，不断刷新页面的话，这个代码会不断执行， 当其实没有必要每次都重新设置权限信息，所以我们需要放到缓存中进行管理； * 当放到缓存中时，这样的话，doGetAuthorizationInfo就只会执行一次了， 缓存过期之后会再次执行。 */ System.out.println("权限配置--&gt;MyShiroRealm.doGetAuthorizationInfo()"); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); User userInfo = (User) principals.getPrimaryPrincipal(); // 实际项目中，这里可以根据实际情况做缓存，如果不做，Shiro自己也是有时间间隔机制，2分钟内不会重复执行该方法 // UserInfo userInfo = userInfoService.findByUsername(username) // 权限单个添加; // authorizationInfo.addRole("admin"); // 添加权限 // authorizationInfo.addStringPermission("userInfo:query"); for (Role role : userInfo.getRoles()) &#123; authorizationInfo.addRole(role.getType()); for (Permission p : role.getPermissions()) &#123; authorizationInfo.addStringPermission(p.getPermission()); &#125; &#125; return authorizationInfo; &#125;&#125; 4.controller层代码1234567891011121314151617181920212223242526272829// 登录提交地址和配置文件的登录url一致 @RequestMapping(value = "/login", method = RequestMethod.POST) public String login(HttpServletRequest request, Map&lt;String, Object&gt; map) throws Exception &#123; System.out.println("HomeController.login()"); // 登录失败从request中获取shiro处理的异常信息。 // shiroLoginFailure:就是shiro异常类的全类名. String exception = (String) request.getAttribute("shiroLoginFailure"); System.out.println("exception=" + exception); String msg = ""; if (exception != null) &#123; if (UnknownAccountException.class.getName().equals(exception)) &#123; System.out.println("UnknownAccountException -- &gt; 账号不存在："); msg = "UnknownAccountException -- &gt; 账号不存在："; &#125; else if (IncorrectCredentialsException.class.getName().equals(exception)) &#123; System.out.println("IncorrectCredentialsException -- &gt; 密码不正确："); msg = "IncorrectCredentialsException -- &gt; 密码不正确："; &#125; else if ("kaptchaValidateFailed".equals(exception)) &#123; System.out.println("kaptchaValidateFailed -- &gt; 验证码错误"); msg = "kaptchaValidateFailed -- &gt; 验证码错误"; &#125; else &#123; msg = "else &gt;&gt; " + exception; System.out.println("else -- &gt;" + exception); &#125; &#125; map.put("msg", msg); // 此方法不处理登录成功,由shiro进行处理. return "/login"; &#125; 5.没有权限页面跳转​ 新建全局异常类123456789@ControllerAdvicepublic class ExceptionHandle &#123; @ExceptionHandler(value = UnauthorizedException.class) // 处理访问方法时权限不足问题 @ResponseBody public String handle(Exception e) &#123; return "&lt;script&gt;alert('没有权限访问！');window.history.back();&lt;/script&gt;"; &#125;&#125; 四、其他1.获取密文：1Object obj = new SimpleHash("md5", user.getPassword(), ByteSource.Util.bytes(user.getSalt()) , 2); //获取MD5加密后的密文 2是加密次数 2.错误页面处理​ 新建error文件夹，404，500错误会自动找到该页面 ​ springBoot错误，也可以新建error.html视图，也会自动找该页面 3.为什么要用盐​ 希望即使两个原始密码相同，加密得到的两个字符串也不同。 4.前端怎么传值过来​ 表单中的参数固定name写法是username、password、rememberMe。]]></content>
      <categories>
        <category>安全认证框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis多对一、多对多注解方式实现]]></title>
    <url>%2F2018%2F01%2F07%2FMyBatis%E5%A4%9A%E5%AF%B9%E4%B8%80%E3%80%81%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[用户和角色多对多，角色和权限多对多。用户表、角色表、权限表、加两个中间表。 不用多说，直接上代码用户表：123456789public interface UserMapper &#123; @Select("select * from `user` where username=#&#123;name&#125;") @Results(&#123;@Result(id=true,property="id",column="id"), @Result(property="name",column="name"), @Result(property="type",column="type"), @Result(property="roles",column="id",javaType=List.class, many=@Many(select="com.gjd.dao.RoleMapper.queryById"))&#125;) User queryByName(String name);&#125; 角色表：1234567891011public interface RoleMapper &#123; @Select("select * from `role` r,`user_role` u where u.rid=r.id and u.uid=#&#123;id&#125;") @Results(&#123;@Result(id=true,property="id",column="id"), @Result(property="name",column="name"), @Result(property="permission",column="permission"), @Result(property="resourceType",column="resourceType"), @Result(property="url",column="url"), @Result(property="permissions",column="id",javaType=List.class, many=@Many(select="com.gjd.dao.PermissionMapper.queryById"))&#125;) List&lt;Role&gt; queryById(long id);&#125; 权限表：1234public interface PermissionMapper &#123; @Select("select * from `role_permission` r,`permission` p where r.rid=#&#123;id&#125; and r.pid=p.id") List&lt;Permission&gt; queryById(long id);&#125; 一对多、多对一把many=@Many替换成one=@One就好了。]]></content>
      <categories>
        <category>JAVA框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js常用和AJAX]]></title>
    <url>%2F2017%2F12%2F30%2Fjs%E5%92%8CJQuery%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[JS项目常用 判断数据类型typeof(s) 字符串：&quot;string&quot;，数字：&quot;number&quot;； 找指定的子标签单个：$(order).find(&quot;i&quot;);多个：$(order).find(&quot;i&quot;).each (function(i,data) ....)； 遍历指定class 元素$(&quot;.capital-order&quot;).each(function(i, data) {...} DOM获取value和namedata.value data.name jquery获取value和name$().val() ；$().attr(&quot;name&quot;) jquery中attr和prop的区别对应DOM中attribute()和properties() attr获取的是原始的值，prop是结果，比如checked、selected、disabled attr获取到的是里面的值，而prop是true或者false 设置标签属性的值$().attr(&quot;key&quot;,&quot;value&quot;); 修改css的值$(&quot;&quot;).css(&quot;key&quot;,&quot;value&quot;);dom.style.${css名称} 获取/设置标签内容$(&quot;&quot;).html(&quot;&quot;);$(&quot;&quot;).text()dom.innerHTML dom.innerText 四舍五入Number(数值).toFixed(2) 转intparseInt(s) 跳转页面window.location.href=url; 追加append(text); 找出其他同类元素，除了自己$(&quot;&quot;).siblings() 把from里的有name标签的封装成对象$(&quot;form表单&quot;).serialize() 判断标签是否存在某个class$(i).hasClass(&quot;c-red&quot;) 隐藏光标，设置字体为红色text-shadow:0 0 0 red;color:transparent; 触发按钮事件$(&quot;#close&quot;).trigger(&quot;click&quot;); 显示/隐藏切换jq：$(&quot;p&quot;).hide(); $(&quot;p&quot;).show();js：ui.style.display=&quot;none&quot;; ui.style.display=&quot;&quot;;其他：ui.style.visibility= &quot;visible/hidden&quot;; 查询父标签$(&#39;#items1&#39;).closest(&#39;.parent1&#39;);$(&#39;#items1&#39;).parents(&#39;.parent1&#39;); 点击事件$(&quot;#strategy&quot;).trigger(&quot;click&quot;); 添加/删除class$(&quot;#&quot;).addClass();$(&quot;#&quot;).removeClass(); AJAX js原生方式： 创建XMLHttpRequest对象 12345if (window.ActiveXObject) &#123; req = new ActiveXObject("Microsoft.XMLHTTP");&#125; else &#123; req = new XMLHttpRequest();&#125; 与服务器建立连 1234//method:get|post url:服务器相对或绝对路径 asynch:true|false 默认为true;req.open("post", "user",true);//Post提交方式需要设置Request头部信息req.setRequestHeader("Content-type","application/x-www-form-urlencoded"); 发送请求 1req.send("name=" + name + "&amp;pwd=" + pwd); 设置回调函数 ​ 123456//readyState 0未初始化 1正在加载 2已加载 3交互中 4响应完成 req.onreadystatechange = function() &#123; if (req.readyState == 4 &amp;&amp; req.status == 200) &#123; var text = req.responseText; &#125;&#125; JQuery方式方式1：12345678910111213141516$.ajax(&#123; type:"get", //请求类型get/post url:"goods", //待载入页面的URL地址 data:&#123;"uId":v&#125;, //待发送 Key/value 参数。 dataType:"json", //数据类型 error:function(data)&#123; alert("出现错误"+data); &#125;, success:function(data,status)&#123; //alert("调用成功"); &#125;, beforeSend:function(req)&#123; //alert("发送之前"); &#125; &#125;); 方式2：1234567$.get(url, [data], [callback], [type]);//$.post()同上//url:待载入页面的URL地址//data:待发送 Key/value 参数。//callback:载入成功时回调函数。//timeout:超时时间//type:返回内容格式，xml, html, script, json, text, _default。 方式3：123$.getJSON(url).done(function(data)&#123; alert('请求成功！json数据：'+data);&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2017%2F12%2F30%2Fredis%2F</url>
    <content type="text"><![CDATA[安装、启动安装 源码1 安装步骤第一步：安装gcc编译环境 yum install gcc-c++第二步：把redis的源码上传到linux服务器。第三步：解压缩。 tar -zxvf redis-3.0.0.tar.gz第四步：make第五步：make install PREFIX=/usr/local/redis yum 安装yum install redis -y 启动启动redis两种启动方式，前端启动、后台启动。前端启动：./redis-server后台启动：1、复制redis.conf到redis的安装目录2、修改redis.conf。修改daemonize yes3、[root@bogon redis]# ./redis-server redis.conf centos: service redis start/stop/restart客户端redis-cli -p 端口 -h ip地址 &lt;-c&gt;连接集群时使用此参数默认端口：6379Ip：localhost（127.0.0.1） 常用命令1 PING 命令，该命令用于检测 redis 服务是否启动。 2 $ redis-cli -h host -p port -a password 在远程 redis 服务上执行命令，同样我们使用的也是 redis-cli 命令。 3 设值：set key value 取值：get key 删除：del key 4 DUMP key DUMP 命令用于序列化给定 key ，并返回被序列化的值。 5 exists key EXISTS 命令用于检查给定 key 是否存在。 6 expire key 60 为 key 设置过期时间 7 expireat key 1293840000 Redis Expireat 命令用于以 UNIX 时间戳(unix timestamp)格式设置 key 的过期时间。key 过期后将不再可用。 8 pexpireat key 1555555555005 PEXPIREAT 命令用于设置 key 的过期时间，以毫秒计。key 过期后将不再可用。 9 keys s* Keys 命令用于查找所有符合给定模式 pattern 的 key 。。 10 select 1 (数据库编号) 切换数据库 11 move key 1 MOVE 命令用于将当前数据库的 key 移动到给定的数据库 1 当中。 12 ttl key TTL 命令以秒为单位返回 key 的剩余过期时间。 13 persist key PERSIST 命令用于移除给定 key 的过期时间，使得 key 永不过期。 14 pttl key Pttl 命令以毫秒为单位返回 key 的剩余过期时间。 15 randomkey RANDOMKEY 命令从当前数据库中随机返回一个 key 。 16 flushdb 删除当前数据库所有 key 17 rename key newkey Rename 命令用于修改 key 的名称 。(newkey 已存在时， RENAME 会覆盖旧 newkey) 18 renamenx key newkey Renamenx 命令用于在新的 key 不存在时修改 key 的名称 。 19 type key Type 命令用于返回 key 所储存的值的类型。 字符串处理：1 getrange key start end Getrange 命令用于获取存储在指定 key 中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。 0 -1 表示获取所有 2 getset key “value” Getset 命令用于设置指定 key 的新值，并返回 key 旧的值。 3 setbit key offset o/get bit key offset 4 mget key1 key2 … Mget 命令返回所有(一个或多个)给定 key 的值。 没有返回空 5 setex key 30 “value” Setex 命令为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。 6 setnx key “value” Setnx（SET if Not eXists） 命令在指定的 key 不存在时，为 key 设置指定的值。 7 setrange key 5 “value” Setrange 命令用指定的字符串覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始。 8 strlen key Strlen 命令用于获取指定 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误。 9 mset key1 “va1” key2 “va2” Mset 命令用于同时设置一个或多个 key-value 对。 10 msetnx key1 “va1” key2 “va2” Msetnx 命令用于所有给定 key 都不存在时，同时设置一个或多个 key-value 对。 11 psetex key 1000 “value” Psetex 命令以毫秒为单位设置 key 的生存时间。 12 incr key Incr 命令将 key 中储存的数字值增一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。 13 incrby key 30 Incrby 命令将 key 中储存的数字加上指定的增量值。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。 14 incrybyfloat key 1.2 Incrbyfloat 命令为 key 中所储存的值加上指定的浮点数增量值。 15 decr key Decr 命令将 key 中储存的数字值减一。 16 decrby key 20 Decrby 命令将 key 所储存的值减去指定的减量值。 17 append key “value” Append 命令用于为指定的 key 追加值。 redis.conf 配置项说明1.Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no2.当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid3.指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 63794.绑定的主机地址 bind 127.0.0.15.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 3006.指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose7.日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout8.设置数据库的数量，默认数据库为0，可以使用SELECT命令在连接上指定数据库id databases 169.指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。10.指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes11.指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb12.指定本地数据库存放目录 dir ./13.设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof 14.当master服务设置了密码保护时，slav服务连接master的密码 masterauth 15.设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭 requirepass foobared16.设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 12817.指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory 18.指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no appendonly no19.指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof20.指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec21.指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no22.虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap23.将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 024.Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 3225.设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 13421772826.设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 427.设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes28.指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 51229.指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes30.指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf 查看CONFIG GET CONFIG_SETTING_NAME例如：CONFIG GET loglevel查看所有：config get * 修改CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE例如：CONFIG SET loglevel “notice” 高级操作数据备份与恢复1 save 备份 2 config get dir 获取 redis 安装目录 恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。 3 bgsave 后台执行 备份 安全1 config get requirepass 查看密码(默认密码为空) 2 config set requirepass “password” 设置密码 3 auth password Auth 命令用于检测给定的密码和配置文件中的密码是否相符。 4 ping 查看服务是否运行 reids 性能测试1 redis-benchmark [option] [option value]-h 指定服务器主机名 127.0.0.1-p 指定服务器端口 6379-s 指定服务器 socket-c 指定并发连接数 50-n 指定请求数 10000-d 以字节的形式指定 SET/GET 值的数据大小 2-k 1=keep alive 0=reconnect 1-r SET/GET/INCR 使用随机 key, SADD 使用随机值-P 通过管道传输 请求 1-q 强制退出 redis。仅显示 query/sec 值–csv 以 CSV 格式输出-l 生成循环，永久执行测试-t 仅运行以逗号分隔的测试命令列表。-I Idle 模式。仅打开 N 个 idle 连接并等待。 例如：redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -q Redis 客户端连接 1 redis-server –maxclients 100000 设置最大连接数为 100000 2 config get maxclients 查看最大连接数 3 client setname 设置当前连接的名称 4 client pause 10 挂起客户端连接，指定挂起的时间以毫秒计 5 client kill 关闭客户端连接 数据类型一、基本命令启动：$ redis-serve进入客户端测试：redis-cli设值：set key value取值：get key二、数据类型1.String(字符串)2.Hash(哈希) 设值：hmset user:1 v1 v2 v3 v4 v5 200.. //貌似最后一个必须为数字？ 取值：hmgetall user:13.List(列表) Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 设置：lpush key value lpush key value2 lpush key value3 …. 取值：lrange key 0 104.Set(集合) 添加一个string元素到,key对应的set集合中，成功返回1,如果元素已经在集合中返回0,key对应的set不存在返回错误。 设值：sadd key value sadd key value2 sadd key value3 sadd key value (该value已经在集合中存在，故应返回0) 根据集合内元素的唯一性，第二次插入的元素将被忽略。 取值：smembers key5.zset(sorted set：有序集合) Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型 的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。 设值：(zadd key score member) zadd key 0 value zadd key 1 value2 取值：zrangebyscore key 0 1000]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb]]></title>
    <url>%2F2017%2F01%2F16%2Fjavaweb%2F</url>
    <content type="text"><![CDATA[ServletTomcat：Web 应用服务器，属于轻量级应用服务器，也叫Servlet容器 1. 生命周期生命周期方法： void init(ServletConfig)：出生之后（1次）； void service(ServletRequest request, ServletResponse response)：每次处理请求时都会被调用； void destroy()：临死之前（1次）； 特性： 单例，一个类只有一个对象；当然可能存在多个Servlet类！ 2. 实现Servlet的方式实现Servlet有三种方式： 实现javax.servlet.Servlet接口； 继承javax.servlet.GenericServlet类； 继承javax.servlet.http.HttpServlet类； 通常我们会去继承HttpServlet类来完成我们的Servlet 3. 常用方法1. HttpServletRequest方法： String getParameter(String paramName)：获取指定请求参数的值； String getMethod()：获取请求方法，例如GET或POST； String getHeader(String name)：获取指定请求头的值； void setCharacterEncoding(String encoding)：设置请求体的编码！因为GET请求没有请求体，所以这个方法只只对POST请求有效。当调用request.setCharacterEncoding(“utf-8”)之后，再通过getParameter()方法获取参数值时，那么参数值都已经通过了转码，即转换成了UTF-8编码。所以，这个方法必须在调用getParameter()方法之前调用！ request.getRequestDispatcher(“/ServletTest”).forward(request,response)：转发 2. HttpServletResponse方法： PrintWriter getWriter()：获取字符响应流，使用该流可以向客户端输出响应信息。例如response.getWriter(). print(“&lt;h1&gt;Hello JavaWeb!&lt;/h1&gt;”)； ServletOutputStream getOutputStream()：获取字节响应流，当需要向客户端响应字节数据时，需要使用这个流，例如要向客户端响应图片； void setCharacterEncoding(String encoding) ：用来设置字符响应流的编码，例如在调用setCharacterEncoding(“utf-8”);之后，再response.getWriter()获取字符响应流对象，这时的响应流的编码为utf-8，使用response.getWriter()输出的中文都会转换成utf-8编码后发送给客户端； void setHeader(String name, String value) ：向客户端添加响应头信息，例如setHeader(“Refresh”, “3;url=http://www.itcast.cn”)，表示3秒后自动刷新到http://www.itcast.cn； void setContentType(String contentType) ：该方法是setHeader(“content-type”, “xxx”)的简便方法，即用来添加名为content-type响应头的方法。content-type响应头用来设置响应数据的MIME类型，例如要向客户端响应jpg的图片，那么可以setContentType(“image/jepg”)，如果响应数据为文本类型，那么还要台同时设置编码，例如setContentType(“text/html;chartset=utf-8”)表示响应数据类型为文本类型中的html类型，并且该方法会调用setCharacterEncoding(“utf-8”)方法； void sendError(int code, String errorMsg) ：向客户端发送状态码，以及错误消息。例如给客户端发送404：response(404, “您要查找的资源不存在！”)。 response.sendRedirect(“http:…..”)：重定向某个地址3. ServletConfig方法：ServletConfig对象是由服务器创建的，然后传递给Servlet的init()方法，你可以在init()方法中使用它 String getServletName() ：获取Servlet在web.xml文件中的配置名称，即&lt;servlet-name&gt;指定的名称； ServletContext getServletContext() ：用来获取ServletContext对象。 String getInitParameter(String name) ：用来获取在web.xml中配置的初始化参数，通过参数名来获取参数值； Enumeration getInitParameterNames() ：用来获取在web.xml中配置的所有初始化参数名称；在元素中还可以配置初始化参数： 4. Servlet与线程安全因为一个类型的Servlet只有一个实例对象，那么就有可能会现时出一个Servlet同时处理多个请求，那么Servlet是否为线程安全的呢？答案是：“不是线程安全的”。这说明Servlet的工作效率很高，但也存在线程安全问题！所以我们不应该在Servlet中便宜创建成员变量，因为可能会存在一个线程对这个成员变量进行写操作，另一个线程对这个成员变量进行读操作。 5. ServletContext概述服务器会为每个应用创建一个ServletContext对象： ServletContext对象的创建是在服务器启动时完成的； ServletContext对象的销毁是在服务器关闭时完成的。 ServletContext是JavaWeb四大域对象之一： PageContext； ServletRequest； HttpSession； ServletContext；所有域对象都有存取数据的功能，因为域对象内部有一个Map，用来存储数据setAttribute()、getAttribute()、removeAttribute() 6. 请求转发与重定向比较 请求转发是一个请求，而重定向是两个请求； 请求转发后浏览器地址栏不会有变化，而重定向会有变化，因为重定向是两个请求； 请求转发的目标只能是本应用中的资源，重定向的目标可以是其他应用； 请求转发对AServlet和BServlet的请求方法是相同的，即要么都是GET，要么都是POST，因为请求转发是一个请求； 重定向的第二个请求一定是GET； 6. 其他配置servlet初始化时间 &lt;load-on-startup&gt;3&lt;/load-on-startup&gt; 通配符使用 &lt;url-pattern&gt;/servlet/*&lt;url-patter&gt;：/servlet/a、/servlet/b，都匹配/servlet/*； &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;：/abc/def/ghi.do、/a.do，都匹配*.do； &lt;url-pattern&gt;/*&lt;url-pattern&gt;：匹配所有URL； 配置默认参数1234&lt;context-param&gt;&lt;param-name&gt;paramName1&lt;/param-name&gt;&lt;param-value&gt;paramValue1&lt;/param-value&gt; &lt;/context-param&gt; 获取值：this.getServletContext(). getInitParameter(&quot;paramName1&quot;); 获取真实路径servletContext.getRealPath(“/WEB-INF/b.txt”)； 读文件InputStream in = servletContext. getResourceAsStream(“/WEB-INF/b.txt”)； Class类的getResourceAsStream(String path) 路径以“/”开头，相对classes路径； 路径不以“/”开头，相对当前class文件所有路径，例如在cn.itcast.servlet.MyServlet中执行，那么相对/classes/cn/itcast/servlet/路径； ClassLoader类的getResourceAsStream(String path) 相对classes路径； get请求乱码name = new String(name.getBytes(“iso-8859-1”), “utf-8”); post乱码request.setCharacterEncoding(“utf-8”); String name = request.getParameter(“name”); JSPjsp其实就是一个servlet，jsp第一次被请求的时候，会编译成class文件，然后再去执行servlet 1. JSP脚本 &lt;%…%&gt;：Java语句； &lt;%=…%&gt;：Java表达式； &lt;%!…%&gt;：Java定义类成员；其中&lt;%=…%&gt;与out.print()功能是相同的！它们都是向客户端输出，例如：&lt;%=s1%&gt;等同于&lt;% out.print(s1); %&gt; 2. JSP指令JSP中有三大指令：page、include、taglib，page最常用。page指令1&lt;%@page language=”java” contenType=”text/html;charset=gb2312” session=”true” buffer=”64kb” autoFlush=”true” isThreadSafe=”true” info=”text” errorPage=”error.jsp” isErrorPage=”true” isELIgnored=”true” pageEncoding=”gb2312” import=”java.sql.*”%&gt; web.xml也可以配置错误页面12345678910111213141516&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error404.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt;&lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error500.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt;&lt;exception-type&gt;java.lang.RuntimeException&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; 其他指令&lt;%@include file=&quot;filename.jsp&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 九大内置对象 out（JspWriter）：等同与response.getWriter()，用来向客户端发送文本数据； config（ServletConfig）：对应“真身”中的ServletConfig； page（当前JSP的真身类型）：当前JSP页面的“this”，即当前对象； pageContext（PageContext）：页面上下文对象。 exception（Throwable）：只有在错误页面中可以使用这个对象； request（HttpServletRequest）：即HttpServletRequest类的对象； response（HttpServletResponse）：即HttpServletResponse类的对象； application（ServletContext）：即ServletContext类的对象； session（HttpSession）：即HttpSession类的对象，不是每个JSP页面中都可以使用，如果在某个JSP页面中设置&lt;%@page session=”false”%&gt;，说明这个页面不能使用session。 JSP动作标签 include指令是在编译级别完成的包含，即把当前JSP和被包含的JSP合并成一个JSP，然后再编译成一个Servlet。include动作标签是在运行级别完成的包含，即当前JSP和被包含的JSP都会各自生成Servlet，然后在执行当前JSP的Servlet时完成包含另一个JSP的Servlet。它与RequestDispatcher的include()方法是相同的！ forward标签的作用是请求转发！forward标签的作用与RequestDispatcher.forward()方法相同 123&lt;jsp:include page="/b.jsp"&gt; &lt;jsp:param value="zhangSan" name="username"/&gt; &lt;/jsp:include&gt; EL表达式判断字符串长度是否为0或者集合为0${empty “”}集合对象：${map.key}、${map[‘key’]} 内置对象访问 pageScope：${pageScope.name}等同与pageContext.getAttribute(“name”)； requestScope：${requestScope.name}等同与request.getAttribute(“name”)； sessionScoep： ${sessionScope.name}等同与session.getAttribute(“name”)； applicationScope：${applicationScope.name}等同与application.getAttribute(“name”)； 其他对象 ${header.Host} ${initParam.par} //获取web.xml配的参数 ${cookie.} ${pageContext.servletContext.serverInfo} ${pageContext.session.id} ${pageContext.request.requestURL} JSTL表达式 out和set&lt;c:out value=”${aaa}” default=”xxx”/&gt; 等于${aaa}c:set var=”a” value=”hello” scope=”session”/&gt; 在session中添加name为a，value为hello的数据。 remove&lt;c:remove var=&quot;a&quot;/&gt; 删除所有域中name为a的数据！也可以指定：scope=”page” urlc:url value=&quot;/&quot;/&gt; 输入当前项目路径 如：test/ if 1234&lt;c:set var="a" value="hello"/&gt;&lt;c:if test="$&#123;not empty a &#125;"&gt; &lt;c:out value="$&#123;a &#125;"/&gt;&lt;/c:if&gt; choose 1234567&lt;c:set var="score" value="$&#123;param.score &#125;"/&gt;&lt;c:choose&gt; &lt;c:when test="$&#123;score &gt; 100 || score &lt; 0&#125;"&gt;错误的分数：$&#123;score &#125;&lt;/c:when&gt; &lt;c:when test="$&#123;score &gt;= 90 &#125;"&gt;A级&lt;/c:when&gt; &lt;c:when test="$&#123;score &gt;= 60 &#125;"&gt;D级&lt;/c:when&gt; &lt;c:otherwise&gt;E级&lt;/c:otherwise&gt;&lt;/c:choose&gt; forEach 1234&lt;c:set var="sum" value="0" /&gt;&lt;c:forEach var="i" begin="1" end="10" step="2"&gt; &lt;c:set var="sum" value="$&#123;sum + i&#125;" /&gt;&lt;/c:forEach&gt; 123&lt;c:forEach var="item" items="$&#123;ns &#125;"&gt; &lt;c:out value="name: $&#123;item &#125;"/&gt;&lt;br/&gt;&lt;/c:forEach&gt; 1234567&lt;c:forEach var="item" items="$&#123;ns &#125;" varStatus="vs"&gt; &lt;c:if test="$&#123;vs.first &#125;"&gt;第一行：&lt;/c:if&gt; &lt;c:if test="$&#123;vs.last &#125;"&gt;最后一行：&lt;/c:if&gt; &lt;c:out value="第$&#123;vs.count &#125;行: "/&gt; &lt;c:out value="[$&#123;vs.index &#125;]: "/&gt; &lt;c:out value="name: $&#123;vs.current &#125;"/&gt;&lt;br/&gt;&lt;/c:forEach&gt; count：int类型，当前以遍历元素的个数； index：int类型，当前元素的下标； first：boolean类型，是否为第一个元素； last：boolean类型，是否为最后一个元素； current：Object类型，表示当前项目。fmt标签库常用标签&lt;fmt:formatDate value=&quot;${d }&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;fmt:formatNumber value=&quot;${d2 }&quot; pattern=&quot;#.##&quot;/&gt;&lt;fmt:formatNumber value=&quot;${d1 }&quot; pattern=&quot;0.00&quot;/&gt; 其他在请求url后加上sessionId&lt;%=response.encodeURL (&quot;/test/index.jsp&quot;) %&gt; href=&#39;/test/index.jsp;jsessionid=&lt;%=session.getId() %&gt;&#39; JDBC和数据库1. JDBC六大步骤 加载驱动类 Class.forName (&quot;oracle.jdbc.OracleDriver&quot;); 建立连接 Connection conn = DriverManager. getConnection(url,name,password); 创建statement Statement state = conn.createStatement(); 执行SQL语句 String sql = &quot;select id,name from s_emp&quot;; ResultSet rs = state.executeQuery(sql); 处理结果集 123456while(rs.next())&#123; int id = rs.getInt(&quot;id&quot;); String name = rs.getString(2); System.out.println(id+&quot; &quot;+name); &#125; 关闭连接rs.close(); state.close(); conn.close(); PreparedStatement与Statement区别PreparedStatement叫预编译声明！PreparedStatement是Statement的子接口，你可以使用PreparedStatement来替换Statement。PreparedStatement的好处： 防止SQL攻击； 提高代码的可读性，以可维护性； 提高效率。 预处理的原理每个pstmt都与一个sql模板绑定在一起，先把sql模板给数据库，数据库先进行校验，再进行编译。执行时只是把参数传递过去而已！若二次执行时，就不用再次校验语法，也不用再次编译！直接执行！ JDBC中的事务Connection的三个方法与事务相关： setAutoCommit(boolean)：设置是否为自动提交事务，如果true（默认值就是true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，如果设置false，那么就相当于开启了事务了；con.setAutoCommit(false)表示开启事务！ commit()：提交结束事务; rollback()：回滚结束事务。 2. 事务事务的四大特性是： 原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。 一致性（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。 隔离性（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。 持久性（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据。 开启事务：start transaction；结束事务：commit或rollback。 事务的并发读问题 脏读：读取到另一个事务未提交数据； 不可重复读：两次读取不一致(读取到了另一事务的更新；) 幻读（虚读）：读到另一事务已提交数据。 四大隔离级别 SERIALIZABLE（串行化） 不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的； 性能最差；三种问题都能处理 REPEATABLE READ（可重复读）（MySQL） 防止脏读和不可重复读，不能处理幻读问题； 性能比SERIALIZABLE好 READ COMMITTED（读已提交数据）（Oracle） 防止脏读，没有处理不可重复读，也没有处理幻读； 性能比REPEATABLE READ好 READ UNCOMMITTED（读未提交数据） 可能出现任何事务并发问题 性能最好 MySQL的默认隔离级别为REPEATABLE READ。 3. 连接池4. 监听器、过滤器、拦截器 拦截器是基于java的反射机制的，而过滤器是基于函数回调 过滤器依赖与servlet容器，而拦截器不依赖与servlet容器 拦截器是AOP的一种实现 过滤器的生命周期 init(FilterConfig)：服务器启动创建Filter实例，并且每个类型的Filter只创建一个实例，创建完Filter实例后，这个方法只会被执行一次； doFilter(ServletRequest req,ServletResponse res,FilterChain chain)：这个方法会在用户每次访问就会执行。 destroy()：服务器会在创建Filter对象之后，把Filter放到缓存中一直使用，通常不会销毁它。一般会在服务器关闭时销毁Filter对象，在销毁Filter对象之前，服务器会调用Filter对象的destory()方法。配置过滤器拦截方式：REQUEST、FORWARD、INCLUDE、ERROR。123456&lt;filter-mapping&gt; &lt;filter-name&gt;myfilter&lt;/filter-name&gt; &lt;url-pattern&gt;/b.jsp&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt; &lt;/filter-mapping&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iconfont使用教程]]></title>
    <url>%2F2017%2F01%2F06%2F%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0icon%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[自己项目中用到了第三方登录的功能，来记录下怎么添加第三方登录的图标。 1.寻找合适的图标库我这里是用阿里的iconfont矢量图标，官方网址：http://www.iconfont.cn/ 2.添加图标，下载到本地，解压 这是解压后的目录： 3.将iconfont.css导入到你的css文件。把url中的文件拷贝到CSS能访问到的路径 4.html代码中直接引用&lt;i class=&quot;iconfont icon-qq1&quot;&gt;&lt;/i&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>icon图标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH框架]]></title>
    <url>%2F2016%2F12%2F30%2FSSH%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[web.xml配置1. spring启动方式三种方式： 本地文件ApplicationContext ac = new FileSystemXmlApplicationContext (“applicationContext.xml”); ClasspathApplicationContext ctx = new ClassPathXmlApplicationContext (“ApplicationContext.xml”); Web应用中依赖servlet或Listener （1）利用Listener接口来实现 （2）利用Servlet接口来实现 （1）利用Listener接口来实现12345678910&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;!--&lt;param-value&gt;/WEB-INF/spring-context.xml&lt;/param-value&gt; --&gt;&lt;/context-param&gt; （2）利用Servlet接口来实现12345678910111213141516171819202122232425&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;Servlet&gt; &lt;servlet-name&gt;context&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; ``` ### 2. struts2配置```xml&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 配置文件1. hibernate.cfg.xml配置1234567891011121314151617181920212223242526&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 数据库驱动程序类 --&gt; &lt;property name="connection.driver_class"&gt;oracle.jdbc.OracleDriver&lt;/property&gt; &lt;!-- 数据库连接字符串 --&gt; &lt;property name="connection.url"&gt;jdbc:oracle:thin:@192.168.1.249:1522:oracle&lt;/property&gt; &lt;!-- 数据库用户名 --&gt; &lt;property name="connection.username"&gt;sc160501&lt;/property&gt; &lt;!-- 数据库密码 --&gt; &lt;property name="connection.password"&gt;sc160501&lt;/property&gt; &lt;!-- Hibernate 使用数据方言 --&gt; &lt;property name="dialect"&gt;org.hibernate.dialect.OracleDialect&lt;/property&gt; &lt;!-- 是否创建数据库表 create 每次启动都创建 update 如果数据库没有表就创建 validate 每次启动就校验数据库表和model是否匹配 create-drop 启动时创建，停止时删除 --&gt; &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 是否显示SQL语句 --&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;!-- 是否格式化SQL语句 --&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;mapping resource="com/gjd/model/User.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; hbm.xml映射文件12345678910111213141516171819202122232425262728293031323334353637&lt;hibernate-mapping package="com.hzcl.model"&gt; &lt;class name="User" table="t_user"&gt; &lt;id name="id" column="id" type="integer"&gt; &lt;generator class="sequence"&gt; &lt;param name="sequence"&gt; seq_t_user &lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; &lt;property name="name" column="user_name" type="string" /&gt; &lt;property name="pwd" column="pwd" type="string" /&gt; &lt;property name="createDate" column="create_date" type="date" not-null="false" /&gt; &lt;property name="sex" column="sex" length="2" type="string" not-null="false" /&gt; &lt;property name="imgSrc" column="img_src" type="string" not-null="false" /&gt; &lt;property name="loginTime" column="loginTime" type="date" /&gt; &lt;!-- 一对多 &lt;set name="comm" table="t_com" cascade="all" lazy="false"&gt; &lt;key column="tid"&gt;&lt;/key&gt; &lt;one-to-many class="Comment"/&gt; &lt;/set&gt; --&gt; &lt;!-- 多对一 &lt;many-to-one name="user" class="User" column="tid" lazy="false"&gt;&lt;/many-to-one&gt; --&gt; &lt;!-- 多对多 &lt;set name="projects" table="PROEMP"&gt; &lt;key column="RPROID"&gt;&lt;/key&gt; &lt;many-to-many class="Project" column="REMPID"&gt; &lt;/many-to-many&gt; &lt;/set&gt; --&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; User.hbm.xml常用配置 12345678910111213141516171819202122&lt;hibernate-mappingschema=&quot;schemaName&quot; //模式的名字catalog=&quot;catalogName&quot; //目录的名称default-cascade=&quot;cassade_style&quot; //级联风格 @default-access=&quot;field/property/CalssName&quot; //访问策略 @default-lazy=&quot;true/false&quot; //加载策略 @package=&quot;packagename&quot; //默认包名/&gt;&lt;classname=&quot;ClassName&quot; //对应映射的类table=&quot;tableName&quot; //对应映射数据库的表batch-size=&quot;N&quot; //抓取策略，一次抓取多少记录where=&quot;condition&quot; //条件 eg:抓取条件entity-name=&quot;EntiyName&quot; //如果需要映射多张表/&gt;&lt;id //表的主键name=&quot;propertyName&quot; //对应的属性type=&quot;typeName&quot; //对应类型column=&quot;column_nam&quot; //映射数据库中表当中字段名的名称length=&quot;length&quot; //指定长度&lt;generator class=&quot;generatorClass&quot;/&gt; //主键生成策略 @/&gt; 关联操作 关联查询 1）延迟加载对于关联属性，Hibernate默认采用延迟记载的机制。 lazy=”true”：采用延迟记载（默认） lazy=”false”：不采用延迟加载2）采用连接查询 fetch=”select”不采用连接查询（默认） fetch=”join”采用连接查询，此时lazy属性失效 级联操作1）什么叫级联操作 在Hibernate里，在对一方进行增、删、改时要自动的对另一方也进行增、删、改，这样的行为称之为级联操作。2）如何实现级联添加、修改、删除在要操作的对象的映射关系文件中，在关联属性上追加cascade属性，用这个属性的值来指定级联方式：cascade=”none” 不支持级联（默认）cascade=”save-update” 支持级联添加、修改cascade=”delete” 支持级联删除cascade=”all” 支持级联添加、修改、删除//级联删除时，需要在配置文件的关联属性上追加inverse=”true”。 单一主键（1）assigned 由java应用程序负责生成（手工赋值）（2）native 由底层数据库自动生成标示符，如果是MySQL就是increment，如果是Oracle就是sequence，等等 2. applicationContext.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!-- 引入资源文件 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties" /&gt; &lt;!-- 配置druid连接池 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;!-- 数据库基本信息配置 --&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClass&#125;" /&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name="initialSize" value="1" /&gt; &lt;property name="minIdle" value="1" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;/bean&gt; &lt;!-- 配置Hibernate的相关属性 --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.OracleDialect&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;create&lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="mappingResources"&gt; &lt;list&gt; &lt;value&gt;com/model/User.hbm.xml&lt;/value&gt; &lt;value&gt;com/model/News.hbm.xml&lt;/value&gt; &lt;value&gt;com/model/Comment.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器： --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt; &lt;!-- 注入 dao --&gt; &lt;bean id="userDao" class="com.dao.UserDaoImpl"&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注入 service --&gt; &lt;bean id="userService" class="com.service.UserServiceImpl"&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注入 action --&gt; &lt;bean id="userAction" class="com.action.UserAction"&gt; &lt;property name="userService" ref="userService"&gt;&lt;/property&gt; &lt;/bean&gt; 3. struts.xml配置详解1234567891011121314151617181920212223242526272829303132333435363738394041&lt;struts&gt; &lt;!-- 让Spring 来创建Action对象 --&gt; &lt;constant name="struts.objectFactory" value="spring"/&gt; &lt;constant name="struts.action.extension" value="html,"&gt;&lt;/constant&gt; &lt;constant name="struts.custom.i18n.resources" value="message"&gt;&lt;/constant&gt; &lt;package name="user" extends="struts-default" namespace="/"&gt; &lt;interceptors&gt; &lt;interceptor name="login" class="com.interceptor.LoginInterceptor"/&gt; &lt;interceptor-stack name="myStack"&gt; &lt;interceptor-ref name="login"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;default-interceptor-ref name="myStack"&gt;&lt;/default-interceptor-ref&gt; &lt;global-results&gt; &lt;result name="error" type="redirect"&gt;/login.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name="user_*" class="userAction" method="&#123;1&#125;"&gt; &lt;result type="redirectAction"&gt;news_list&lt;/result&gt; &lt;result name="login"&gt;/login.jsp&lt;/result&gt; &lt;result name="info"&gt;/userInfo.jsp&lt;/result&gt; &lt;result name="logout"&gt;/login.jsp&lt;/result&gt; &lt;result name="input"&gt;/register.jsp&lt;/result&gt; &lt;result name="lang"&gt;/register.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="news_*" class="newsAction" method="&#123;1&#125;"&gt; &lt;result name="del" type="redirectAction"&gt;news_list&lt;/result&gt; &lt;result&gt;/news.jsp&lt;/result&gt; &lt;result name="modify"&gt;/addnews.jsp&lt;/result&gt; &lt;result name="new"&gt;/new.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="comm_*" class="commentAction" method="&#123;1&#125;"&gt; &lt;result name="newComm" type="chain"&gt;news_newCom&lt;/result&gt; &lt;/action&gt; &lt;action name="file" class="fileAction"&gt; &lt;result&gt;/login.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; struts.xml中包含的内容： 1、全局属性2、用户请求和相应Action之间的对应关系3、Action可能会用到的参数和返回结果4、各种拦截器的配置 配置详解 package提供了将多个Action组织成为一个模块的方式package的名字必须是唯一的，可以在这个包上加一些拓展的包 为拦截器可以为拦截器定义name(名称)和class（类路径） 拦截器栈 定义默认的拦截器，每个Action都会自动引用 包含其他配置文件 注意：1.被include的标签一定要符合struts的dtd规范。也就是说被include的xml文件的内部格式要符合struts的xml文件规范。2.xml文件的编码格式要相同，如果是utf-8，那么都是utf-8。配置编码： 工作原理： 用户的请求HttpServletRequest—&gt;过滤器filter—&gt;ActionMapper(.action)请求—-&gt;过滤器—-&gt;ActionProxy—-&gt;通过ConfigurationManager读取struts.xml中的ActionInvocation具体的Action类—-&gt;通过ActionProxy创建Action反向实例—-&gt;拦截器—&gt;action,返回result(字符串对象)对应的视图—-&gt;拦截器—-&gt;HttpServletResponse返回请求 action搜索顺序 例子：localhost:8080/product_one/hellowworld.jsp可以进入result.jsp页面localhost:8080/product_one/aaa/ddd/ccc/hellowworld.jsp也可以进入result.jsp页面Action搜索顺序：localhost:8080/struts2/path1/path2/path3/student.action第一步：判断package是否存在，如：path1/path2/path3/ 如果package存在第二步：则判断该package中action是否存在，如果不存在则去默认namespace的package里面寻找action第三步：如果没有，则报错 如果package不存在：第二步：检查上一级路径的package是否存在（直到默认namespace），重复第一步第三步：如果没有则报错 如果请求为/login.action，系统会根据根命名空间（”/“）中查找名为login的Action，如果在根命名空间中找到了名为login的Action，则该Action处理用户的请求；否则系统将转为在默认命名空间中寻找名为login的Action，如果默认的命名空间中有名为login的Action，则由该Action处理用户的请求。如果两个命名空间中都找不到名为login的Action，那么系统将出现错误。 注意：命名空间只有一个级别。如果请求的URL是/bookservice/search/get.action系统将先在/bookservice/search的命名空间下查找名为get的Action，如果在该系统命名空间内找到名为get的Action，则由该Action处理该用户的请求；如果在该命名空间中没有找到名为get的Action，系统将直接进入默认的命名空间中查找名为get的Action，而不会在bookservice的命名空间下查找名为get的Action。可以多个包使用同一个命名空间，但是相同的命名空间相当于同一个模块，也就是同一个包。一个包中可以有name值相同的action，但是后面的action会把前面同名的action覆盖掉 动态方法调用： 动态方法调用是为了解决一个Action对应多个请求的处理，以免Action太多。三种方式：指定method属性、感叹号方式、通配符方式（这种方式较方便） method属性 感叹号 123456&lt;constant name="struts.enable.DynamicMethodInvocation" value="true"&gt;&lt;/constant&gt;&lt;action name="hellowword" class="com.Action.hellowAction"&gt;&lt;result &gt;/result.jsp&lt;/result&gt;&lt;result name="add"&gt;/add.jsp&lt;/result&gt;&lt;result name="update"&gt;/update.jsp&lt;/result&gt;&lt;/action&gt; localhost:8080/struts_hellowworld/aaa/hellowworld!.action 通配符12345&lt;action name="*_*" method="&#123;2&#125;" class="com.Action.&#123;1&#125;Action"&gt;&lt;result &gt;/&#123;2&#125;.jsp&lt;/result&gt;&lt;result name="add"&gt;/&#123;2&#125;.jsp&lt;/result&gt;&lt;result name="update"&gt;/&#123;2&#125;.jsp&lt;/result&gt;&lt;/action&gt; localhost:8080/struts_hellowworld/aaa/hellow_add.action 默认的action 12345&lt;default-action-ref name="index"&gt;&lt;/default-action-ref&gt;&lt;action name="index"&gt;&lt;result&gt;/error.jsp&lt;/result&gt;&lt;br&gt;&lt;/action&gt; 结果类型input的效果 1.当参数类型转换错误时，如age输入框中的类型是字母等情况，方法自动返回input 2.当action中存在addFiledError时： 1）addFileError放在一般执行方法，addFieldError(“”, “”);语句后面有返回input的语句 2）addFileError放在validate()中*3.FileError的表现形式： 在jsp页面中使用标签，该标签name属性为addFieldError方法中的参数fieldName，在jsp页面中使用struts标签， 需要导入标签库 语句：&lt;%@ taglib prefix=”s” uri=”/struts-tags” %&gt; 【Structs2处理流程】 用户请求Structs框架控制器(Action)Structs框架视图资源返回String，提供代码复用性，有利于框架分离。【Action中五种内置属性(com.opensymphony.xwork2.Action)】(1) SUCCESS Action正确的执行完成，返回相应的视图，success是name属性的默认值。(2) NONE 表示Action正确的执行完成，但并不返回任何事视图。(3) ERROR 表示Action执行失效，返回错误处理视图。(4) LOGIN Action因为用户没有登录的原因没有正确执行，将返回该登录视图，要求用户进行登录验证(5) INPUT Action的执行，需要从前端界面获取参数，INPUT就是代表这个参数输入界面，一般在应用中，会对这些 参数进行验证，如果验证没有通过，将自动返回该视图。返回 1.在result里面最重要的属性是type类型，type的默认值为dispatcher（转发），这个类型支持JSP视图技术。2.Struts2支持多种视图技术，例如JSP、Valocity（模板引擎）、FreeMaker（模板引擎）等。3.常用三个：chain，redirect，plaintext。1）、chain：将action和另外一个action链接起来，必须是一个action不能是jsp页面。2）、redirect：重定向（会丢失请求参数）。3）、plaintext：返回网页源代码。4）、stream：返回inputstream用于文件下载。5）、默认”dispatcher” jsp传值 请求转发 客户端通过httpservletrequest向servlet容器,也就是tomcat提交一个请求,这个请求会经过一些列的过滤器,如ActionContentClearUp过滤器,最终被struts核心过滤器过滤,也就是FilterDispatcher.从struts2.1.3版本以后struts的核心控制器发生了变化,变成了PrepqreAndExecuteFiletr,核心过滤器过滤以后,调用访问ActionMapping,决定是否调用某一action,如果用户请求的是jsp页面或者是其他资源,不会调用某一action,如果决定调用某一action,ActionMapping会将控制权委派给ActionProxy,也叫action代理,此时action代理会通过一个Configuration Manager也就是配置管理器对象加载struts核心配置文件,也就是struts.xml.如果在struts.xml找到需要创建的action,ActionProxy会创建一个Action Invocation实例,action Invocation包括一些列的拦截器和action,先顺序执行一些列的拦截器,然后执行action处理,返回一个结果,通过result返回一个视图或者调用另外某个action.当返回这个视图以后,将之前执行过的拦截器反向执行一遍,然后通过response响应客户端的请求. 12345678&lt;!-- 注册拦截器 --&gt; &lt;interceptors&gt; &lt;interceptor name="auth" class="com.imooc.interceptor.AuthInterceptor"&gt; &lt;/interceptor&gt;&lt;!-- 引用拦截器 --&gt; &lt;interceptor-ref name="mytimer"&gt;&lt;/interceptor-ref&gt; 默认拦截器栈 在struts-default.xml中定义一个defaulStack拦截器栈,并将其指定为默认拦截器. 只要在定义包的过程中继承struts-default包,那么defaultStack将是默认的拦截器. 当为包中的某个action显式指定了某个拦截器,则默认拦截器不会起作用. 拦截器栈中的各个拦截器的顺序很重要. 引用默认的拦截器栈&lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt;在引用拦截器的时候一般先引用默认的拦截器。WEB-INF里的文件默认情况下是不允许被外部直接访问的，可以通过action间接来访问如果action的class不写，则默认是ActionSupport这个类 struts.xml 定义顺序 result-typesinterceptorsinterceptor-stackdefault-interceptor-ref 默认拦截器default-action-ref 默认actiondefault-class-ref Action默认处理的类global-results 全局返回global-exception-mappings 全局异常action 核心代码编写1. hibernate一级缓存 什么是一级缓存Hibernate在创建Session时，会给每一个Session分配一块内存空间，用于缓存Session查询到的对象数据，这块内存空间称之为一级缓存。由于该空间是给Session使用的，也称Session级缓存。重点： –一级缓存又称Session级缓存 –一级缓存是Session独享的 为什么用一级缓存1）作用： 一级缓存可以降低数据库访问次数，提高 代码执行效率。2）步骤： –Session取值时会优先向它的一级缓存取值 –如果缓存中没有数据，它会向数据库取值， 并将取到的值放入一级缓存，然后Session 从缓存中取出数据 –当再次查询相同的数据时，由于一级缓存中 已经存在了该数据，则直接返回，不需要重新 访问数据库 如何使用一级缓存 1）一级缓存是默认开启的，自动使用。 2）规则： --一级缓存是Session独享的，即一个Session 不能访问另一个Session缓存的数据。 --每次查询，Session仅仅是把本次查询结果 放到一级缓存中 --如果查询的结果是多条数据，Session会将 这些数据拆开，以单个对象的形式存入一级缓存。 --在执行save、update、delete时，会自动触发 缓存的更新。 3）一级缓存是给Session使用的，并且是由Session 负责管理，Session管理一级缓存的方式如下： a、session.evict(obj); evict可以将obj对象从当前session的缓存区 移除。 b、session.clear(); clear可以将当前session的缓存区清空。 c、session.close(); session关闭时，它会释放自己的缓存区域， 从而缓存数据也释放了。 二、对象持久性 1、Hibernate下，可以把对象看做具有3种状态，分别 为临时态、持久态、游离态，对象持久性是值对象 在这三种状态之间的转换规则。 2、3种状态的转换及规则 1）临时态 a、转换 –new出来的对象是临时态的 –delete持久态的对象，它将转变为临时态 b、规则 –临时态的对象可以被垃圾回收 –临时态的对象没有被持久化过， 并且没有与session建立关联。 2）持久态（） a、转换 –通过save/update操作过的对象， 是持久态的。 –经过get/load/list/iterate方法查询得到的 对象是持久态的。 b、规则 –持久态的对象不能被垃圾回收 –持久态的对象被持久化了，并且与 session建立起了关联。 –（）持久态的对象存在于一级缓存中。 –（*）持久态的对象可以自动与数据库同步， 同步的时机是在调用session.flush()时， 实际上事务提交时也可以同步，原因是 ts.comit() = session.flush() + commit; 3）游离态 a、转换 –通过evict/clear/close操作过的对象， 是游离态的。 b、规则 –游离态的对象可以被垃圾回收 –游离态的对象被持久化过， 但是已经与session解除了关联。 3、问题 当大批量插入数据时，每次插入都会导致对象存在 于一级缓存中，如果数据量太大，可能导致缓存 溢出，如何解决？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 public void batchDdd(List&lt;Emp&gt; emps) &#123; if(emps == null || emps.size() == 0) &#123; return; &#125; Session session = HibernateUtil.getSession(); Transaction ts = session.beginTransaction(); try &#123; for(int i=0;i&lt;emps.size();i++) &#123; //循环添加Emp session.save(emps.get(i)); //每100批次，要同步并清理缓存 if(i%100 == 0) &#123; //每隔100次触发同步，但不提交事务 session.flush(); //清理缓存 session.clear(); &#125; &#125; //统一的提交事务 ts.commit(); &#125; catch(HibernateException e) &#123; ts.rollback(); &#125; &#125;``` **三、延迟加载** 1、什么是延迟加载 Hibernate中存在一些查询方法，在查询时并没有 立刻访问数据库查询数据，而是返回了空对象（ 对象并不是null，而是经过new的对象，但对象中 除ID外其他属性都为null），当程序使用此对象 时，Hibernate才真正去查询数据库，将数据填充 到返回的对象中。这种将查询推迟到使用对象时的 机制，称之为延迟加载。 2、为什么用延迟加载 1）推迟的时间内，由于数据没有加载，可以节约 内存空间，可以提升内存使用率。 2）如果有对象查询后并没有使用，那么在延迟加载 的方法中实际上没有访问数据库，可以减少一定 数量的数据库访问次数。 3、如何使用延迟加载 1）有一些方法本身自动支持延迟加载，只要调用 这些方法就可以使用延迟加载。 2）具有延迟加载的方法如下 a、session.load() b、query.iterate() c、关联映射中的关联属性加载**四、二级缓存**1、什么是二级缓存，二级缓存就是SessionFactory缓存 比Session作用范围更广2、先查一级缓存，如果查询不到再查二级缓存，如果二级缓存也查询不到，就直接查数据库 查询到数据以后保持到一级缓存和二级缓存中 如果一级缓存查询不到数据 就从二级缓存中查询 一级缓存和二级缓存的区别 1、作用范围不一样一个属于session的一个属于sessionFactory 2、一级缓存默认开启 二级缓存必须手动开启 3、一级缓存数据缓存在内存中 二级缓存数据缓存在磁盘中 使用二级缓存步骤 1、导入ehcache.jar 2、编写ehcache.xml缓存配置文件 3、在hibernate.cfg.xml中开启二级缓存的支持 ```xml &lt;!-- 开启二级缓存 --&gt; &lt;property name="cache.use_second_level_cache"&gt; true&lt;/property&gt;&lt;!-- 配置二级缓存驱动类 --&gt;&lt;property name="cache.provider_class"&gt;org.hibernate.cache.EhCacheProvider&lt;/property&gt;&lt;!-- 开启查询缓存 --&gt;&lt;property name="cache.use_query_cache"&gt;true&lt;/property&gt; 4、开启二级缓存 持久化对象映射文件添加 持久层增删改查dao层继承 该类：HibernateDaoSupportthis.getHibernateTemplate().save(); //增删改查 2. struts获取request、response采用耦合IOC方式注入属性 三个接口ServletRequestAwareServletresponseAwareServletContextAwareServletSessionAwareActionContext struts2自己封装了Servlet的方法ServletActionContext 可以获取原生态的Servlet的方法表单验证方法validate() //支持表单验证的方法 国际化123456789101112国际化：第一步：struts.xml中加入&lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;message&quot;&gt;&lt;/constant&gt;第二步：在与struts.xml文件同目录下创建一下两个文件. message_en_US.properties(配置英文信息） message_zh_CN.properties(配置中文信息）切换：&lt;a href=&quot;changeLanguage.action?request_locale=zh_CN&quot; &gt;中文&lt;/a&gt;&lt;a href = &quot;changeLanguage.action?request_locale=en_US&quot;&gt;英文&lt;/a&gt;jsp中使用：(必须用ognl标签) &lt;s:text name=&quot;m_name&quot;/&gt; 新建拦截器的步骤 1 建立一个拦截器类继承自Abstractlnertceptor类，并实现inertcept方法。invocation.invoke()方法调用下一个拦截器，如果已经是最后一个拦截器，则执行目标action1234567891011public String intercept(ActionInvocation invoaction) throws Exception &#123; //1.执行action之前 long start = System.currentTimeMillis(); //2.执行下一个拦截器，如果已经是最后一个拦截器，则执行目标Action String result = invoaction.invoke(); //3.执行action之后 long end = System.currentTimeMillis(); System.out.println(end-start); return result; &#125; 自定义拦截器： 方法一：实现Interceptor接口-void init():初始化拦截器所需资源-void destroy() :释放在init（）中分配的资源-String intercept(ActionInvocation ai)throws Exception 实现拦截器功能，利用ActionInvocation参数获取Action状态，返回result字符串作为逻辑视图。 方式二：继承AbstractInterceptor类-提供了init()和destroy() 方法的空实现-只需要实现intercept方法即可 实际开发当中一般会去继承AbstractInterceptor这个父类 2 在strut的配置文件的package中注册拦截器，注册拦截器在action调用之前，在相应的action配置中个，通过intercepor-ref标签中来引用拦截器 接收参数 1，使用Action的属性接受参数，在Action中定义需要接受的属性，并写它的set/get方法。2，使用DomainModel接受参数，创建实体类定义需要接受的属性，并set/get方法，在Action中创建实体类名属性。并在界面进行指定。3，使用ModelDriver接受参数，在Action中实现ModelDriver&lt;实体类名&gt;接口，并实现方法返回当前需要转换的对象，删除set/get方法，并对 对象 进行实例化，并取消指定。4，request5，获取List集合中的参数。获取多个参数。 字段驱动方式第一种接收参数的方法：直接在action类中创建相应的属性和getter和setter，和前端的name名字相同。eg:前端的username，在action类中就要建立一个private String username; Struts会自动映射为这个属性赋值 模型驱动方式第二种接受参数的方法：使用DomainModel，将username 和password两个属性封装为一个类User（必须是标准的JavaBean），在action中声明这个属性：private User user; 同时为user设置getter和setter；在前端中的name需要设置为user.name和user.password,才能映射成功 第三种接收参数的方法：使用ModelDriven接口，这个action必须实现这个接口的public T getModel()方法。此时声明的属性必须实例化，eg: private User user = new User(); 同时不需要getter和setter。前端的name也只需要写username和password就可以，不需要再加域了。这种方法时最推荐的方法，因为可以减少前后端的耦合]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么绑定域名]]></title>
    <url>%2F2016%2F07%2F11%2F%E6%80%8E%E4%B9%88%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[购买域名我是在godaddy上面买的，一个国外的网站，在国内买需要备案，所以选择国外，而且这个还支持支付宝。 1.查找你想要的域名 2.查到适合自己的域名选择，然后点击「continue to Cart」这里都是些附加的服务，不用管，继续点击「continue to Cart」 3.确认购买这里可以修改购买年限，我们还可以上网搜 godaddy 的优惠码，可以优惠一点点，土豪请忽略。 4.结算。登录或注册界面，填完必要的信息之后，选择用支付宝结算。 将域名与 GitHub Pages 的空间绑定1.DNS 设置注册DNSpod，添加域名，如下图设置。其中A的两条记录指向的ip地址是github Pages的提供的ip * 192.30.252.153 * 192.30.252.154 如博客不能登录，有可能是 github 更改了空间服务的 ip 地址，只需要修改即可。www 指定的记录是你在 github 注册的仓库。（gaojindeng.github.io.） 去 Godaddy 修改 DNS 地址将域名服务器更改成 f1g1ns1.dnspod.net 和 f1g1ns2.dnspod.net 过几分钟你就可以访问你的域名了。]]></content>
      <categories>
        <category>建站相关</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2016%2F07%2F09%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[创建版本库1.pwd 显示当前目录2.git init 把当前目录变成git可以管理的仓库 提交文件到仓库1.git add 文件名.后缀2.git commit -m “描述文字 注释”3.git status 查看文件是否提交4.git diff file 查看文件对比5.git log 查看git提交日志，git log --pretty=oneline 简化输出 版本回退和撤消1.git reset --hard HEAD^ 回退上一个版本2.git reset --hard HEAD^^回退上上一个版本3.git reset --hard HEAD~100 回退前100个版本4.git reflog 获取版本号5.git reset --hard 版本号 恢复这个版本6.git checkout -- file 丢弃工作区的修改7.git reset HEAD file 可以把暂存区的修改撤销掉，重新放回工作区 理解工作区与暂存区的区别？1.工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录 版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。2.版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本 库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我 们自动创建了第一个分支master,以及指向master的一个指针HEAD。 git add 就是把文件从工作区修改添加到暂存区； 远程仓库 SSH Keys1.ssh-keygen -t rsa -C &quot;503610326@qq.com&quot; 用户目录会多一个.ssh目 录。id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。2.登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”, 填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。 关联和提交文件到远程仓库1.登录github，创建一个与本地同名的仓库2.在本地仓库运行命令git remote add origin http://...远程仓库的地址3.本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送 到远程。4.git push -u origin master 第一次要加-u 然后输入用户名，密码5.git push origin master 以后每一次提交到服务器6.git remote -v查看远程库信息 如何从远程库克隆1.在github上创建一个仓库2.本地 git clone https://...仓库名 本地就会生成目录了 管理分支1.git checkout -b dev 创建并切换分支 也可以分两步：git branch dev+git checkout dev2.git branch 查看当前分支3.git merge dev 合并分支 指定分支合并到当前分支4.git branch -d name 删除分支5.git merge --no-ff -m &quot;描述&quot; dev 用普通模式合并，合并后的历史有分支，能看出来曾经做过合并。6.git stash 隐藏分支7.git stash list 查看隐藏分支8.git stash apply 恢复隐藏分支 但不会删除 git stash drop 删除隐藏分支9.git stash pop 恢复隐藏分支并且删除10.git branch -D &lt;name&gt; 删除没有合并的分支11.git push origin branch-name 把本地分支推送到远程仓库12.推送失败，git pull origin branch-name拉去远程分支与本地合并，解决分支，继续提交13.git checkout -b dev origin/dev 在本地创建和远程分支对应的分支 分支管理策略1.git merge -no-ff -m &quot;注释&quot; dev 合并dev分支 保留dev分支信息(删除该分 区信息还可以查看到)2.分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发 布，或者说dev分支代码稳定后可以合并到主分支master上来。 Bug分支1.每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分 支删除掉。2.git stash 将当前的工作现场隐藏起来 等Bug分区修复好BUG。3.git stash list查看4.git stash apply恢复git stash drop 删除stash内容5.git stash pop回复并删除stash内容 多人协作1.当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支 对应起来了，并且远程库的默认名称是origin。2.git remote 查看远程库的信息 -v 查看详细信息3.git push origin master 推送到远程的分支上去4.一般是主分支推送到远程的]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用hexo在github上搭建免费个人博客]]></title>
    <url>%2F2016%2F07%2F09%2F%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[GitHub首先登陆GitHub网站，在github上建立一个repository，名字必须为xxx.github.io，xxx为你的账户名，如下图所示 安装软件依次下载并安装下面两个软件，一直点击下一步即可： Node.js Git 配置 SSH keys我们用SSH keys让本地git项目与远程的github建立联系,请看我博客git命令教程 Hexo在本地新建一个文件夹来存放hexo项目，进入该文件夹右击打开Git Bash here安装命令：1npm i -g hexo 初始化hexo:1hexo init 安装插件：1hexo install 1npm install --save hexo-deployer-git 安装后会出现以下目录：然后生成web项目：1hexo g 启动服务器预览效果(http://localhost:4000)：1hexo s 这还只是本地项目，现在要发布到github上面去，我们需要配置项目目录下的_config.yml文件，打开它找到最后一行，我们把github的配置信息填上去。这里gaojindeng是我的登录名，你只需要将它改成你github的登录名，原封不动地配置好就行了。我看到好多教程是第二张图那样配置，新版本是不能那样配的。我们开始发布博客吧！1hexo d 稍等一会就可以输入网址xxx.github.io访问你的博客啦~~~ 新建博文1hexo new "文章题目" 新建页面1hexo new page "页面名称" 快捷命令全称1234hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new 发博文123hexo ghexo d 其他头像存放路径： 主题的source 文件夹下 直接/*.jpg 就行]]></content>
      <categories>
        <category>建站相关</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
