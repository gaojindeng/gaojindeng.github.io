<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信精选文章]]></title>
    <url>%2F2099%2F12%2F12%2Fweixin%2F</url>
    <content type="text"><![CDATA[微信精选文章中国何时能成为“超级大国”？ 为什么建议年轻人不要买房？ 房产和投资理财，哪个更好？ 养鹅——才能实现财务自由 更多文章请微信搜索“灯塔量化”公众号，跟我一起学习投资理财知识！]]></content>
      <categories>
        <category>weixin</category>
      </categories>
      <tags>
        <tag>weixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti工作流进阶]]></title>
    <url>%2F2018%2F06%2F24%2FActiviti%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[一、Activiti表单12345678&lt;startEvent id="startevent1" name="Start"&gt; &lt;extensionElements&gt; &lt;activiti:formProperty id="userName" name="userName" variable="userName" type="string" /&gt; &lt;activiti:formProperty id="age" name="age" variable="age" type="string" /&gt; &lt;/extensionElements&gt;&lt;/startEvent&gt; 12345678910111213FormService formService = engine.getFormService();StartFormData sfd = formService.getStartFormData(pd.getId());List&lt;FormProperty&gt; formProps = sfd.getFormProperties();Map&lt;String, Object&gt; variables = Maps.newHashMap();for(FormProperty fp : formProps) &#123; System.out.println(fp.getName() + "--" + fp.getType()); if (StringFormType.class.isInstance(formProperty.getType())) &#123; variables.put(formProperty.getId(), "1"); &#125; else if (DateFormType.class.isInstance(formProperty.getType())) &#123; variables.put(formProperty.getId(), "1"); &#125; taskService.complete(task.getId(), variables);&#125; 执行任务12//这样也会执行任务到下一个任务节点proccessEngine.getFormService().submitTaskFormData(task.getId(),map); 会签利用多实例，实现多个审核通过 其他taskAssignee 优先 taskCandidateGroupdelegate &gt; setAssignee &gt; claim 后两者都是设置Assignee]]></content>
      <categories>
        <category>Activiti</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti工作流基础]]></title>
    <url>%2F2018%2F06%2F04%2FActiviti%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、activiti配置文件12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- spring模式加载的class不同 --&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/db_activiti" /&gt; &lt;!-- 数据库配置也可以直接用数据源dataSource注入 --&gt; &lt;property name="jdbcDriver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="jdbcUsername" value="root" /&gt; &lt;property name="jdbcPassword" value="root" /&gt; &lt;!-- false:关闭；true:当表不存在时自动创建；create-drop/drop-create --&gt; &lt;property name="databaseSchemaUpdate" value="true" /&gt; &lt;!-- 监控流程作业，默认false --&gt; &lt;property name="jobExecutorActivate" value="false" /&gt; &lt;!-- none: 跳过所有的历史数据。性能最优，但是没有历史数据。 activity: 保存所有的流程实例和活动信息。只保留最后信息，没有明细信息。 audit: 默认级别。保存所有的流程实例，任务、活动、表单属性等信息。 full: 最高级别，最完整的的历史信息。除了audit中的信息外，还包含详细信息。 --&gt; &lt;property name="history" value="audit" /&gt; &lt;!-- 打开异步处理Service任务 --&gt; &lt;property name="asyncExecutorActivate" value="true"&gt;&lt;/property&gt; &lt;!-- 发布流程不生成流程图 --&gt; &lt;property name="createDiagramOnDeploy" value="false" /&gt; &lt;!-- 字体 --&gt; &lt;property name="activityFontName" value="宋体" /&gt; &lt;property name="labelFontName" value="宋体" /&gt; &lt;!-- 不保存流程图片 --&gt; &lt;property name="createDiagramOnDeploy" value="false" /&gt; &lt;property name="DbIdentityUsed" value="true" /&gt; &lt;property name="DbHistoryUsed" value="true" /&gt; &lt;property name="databaseTablePrefix" value="T_" /&gt; &lt;property name="databaseType" value="mysql" /&gt; &lt;/bean&gt; &lt;/beans&gt; 二、数据库表参考：Activiti数据库表结构(表详细版) activiti6.0新增： ACT_RU_TIMER_JOB 存放定时任务 ACT_RU_SUSPENDED_JOB 存放暂停任务 ACT_RU_DEADLETTER_JOB 无法执行的任务 ACT_EVT_LOG 异步日志表 ACT_PROCDEF_INFO 流程定义扩展表 三、service接口 RepositoryService 流程仓库Service，用于管理流程仓库，如部署、删除、读取流程资源。 IdentifyService 身份Service，管理和查询用户、组之间的关系。 RuntimeService 运行时Service，管理所有正在运行状态的流程实例、任务等。 TaskService 任务Service，用于管理、查询任务，如签收、办理、指派等。 FormService 表单Service，用于读取和流程、任务相关的表单数据。 HistoryService 历史Service，可以查询所有历史数据。 ManagementService 引擎管理Service，和具体业务无关，主要是可以查询引擎配置、数据库、作业等。 7个service都是通过ProcessEngine对象来获取的 ProcessEngine engine = ProcessEngines.getDefaultProcessEngine(); 四、activiti流程设计器使用（BPMN2.0规范）事件1、事件的分类与定义 定时器事件定义 可以用在开始事件、中间事件、边界事件。可选指定时间触发、循环触发。支持cron表达式 错误事件定义 可以用在开始事件、结束事件、边界事件。捕获/抛出错误。 信号事件定义 通过一个信号控制多个流程实例，可以用在边界事件、中间事件。 消息事件定义 一个消息控制一个流程实例 取消事件定义 用在事务子流程模型中，有取消边界事件和取消结束事件 补偿事件定义 补偿事件 其他事件 2、开始事件 无指定开始事件 定时器开始事件 必须在配置文件打开异步处理Service任务，可以设置定时器触发方式 消息开始事件 通过消息名称启动流程：ProcessInstance pi = runService.startProcessInstanceByMessage(“msgName”);流程配置文件添加&lt;message id=&quot;msgA&quot; name=&quot;msgName&quot;&gt;&lt;/message&gt; 错误开始事件 流程中抛出异常，在事件子流程开始错误事件中捕获异常流程配置文件添加&lt;error id=&quot;countError&quot; errorCode=&quot;abc&quot;&gt;&lt;/error&gt;处理类抛出throw new org.activiti.engine.delegate.BpmnError(&quot;abc&quot;); 3、结束事件 无指定结束事件 错误结束事件 流程以错误事件结束，然后事务子流程中就会捕获，从而执行子流程 取消结束事件 在事务子流程中，触发取消结束事件后，就会触发所有补偿边界事件，然后先执行补偿边界事件，再判断整个事务子流程中是否有边界事件，有就执行事务子流程中的。 1234&lt;endEvent id="cancelendevent1" name="CancelEnd"&gt; &lt;cancelEventDefinition&gt;&lt;/cancelEventDefinition&gt;&lt;/endEvent&gt;&gt; 终止结束事件 当一个流程实例中，有多个任务都可以执行（并行网关），有一条执行到了终止结束事件，那么整个流程实例都终止了。 4、边界事件 定时器边界事件 当触发定时器时，执行定时器指定的任务 错误边界事件 捕获异常：throw new org.activiti.engine.delegate.BpmnError(&quot;abc&quot;); 信号边界事件 ，当执行到某个节点的时候触发信号或者消息时，执行另一个任务。申请–&gt;审批–&gt;审批不通过触发事件–&gt;回到申请 取消边界事件 当事务子流程中，取消结束事件被触发后，补偿边界事件触发，然后子流程取消边界事件也会触发 补偿边界事件 1234&lt;boundaryEvent id="boundarycompensation1" name="Compensate" attachedToRef="usertask1" cancelActivity="true"&gt; &lt;compensateEventDefinition&gt;&lt;/compensateEventDefinition&gt;&lt;/boundaryEvent&gt;&gt; 5、中间事件 定时器中间事件（捕获） 必须等待定时器触发后才能执行后面的节点任务（下个节点延迟拿到执行） 123456&lt;intermediateCatchEvent id="timerintermediatecatchevent1" name="TimerCatchEvent"&gt; &lt;timerEventDefinition&gt; &lt;timeDuration&gt;PT5S&lt;/timeDuration&gt; &lt;/timerEventDefinition&gt;&lt;/intermediateCatchEvent&gt; &gt; 信号中间事件（捕获和抛出） 比如并行网关里，多条执行任务都是捕获信号中间事件，然后其中一条任务执行完成后，抛出信号中间事件，其他有捕获信号中间时间的执行任务才能往下走。(中间信号事件是自动触发的) 1234567891011&lt;signal id="finishPay" name="finishPay"&gt;&lt;/signal&gt;&lt;!-- 捕获 --&gt;&lt;intermediateThrowEvent id="signalintermediatethrowevent1" name="SignalThrowEvent"&gt; &lt;signalEventDefinition signalRef="finishPay"&gt;&lt;/signalEventDefinition&gt;&lt;/intermediateThrowEvent&gt;&lt;!-- 抛出 --&gt;&lt;intermediateCatchEvent id="signalintermediatecatchevent2"name="SignalCatchEvent"&gt; &lt;signalEventDefinition signalRef="finishPay"&gt;&lt;/signalEventDefinition&gt;&lt;/intermediateCatchEvent&gt;&gt; 消息中间事件（捕获） 1234Execution run = runService.createExecutionQuery().messageEventSubscriptionName("message").singleResult();System.out.println(run.getId());runService.messageEventReceived("message", run.getId());&gt; 信号中间事件 123456789// 启动流程ProcessInstance pi = runService.startProcessInstanceById(pd.getId());// 查当前的子执行流（只有一个）Execution exe = runService.createExecutionQuery() .processInstanceId(pi.getId()).onlyChildExecutions() .singleResult();System.out.println(pi.getId() + ", 当前节点：" + exe.getActivityId());runService.signalEventReceived("testSignal");&gt; 补偿中间事件 6、补偿事件补偿边界事件 事务子流程有取消结束事件就会执行子流程中补偿边界事件 触发补偿中间事件==&gt;触发边界补偿事件 补偿中间事件 触发补偿中间事件就会触发所有之前任务的边界补偿事件 任务1、用户任务 分配任务的候选人 方式1：使用taskService的addCandidateGroup和addCandidateUser方法 方式2：使用XML配置id1234567 &lt;potentialOwner&gt; &lt;resourceAssignmentExpression&gt; &lt;formalExpression&gt;user(angus), group(management), boss &lt;/formalExpression&gt; &lt;/resourceAssignmentExpression&gt; &lt;/potentialOwner&gt;&lt;/userTask&gt; 分配任务代理人 一个任务可以分配多个候选人，但是只能有一个代理人 方式1：使用task对象的setAssignee方法设置代理人 方式2：使用XML配置id123456 &lt;humanPerformer&gt; &lt;resourceAssignmentExpression&gt; &lt;formalExpression&gt;user&lt;/formalExpression&gt; &lt;/resourceAssignmentExpression&gt; &lt;/humanPerformer&gt;&gt; &lt;/userTask&gt; 权限分配扩展 1234&lt;userTask id="usertask1" name="Task A" activiti:assignee="user1"activiti:candidateUsers="angus,angus1" activiti:candidateGroups="boss,management"&gt;&lt;/userTask&gt;&gt; 当设置代理人的时候，该任务只属于该代理人 使用任务监听器进行权限分配 见监听器 使用JUEL分配权限 1234&lt;userTask id=&quot;usertask1&quot; name=&quot;My Task&quot; activiti:candidateUsers=&quot;$&#123;authService.getCandidateUsers()&#125;&quot; activiti:candidateGroups=&quot;$&#123;authService.getCandidateGroups()&#125;&quot; activiti:assignee=&quot;$&#123;authService.getAssignee()&#125;&quot; &gt;&lt;/userTask&gt;&gt; 启动流程：1234Map&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;();vars.put(&quot;authService&quot;, new AuthService());ProcessInstance pi = runService.startProcessInstanceById(pd.getId(), vars);&gt; AuthService类中方法返回List&lt;String&gt;获取String类型即可 2、服务任务 Java Service Task activiti:class：必须是该两个接口的实现类JavaDelegate、ActivityBehavior 必须写死类路径 activiti:delegateExpression activiti:delegateExpression=&quot;${myDelegate}&quot; 1234567 //MyDelegate实现JavaDelegate和Serializable MyDelegate de = new MyDelegate(); Map&lt;String ,Object&gt; vars = new HashMap&lt;String, Object&gt;(); vars.put(&quot;myDelegate&quot;, de); // 启动流程 ProcessInstance pi = runService.startProcessInstanceById(pd.getId(), vars);&gt; activiti:expression activiti:expression=&quot;${myBean.print(execution)}&quot;activiti:expression=&quot;${execution.setVariable(&#39;myName&#39;, myBean.name)}&quot; 123456Map&lt;String ,Object&gt; vars = new HashMap&lt;String, Object&gt;();//print方法传入Execution exe，可以获取当前的任务vars.put("myBean", new MyBean());//实现Serializable接口，并且有name成员变量，getName方法// 启动流程ProcessInstance pi = runService.startProcessInstanceById(pd.getId(), vars);&gt; Shell Task 12345678910&lt;serviceTask id="servicetask1" name="Service Task" activiti:type="shell"&gt; &lt;extensionElements&gt; &lt;activiti:field name="command" stringValue="cmd"/&gt; &lt;activiti:field name="arg1" stringValue="/c"/&gt; &lt;activiti:field name="arg2" stringValue="echo"/&gt; &lt;activiti:field name="arg3" stringValue="%JAVA_HOME%"/&gt; &lt;activiti:field name="outputVariable" stringValue="javaHome"/&gt; &lt;/extensionElements&gt;&lt;/serviceTask&gt;&gt; 获取参数值runService.getVariable(pi.getId(), &quot;javaHome&quot;) Receive Task 12345678910// 启动流程ProcessInstance pi = runService.startProcessInstanceById(pd.getId());// 查当前的子执行流（只有一个）Execution exe = runService.createExecutionQuery() .processInstanceId(pi.getId()).onlyChildExecutions() .singleResult();System.out.println(pi.getId() + ", 当前节点：" + exe.getActivityId());// 让它往前走runService.trigger(exe.getId());&gt; Web Service Task 用不上 3、其他任务与流程监听器其他任务 手工任务 自己会执行，会记录历史数据 接收任务: RuntimeService.trigger(exe.getId()) 邮件任务 自动发送邮件 Mule任务 业务规则任务 任务监听器 同Service Task有三种配置方式： class delegateExpression expression 监听器触发： create 流程创建时 assignment 流程任务分配 complete 任务完成 12345678910&lt;userTask id="usertask1" name="User Task" activiti:assignee="crazyit"&gt; &lt;extensionElements&gt; &lt;activiti:taskListener event="create" class="org.crazyit.act.c10.MyTaskListener"&gt; &lt;activiti:field name="userName" stringValue="crazyit" /&gt;&lt;/activiti:taskListener&gt; &lt;activiti:taskListener event="assignment" class="org.crazyit.act.c10.TaskListenerAssignment"&gt;&lt;/activiti:taskListener&gt; &lt;activiti:taskListener event="complete" class="org.crazyit.act.c10.TaskListenerComplete"&gt;&lt;/activiti:taskListener&gt; &lt;/extensionElements&gt;&lt;/userTask&gt; 监听器也可以获取流程中设置的参数监听器实现TaskListener接口1234567891011121314public class MyTaskListener implements TaskListener &#123; private FixedValue userName; public void setUserName(FixedValue userName) &#123; this.userName = userName; &#125; @Override public void notify(DelegateTask arg0) &#123; System.out.println("这是自定义任务监听器, " + userName.getExpressionText()); &#125;&#125; 流程监听器监听器触发： start 流程开始 take 流程经过 end 流程完成 1234567891011&lt;extensionElements&gt; &lt;activiti:executionListener event="start" class="org.crazyit.act.c10.ExecutionListener"&gt; &lt;activiti:field name="userName" stringValue="crazyit" /&gt; &lt;/activiti:executionListener&gt; &lt;activiti:executionListener event="take" class="org.crazyit.act.c10.ExecutionListenerAssignment"&gt;&lt;/activiti:executionListener&gt; &lt;activiti:executionListener event="end" class="org.crazyit.act.c10.ExecutionListenerComplete"&gt; &lt;/activiti:executionListener&gt;&lt;/extensionElements&gt; 监听器实现类是ExecutionListener 流程网关其他1、子流程 嵌入式子流程 子流程与外部任务交互必须经过边界事件 调用式子流程调用外部流程 添加callActivity节点，指定外部流程ID：SubProcess&lt;callActivity id=&quot;callactivity1&quot; name=&quot;调用其他的流程&quot; calledElement=&quot;SubProcess&quot;&gt;&lt;/callActivity&gt;获取外部流程的实例：ProcessInstance piSub = runService.createProcessInstanceQuery(). superProcessInstanceId(pi.getId()).singleResult();传递参数： 12345&lt;extensionElements&gt; &lt;activiti:in source=&quot;days&quot; target=&quot;newDays&quot;/&gt; &lt;activiti:out source=&quot;myDays&quot; target=&quot;resultDays&quot;/&gt;&lt;/extensionElements&gt;&gt; 事件子流程 可以由错误、信号、消息、定时器事件触发 事务子流程 在事务子流程中出现异常，子流程边界错误事件会捕捉到。事务子流程中出现取消结束流程，会触发之前的流程任务的边界补偿事务，同时触发子流程取消边界事务 特别子流程 6.0 新增，在该子流程中，不存在执行顺序，由执行时决定 2、顺序流与网关条件顺序流1234&lt;sequenceFlow id="flow3" sourceRef="exclusivegateway1" targetRef="usertask2"&gt; &lt;conditionExpression xsi:type="tFormalExpression"&gt; &lt;![CDATA[$&#123;days &lt;= 3&#125;]]&gt;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; 如果是条件网关的话，不满足条件会报错。多条满足，会默认走第一个普通顺序流 一个任务不能出现多条普通顺序流吧 网关 单向网关与条件顺序流一起使用，只能有一个条件通过 并行网关 兼容网关单向网关和并行网关结合体 事件网关和中间事务结合使用，多个任务的时候，哪个任务先触发就执行哪条任务 组合网关 不支持 3、流程活动的特性 多实例流程活动 创建多个任务实例 1234567&lt;serviceTask id="servicetask1" name="Service Task" activiti:class="org.crazyit.act.c10.ForeachDelegate"&gt; &lt;multiInstanceLoopCharacteristics isSequential="false"&gt; &lt;loopCardinality&gt;3&lt;/loopCardinality&gt; &lt;/multiInstanceLoopCharacteristics&gt;&lt;/serviceTask&gt;&gt; 设置循环数据（6.0版本） 1234 Map&lt;String, Object&gt; vars = new HashMap&lt;String, Object&gt;(); vars.put("datas1", datas1); //List&lt;String&gt;格式ProcessInstance pi = runService.startProcessInstanceById(pd.getId(), vars);&gt; 123456 &lt;serviceTask id="servicetask1" name="Service Task" activiti:class="org.crazyit.act.c10.ForeachDelegate"&gt; &lt;multiInstanceLoopCharacteristics isSequential="false" activiti:elementVariable="data"&gt; &lt;loopDataInputRef&gt;datas1&lt;/loopDataInputRef&gt; &lt;/multiInstanceLoopCharacteristics&gt;&lt;/serviceTask&gt;&gt; 12345678//处理类，List集合有多少个元素就执行几次public class ForeachDelegate implements JavaDelegate &#123; @Override public void execute(DelegateExecution execution) &#123; System.out.println("执行服务任务: " + execution.getVariable("data")); &#125;&#125;&gt; 设置了循环了数据，会有内置参数，例如nrOfCompletedInstances是当前执行的实例数添加&lt;completionCondition&gt;${nrOfCompletedInstances &gt;= 2}&lt;/completionCondition&gt;设置条件执行流程 Activiti与BPMN2.0规范 五、流程启动与服务调用API1、查询查询所有通过service获取，各个service查询类似。service.createGroupQuery().groupName(&quot;Group_1&quot;).groupType(&quot;TYPE_1&quot;).list();分页查询service.createGroupQuery().listPage(1, 5)查询单个service.createGroupQuery().groupName(&quot;Group_0&quot;).singleResult();排序service.createGroupQuery().orderByGroupId().desc().orderByGroupName().asc().list()自定义查询service.createNativeGroupQuery(). sql(&quot;SELECT * FROM ACT_ID_GROUP where NAME_ = #{name}&quot;). parameter(&quot;name&quot;, &quot;Group_2&quot;).list();保存service.newGroup(id); //新增一个执行ID值 ###2、流程部署ZIP1234FileInputStream fis = new FileInputStream(new File("resource/datas.zip"));ZipInputStream zis = new ZipInputStream(fis);builder.addZipInputStream(zis);builder.deploy(); 代码生成流程模型123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) &#123; ProcessEngine engine = ProcessEngines.getDefaultProcessEngine(); // 存储服务 RepositoryService rs = engine.getRepositoryService(); RuntimeService run = engine.getRuntimeService(); DeploymentBuilder builder = rs.createDeployment(); builder.addBpmnModel("My Process", createProcessModel()); Deployment dep = builder.deploy(); &#125;private static BpmnModel createProcessModel() &#123; // 创建BPMN模型对象 BpmnModel model = new BpmnModel(); // 创建一个流程定义 org.activiti.bpmn.model.Process process = new org.activiti.bpmn.model.Process(); model.addProcess(process); process.setId("myProcess"); process.setName("My Process"); // 开始事件 StartEvent startEvent = new StartEvent(); startEvent.setId("startEvent"); process.addFlowElement(startEvent); // 用户任务 UserTask userTask = new UserTask(); userTask.setName("User Task"); userTask.setId("userTask"); process.addFlowElement(userTask); // 结束事件 EndEvent endEvent = new EndEvent(); endEvent.setId("endEvent"); process.addFlowElement(endEvent); // 添加流程顺序 process.addFlowElement(new SequenceFlow("startEvent", "userTask")); process.addFlowElement(new SequenceFlow("userTask", "endEvent")); return model;&#125; 关闭流程部署验证1234DeploymentBuilder builder = rs.createDeployment();builder.addClasspathResource("error/schema_error.bpmn");builder.disableSchemaValidation(); //关闭builder.deploy(); 查询文件123456789101112131415ProcessEngine engine = ProcessEngines.getDefaultProcessEngine();// 存储服务RepositoryService rs = engine.getRepositoryService();DeploymentBuilder builder = rs.createDeployment();builder.addClasspathResource("my_text.txt");Deployment dep = builder.deploy();// 数据查询InputStream is = rs.getResourceAsStream(dep.getId(), "my_text.txt");int count = is.available();byte[] contents = new byte[count];is.read(contents);String result = new String(contents);//输入结果System.out.println(result); 查询流程文件1234567891011121314151617181920// 创建流程引擎ProcessEngine engine = ProcessEngines.getDefaultProcessEngine();// 得到流程存储服务对象RepositoryService repositoryService = engine.getRepositoryService();// 部署一份流程文件Deployment dep = repositoryService.createDeployment() .addClasspathResource("gen.bpmn").deploy();// 查询流程定义//查询流程定义实体ProcessDefinition def = repositoryService.createProcessDefinitionQuery() .deploymentId(dep.getId()).singleResult();// 查询资源文件InputStream is = repositoryService.getProcessModel(def.getId());// 读取输入流int count = is.available();byte[] contents = new byte[count];is.read(contents);String result = new String(contents);//输入输出结果System.out.println(result); 查询流程图片123456789101112131415161718192021// 创建流程引擎ProcessEngine engine = ProcessEngines.getDefaultProcessEngine();// 得到流程存储服务对象RepositoryService repositoryService = engine.getRepositoryService();// 部署一份流程文件与相应的流程图文件Deployment dep = repositoryService.createDeployment() .addClasspathResource("gen.bpmn").deploy();// 查询流程定义ProcessDefinition def = repositoryService.createProcessDefinitionQuery() .deploymentId(dep.getId()).singleResult();// 查询资源文件InputStream is = repositoryService.getProcessDiagram(def.getId());// 将输入流转换为图片对象 BufferedImage image = ImageIO.read(is);// 保存为图片文件File file = new File("resource/result.png");if (!file.exists()) file.createNewFile();FileOutputStream fos = new FileOutputStream(file);ImageIO.write(image, "png", fos);fos.close();is.close(); 删除流程部署12repositoryService.deleteDeployment(dep.getId());repositoryService.deleteDeployment(dep.getId(), true); //级联删除（会删除运行实例和历史数据） 3、流程定义自己指定流程图片1234567ProcessEngine engine = ProcessEngines.getDefaultProcessEngine();// 存储服务RepositoryService rs = engine.getRepositoryService();DeploymentBuilder builder = rs.createDeployment();builder.addClasspathResource("test2.bpmn").addClasspathResource("test2.png");builder.deploy(); 流程中止流程被中止后是不能被重新启动的12345678910111213141516ProcessEngine engine = ProcessEngines.getDefaultProcessEngine();// 存储服务RepositoryService rs = engine.getRepositoryService();DeploymentBuilder builder = rs.createDeployment();builder.addClasspathResource("test3.bpmn");Deployment dep = builder.deploy();ProcessDefinition def = rs.createProcessDefinitionQuery() .deploymentId(dep.getId()).singleResult(); System.out.println("id: " + def.getId());rs.suspendProcessDefinitionByKey(def.getKey());// 将会抛出异常，因为流程定义被中止了RuntimeService runService = engine.getRuntimeService();runService.startProcessInstanceByKey(def.getKey()); 启动流程任务权限12345678910111213141516171819ProcessEngine engine = ProcessEngines.getDefaultProcessEngine();// 存储服务RepositoryService rs = engine.getRepositoryService();IdentityService is = engine.getIdentityService();TaskService ts = engine.getTaskService();User user = is.newUser(UUID.randomUUID().toString());user.setFirstName("Angus");is.saveUser(user);DeploymentBuilder builder = rs.createDeployment();builder.addClasspathResource("test3.bpmn");Deployment dep = builder.deploy();ProcessDefinition def = rs.createProcessDefinitionQuery() .deploymentId(dep.getId()).singleResult();rs.addCandidateStarterUser(def.getId(), user.getId());//查询该用户有多少个流程可以启动List&lt;ProcessDefinition&gt; defs = rs.createProcessDefinitionQuery().startableByUser(user.getId()).list();for(ProcessDefinition de : defs) &#123; System.out.println(de.getId());&#125; ###4、流程任务任务候选人（组） 多少个用户或组能看见这个任务123456789101112131415161718192021222324ProcessEngine engine = ProcessEngines.getDefaultProcessEngine();TaskService ts = engine.getTaskService();IdentityService is = engine.getIdentityService();// 创建任务String taskId = UUID.randomUUID().toString();Task task = ts.newTask(taskId);task.setName(&quot;test&quot;);ts.saveTask(task);// 创建用户String userId = UUID.randomUUID().toString();User user = is.newUser(userId);user.setFirstName(&quot;angus&quot;);is.saveUser(user);// 设置任务的候选用户组ts.addCandidateUser(taskId, userId);/*添加用户到组*///is.createMembership(userId, groupId);List&lt;Task&gt; tasks = ts.createTaskQuery().taskCandidateUser(userId).list();System.out.println(userId + &quot; 这个用户有权限处理的任务有：&quot;);for(Task t : tasks) &#123; System.out.println(t.getName());&#125; 任务持有人 当前处理该任务用户，一个任务只有一个持有人12345678910111213141516171819202122 ProcessEngine engine = ProcessEngines.getDefaultProcessEngine();TaskService ts = engine.getTaskService();IdentityService is = engine.getIdentityService();// 创建任务String taskId = UUID.randomUUID().toString();Task task = ts.newTask(taskId);task.setName("test1");ts.saveTask(task);// 创建用户String userId = UUID.randomUUID().toString();User user = is.newUser(userId);user.setFirstName("angus1");is.saveUser(user);// 设置任务持有人ts.setOwner(taskId, userId);// ts.setOwner(taskId, "e110a0a5-1314-4c0c-9ba9-142447b11dea");// 根据用户来查询他所持有的任务List&lt;Task&gt; tasks = ts.createTaskQuery().taskOwner(userId).list();for(Task t : tasks) &#123; System.out.println(t.getName());&#125;engine.close(); 任务代理人12345//任务被认领之后，其他人认领就会报错ts.claim(taskId, user.getId());//任务指定代理人ts.setAssignee(taskId, user.getId()); 任务完成taskService.complete(task.getId()); 4、参数与附件设置参数 a、流程配置文件设置 1234567&lt;!-- process标签里面 --&gt;&lt;dataObject id="personName" name="personName" itemSubjectRef="xsd:string"&gt; &lt;extensionElements&gt; &lt;activiti:value&gt;Crazyit&lt;/activiti:value&gt; &lt;/extensionElements&gt;&lt;/dataObject&gt; b、启动流程设置 1234567Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();Person p = new Person();p.setId(1);p.setName("angus");map.put("p", p);map.put("key", "val1");ProcessInstance pi = runService.startProcessInstanceById(pd.getId(),map); c、服务设置 12runService.setVariable(execution.getId(), &quot;key&quot;,value);taskService.setVariable(task.getId(), &quot;key&quot;, value); d、设置本地参数 setVariable变成setVariableLocal 获取参数值12runService.getVariable(execution.getId(), &quot;key&quot;);taskService.getVariable(task.getId(), &quot;key&quot;); 附件 5、启动流程1234567//通过ID启动并设置business_key参数runService.startProcessInstanceById(pd.getId(), "test");//通过key值启动runService.startProcessInstanceByKey(pd.getKey());//通过消息启动，消息开始事件runService.startProcessInstanceByMessage(message);// 6、流程操作与数据查询task流程taskService.complete(task.getId());Receive Task流程该task不会产生task数据，只有execution123456789// 启动流程ProcessInstance pi = runService.startProcessInstanceById(pd.getId());// 查当前的子执行流（只有一个）Execution exe = runService.createExecutionQuery() .processInstanceId(pi.getId()).onlyChildExecutions() .singleResult();System.out.println(pi.getId() + ", 当前节点：" + exe.getActivityId());// 让它往前走runService.trigger(exe.getId()); 7、JOB手动执行任务（act_run_job）1234Job job = managementService.createJobQuery().singleResult();//设置重试次数managementService.setJobRetries(job.getId(), 1);managementService.executeJob(job.getId()); 六、其他6.0版本支持activiti:candidateGroups=”${prd_add}”5.X版本只能activiti:candidateGroups=”#{prd_add}”]]></content>
      <categories>
        <category>Activiti</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS]]></title>
    <url>%2F2018%2F04%2F30%2FAngularJS%2F</url>
    <content type="text"><![CDATA[例子 ng-app 指令告诉 AngularJS， 元素是 AngularJS 应用程序 的”所有者”。 ng-model 指令把输入域的值绑定到应用程序变量 name。 ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。 123456789&lt;div ng-app=""&gt; &lt;p&gt;名字 : &lt;input type="text" ng-model="name"&gt;&lt;/p&gt; &lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;div ng-app="" ng-init="firstName='John'"&gt; &lt;p&gt;姓名为 &lt;span ng-bind="firstName"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt; ng-app作用12345678910111213141516&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; 名: &lt;input type="text" ng-model="firstName"&gt;&lt;br&gt;姓: &lt;input type="text" ng-model="lastName"&gt;&lt;br&gt;&lt;br&gt;姓名: &#123;&#123;firstName + " " + lastName&#125;&#125; &lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.firstName= "John"; $scope.lastName= "Doe";&#125;);&lt;/script&gt; AngularJS 对象12345&lt;div ng-app="" ng-init="person=&#123;firstName:'John',lastName:'Doe'&#125;"&gt; &lt;p&gt;姓为 &#123;&#123; person.lastName &#125;&#125;&lt;/p&gt; &lt;/div&gt; AngularJS 数组12345&lt;div ng-app="" ng-init="points=[1,15,19,2,40]"&gt; &lt;p&gt;第三个值为 &lt;span ng-bind="points[2]"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; 重复 HTML 元素12345678910111213141516171819202122&lt;div ng-app="" ng-init="names=['Jani','Hege','Kai']"&gt; &lt;p&gt;使用 ng-repeat 来循环数组&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat="x in names"&gt; &#123;&#123; x &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div ng-app="" ng-init="names=[&#123;name:'Jani',country:'Norway'&#125;,&#123;name:'Hege',country:'Sweden'&#125;,&#123;name:'Kai',country:'Denmark'&#125;]"&gt; &lt;p&gt;循环对象：&lt;/p&gt;&lt;ul&gt; &lt;li ng-repeat="x in names"&gt; &#123;&#123; x.name + ', ' + x.country &#125;&#125; &lt;/li&gt;&lt;/ul&gt; &lt;/div&gt; 创建自定义的指令123456789101112131415&lt;body ng-app="myApp"&gt;&lt;runoob-directive&gt;&lt;/runoob-directive&gt;&lt;script&gt;var app = angular.module("myApp", []);app.directive("runoobDirective", function() &#123; return &#123; restrict : "A", template : "&lt;h1&gt;自定义指令!&lt;/h1&gt;" &#125;;&#125;);&lt;/script&gt;&lt;/body&gt; 你可以通过以下方式来调用指令： 元素名 &lt;runoob-directive&gt;&lt;/runoob-directive&gt; 属性 &lt;div runoob-directive&gt;&lt;/div&gt; 类名 注释 restrict 值可以是以下几种: E 作为元素名使用 A 作为属性使用 C 作为类名使用 M 作为注释使用restrict 默认值为 EA, 即可以通过元素名和属性名来调用指令。 ng-model 指令1234567891011&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; 名字: &lt;input ng-model="name"&gt; &lt;h1&gt;你输入了: &#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.name = "John Doe";&#125;);&lt;/script&gt; 验证用户输入12345&lt;form ng-app="" name="myForm"&gt; Email: &lt;input type="email" name="myAddress" ng-model="text"&gt; &lt;span ng-show="myForm.myAddress.$error.email"&gt;不是一个合法的邮箱地址&lt;/span&gt;&lt;/form&gt; 应用状态123456789&lt;form ng-app="" name="myForm" ng-init="myText = 'test@runoob.co"&gt;Email:&lt;input type="email" name="myAddress" ng-model="myText" required&gt;&lt;p&gt;编辑邮箱地址，查看状态的改变。&lt;/p&gt;&lt;h1&gt;状态&lt;/h1&gt;&lt;p&gt;Valid: &#123;&#123;myForm.myAddress.$valid&#125;&#125; (如果输入的值是合法的则为 true)。&lt;/p&gt;&lt;p&gt;Dirty: &#123;&#123;myForm.myAddress.$dirty&#125;&#125; (如果值改变则为 true)。&lt;/p&gt;&lt;p&gt;Touched: &#123;&#123;myForm.myAddress.$touched&#125;&#125; (如果通过触屏点击则为 true)。&lt;/p&gt; CSS 类1234567891011&lt;style&gt;input.ng-invalid &#123; background-color: lightblue;&#125;&lt;/style&gt;&lt;body&gt;&lt;form ng-app="" name="myForm"&gt; 输入你的名字: &lt;input name="myAddress" ng-model="text" required&gt;&lt;/form&gt; ng-model 指令根据表单域的状态添加/移除以下类： ng-valid: 验证通过 ng-invalid: 验证失败 ng-valid-[key]: 由$setValidity添加的所有验证通过的值 ng-invalid-[key]: 由$setValidity添加的所有验证失败的值 ng-pristine: 控件为初始状态 ng-dirty: 控件输入值已变更 ng-touched: 控件已失去焦点 ng-untouched: 控件未失去焦点 ng-pending: 任何为满足$asyncValidators的情况 AngularJS Scope(作用域)123456789101112131415&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; &lt;input ng-model="name"&gt; &lt;h1&gt;&#123;&#123;greeting&#125;&#125;&lt;/h1&gt; &lt;button ng-click='sayHello()'&gt;点我&lt;/button&gt; &lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.name = "Runoob"; $scope.sayHello = function() &#123; $scope.greeting = 'Hello ' + $scope.name + '!'; &#125;;&#125;);&lt;/script&gt; 根作用域123456789101112131415161718&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;&lt;h1&gt;&#123;&#123;lastname&#125;&#125; 家族成员:&lt;/h1&gt;&lt;ul&gt; &lt;li ng-repeat="x in names"&gt;&#123;&#123;x&#125;&#125; &#123;&#123;lastname&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope, $rootScope) &#123; $scope.names = ["Emil", "Tobias", "Linus"]; $rootScope.lastname = "Refsnes";&#125;);&lt;/script&gt; 外部文件中的控制器12345678910&lt;div ng-app="myApp" ng-controller="personCtrl"&gt;First Name: &lt;input type="text" ng-model="firstName"&gt;&lt;br&gt;Last Name: &lt;input type="text" ng-model="lastName"&gt;&lt;br&gt;&lt;br&gt;Full Name: &#123;&#123;firstName + " " + lastName&#125;&#125;&lt;/div&gt;&lt;script src="personController.js"&gt;&lt;/script&gt; AngularJS 过滤器 currency 格式化数字为货币格式。filter 从数组项中选择一个子集。lowercase 格式化字符串为小写。orderBy 根据某个表达式排列数组。uppercase 格式化字符串为大写。 123456789101112131415161718192021&lt;div ng-app="myApp" ng-controller="personCtrl"&gt;&lt;input type="number" ng-model="quantity"&gt;&lt;input type="number" ng-model="price"&gt;&lt;p&gt;姓名为 &#123;&#123; lastName | uppercase &#125;&#125;&lt;/p&gt;&lt;p&gt;姓名为 &#123;&#123; lastName | lowercase &#125;&#125;&lt;/p&gt;&lt;p&gt;总价 = &#123;&#123; (quantity * price) | currency &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;!--排序--&gt;&lt;li ng-repeat="x in names | orderBy:'country'"&gt; &#123;&#123; x.name + ', ' + x.country &#125;&#125;&lt;/li&gt;&lt;!--过滤输入--&gt;&lt;p&gt;&lt;input type="text" ng-model="test"&gt;&lt;/p&gt;&lt;ul&gt; &lt;li ng-repeat="x in names | filter:test | orderBy:'country'"&gt; &#123;&#123; (x.name | uppercase) + ', ' + x.country &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 自定义过滤器123456789var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.msg = "Runoob";&#125;);app.filter('reverse', function() &#123; //可以注入依赖 return function(text) &#123; return text.split("").reverse().join(""); &#125;&#125;); AngularJS 服务$location服务 返回当前页面的 URL 地址。1234var app = angular.module('myApp', []);app.controller('myCtrl', function($scope, $location) &#123; $scope.myUrl = $location.absUrl();&#125;); $http 服务 向服务器发送Http请求123456var app = angular.module('myApp', []);app.controller('myCtrl', function($scope, $http) &#123; $http.get("welcome.htm").then(function (response) &#123; $scope.myWelcome = response.data; &#125;);&#125;); $timeout 服务 $timeout 服务对应了 JS window.setTimeout 函数。1234567var app = angular.module('myApp', []);app.controller('myCtrl', function($scope, $timeout) &#123; $scope.myHeader = "Hello World!"; $timeout(function () &#123; $scope.myHeader = "How are you today?"; &#125;, 2000);&#125;); $interval 服务 $interval 服务对应了 JS window.setInterval 函数。123456app.controller('myCtrl', function($scope, $interval) &#123; $scope.theTime = new Date().toLocaleTimeString(); $interval(function () &#123; $scope.theTime = new Date().toLocaleTimeString(); &#125;, 1000);&#125;); 创建自定义服务12345678910var app = angular.module('myApp', []);app.service('hexafy', function() &#123; this.myFunc = function (x) &#123; return x.toString(16); &#125;&#125;);app.controller('myCtrl', function($scope, hexafy) &#123; $scope.hex = hexafy.myFunc(255);&#125;); 过滤器中，使用自定义服务1234567891011121314151617&lt;div ng-app="myApp"&gt; 在过滤器中使用服务: &lt;h1&gt;&#123;&#123;255 | myFormat&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.service('hexafy', function() &#123; this.myFunc = function (x) &#123; return x.toString(16); &#125;&#125;);app.filter('myFormat',['hexafy', function(hexafy) &#123; return function(x) &#123; return hexafy.myFunc(x); &#125;;&#125;]);&lt;/script&gt; $http12345678910111213// 简单的 GET 请求，可以改为 POST$http(&#123; method: 'GET', url: '/someUrl'&#125;).then(function successCallback(response) &#123; // 请求成功执行代码 &#125;, function errorCallback(response) &#123; // 请求失败执行代码&#125;);//简写$http.get('/someUrl', config).then(successCallback, errorCallback);$http.post('/someUrl', data, config).then(successCallback, errorCallback); 1234567891011121314151617&lt;div ng-app="myApp" ng-controller="siteCtrl"&gt; &lt;ul&gt; &lt;li ng-repeat="x in names"&gt; &#123;&#123; x.Name + ', ' + x.Country &#125;&#125; &lt;/li&gt;&lt;/ul&gt; &lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', []);app.controller('siteCtrl', function($scope, $http) &#123; $http.get("http://www.runoob.com/try/angularjs/data/sites.php") .then(function (response) &#123;$scope.names = response.data.sites;&#125;);&#125;);&lt;/script&gt; AngularJS Select(选择框)1234567891011121314151617&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; &lt;select ng-init="selectedName = names[0]" ng-model="selectedName" ng-options="x for x in names"&gt;&lt;/select&gt; &lt;!--也可以使用下面的--&gt; &lt;select&gt;&lt;option ng-repeat="x in names"&gt;&#123;&#123;x&#125;&#125;&lt;/option&gt;&lt;/select&gt; &lt;/div&gt; &lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.names = ["Google", "Runoob", "Taobao"];&#125;);&lt;/script&gt; ng-options 与 ng-repeat区别 http://www.runoob.com/angularjs/angularjs-select.html AngularJS 表格 http://www.runoob.com/angularjs/angularjs-tables.html AngularJS HTML DOM和事件ng-disabled 指令1234567891011&lt;div ng-app="" ng-init="mySwitch=false"&gt;&lt;p&gt;&lt;button ng-disabled="mySwitch"&gt;点我!&lt;/button&gt;&lt;/p&gt;&lt;p&gt;&lt;input type="checkbox" ng-model="mySwitch"/&gt;按钮&lt;/p&gt;&lt;p&gt;&#123;&#123; mySwitch &#125;&#125;&lt;/p&gt;&lt;/div&gt; ng-show 指令1234&lt;div ng-app="" ng-init="hour=13"&gt;&lt;p ng-show="true"&gt;我是可见的。&lt;/p&gt;&lt;p ng-show="false"&gt;我是不可见的。&lt;/p&gt;&lt;p ng-show="hour &gt; 12"&gt;我是可见的。&lt;/p&gt; ng-hide 指令12&lt;p ng-hide="true"&gt;我是不可见的。&lt;/p&gt;&lt;p ng-hide="false"&gt;我是可见的。&lt;/p&gt; ng-click 指令12&lt;button ng-click="count = count + 1"&gt;点我！&lt;/button&gt;&lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt; 隐藏 HTML 元素12345678910111213141516171819202122232425&lt;div ng-app="myApp" ng-controller="personCtrl"&gt;&lt;button ng-click="toggle()"&gt;隐藏/显示&lt;/button&gt;&lt;p ng-hide="myVar"&gt;&lt;!--&lt;p ng-show="myVar"&gt;--&gt;名: &lt;input type="text" ng-model="firstName"&gt;&lt;br&gt;姓名: &lt;input type="text" ng-model="lastName"&gt;&lt;br&gt;&lt;br&gt;Full Name: &#123;&#123;firstName + " " + lastName&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('personCtrl', function($scope) &#123; $scope.firstName = "John", $scope.lastName = "Doe" $scope.myVar = false; $scope.toggle = function() &#123; $scope.myVar = !$scope.myVar; &#125;;&#125;);&lt;/script&gt; AngularJS 表单 http://www.runoob.com/angularjs/angularjs-forms.html 数据绑定&lt;input type=&quot;text&quot; ng-model=&quot;firstname&quot;&gt; Checkbox（复选框） 单选框 单选框使用同一个 ng-model 下拉菜单HTML 表单AngularJS 全局 API 全局 API 函数使用 angular 对象进行访问。 angular.lowercase() 转换字符串为小写 angular.uppercase() 转换字符串为大写 angular.isString() 判断给定的对象是否为字符串，如果是返回 true。 angular.isNumber() 判断给定的对象是否为数字，如果是返回 true。 switch case语句123456&lt;p ng-switch = "x3"&gt; 是不是字符串： &lt;label ng-switch-when = "true"&gt;是&lt;/label&gt; &lt;label ng-switch-when = "false"&gt;不是&lt;/label&gt; &lt;label ng-switch-when = ""&gt;&lt;/label&gt;&lt;/p&gt; AngularJS 包含包含html页面ng-include=&quot;&#39;runoob.htm&#39;&quot; 跨域包含AngularJS 动画AngularJS 依赖注入AngularJS 路由### ng-bind 和花括号的区别就是 启动加载的时候显示不同]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty]]></title>
    <url>%2F2018%2F04%2F30%2Fnetty%2F</url>
    <content type="text"><![CDATA[同步阻塞IO—-BIO同步非阻塞IO—-JAVA-NIO异步非阻塞IO—-JAVA-AIO Channel：通道Buffer：缓冲区Selector：选择器 多个通道注册到一个选择器中，所有的数据都是与缓冲区交互，然后缓冲区与通道交互]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6快速入门]]></title>
    <url>%2F2018%2F04%2F27%2FES6%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1. 变量声明const和let let表示变量（局部变量） const表示常量（JAVA的final） 2. 模板字符串123456789101112131415161718192021222324252627const name = &apos;lux&apos;;console.log(`hello $&#123;name&#125;`) //hello lux//多行文本--使用反引号// ES5var msg = &quot;Hi \man!&quot;// ES6const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;`// 1.includes：判断是否包含然后直接返回布尔值const str = &apos;hahay&apos;console.log(str.includes(&apos;y&apos;)) // true// 2.repeat: 获取字符串重复n次const str = &apos;he&apos;console.log(str.repeat(3)) // &apos;hehehe&apos;//如果你带入小数, Math.floor(num) 来处理// s.repeat(3.1) 或者 s.repeat(3.9) 都当做成 s.repeat(3) 来处理// 3. startsWith 和 endsWith 判断是否以 给定文本 开始或者结束const str = &apos;hello world!&apos;console.log(str.startsWith(&apos;hello&apos;)) // trueconsole.log(str.endsWith(&apos;!&apos;)) // true 3. 函数默认参数，类似于python123function action(num = 200) &#123; console.log(num)&#125; 箭头函数1234567891011121314151617181920212223242526272829303132x =&gt; x * x//等于下面function (x) &#123; return x * x;&#125;x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123;p return - x * x; &#125;&#125;// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125;//返回对象x =&gt; (&#123; foo: x &#125;) 4. 拓展的对象功能对象初始化简写123456function people(name, age) &#123; return &#123; name, // name : name age // age : age &#125;;&#125; 浅克隆5. 更方便的数据访问–解构123456789101112//对象const people = &#123; name: 'lux', age: 20&#125;const &#123; name, age &#125; = peopleconsole.log(`$&#123;name&#125; --- $&#123;age&#125;`)//数组const color = ['red', 'blue']const [first, second] = colorconsole.log(first) //'red'console.log(second) //'blue' Object.assign() 可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{} 6. Spread Operator 展开运算符123456789101112131415//数组const color = ['red', 'yellow']const colorful = [...color, 'green', 'pink']console.log(colorful) //[red, yellow, green, pink]//对象const alp = &#123; fist: 'a', second: 'b'&#125;const alphabets = &#123; ...alp, third: 'c' &#125;console.log(alphabets) //&#123; "fist": "a", "second": "b", "third": "c"//数组const number = [1,2,3,4,5]const [first, ...rest] = numberconsole.log(rest) //2,3,4,5&#125; 7. import导入模块、export导出模块123456789101112131415161718//全部导入import people from './example'//有一种特殊情况，即允许你将整个模块当作单一对象进行导入//该模块的所有导出都会作为对象的属性存在import * as example from "./example.js"console.log(example.name)console.log(example.age)console.log(example.getName())//导入部分import &#123;name, age&#125; from './example'// 导出默认, 有且只有一个默认export default App// 部分导出export class App extend Component &#123;&#125;; 作者：陈嘻嘻啊链接：https://www.jianshu.com/p/287e0bb867ae來源：简书]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python进阶]]></title>
    <url>%2F2018%2F04%2F23%2Fpython%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[python把函数作为参数1234def add(x, y, f): return f(x) + f(y)add(-5, 9, abs)# 其实是调用 abs(-5) + abs(9) 常用函数 map()函数 1234def f(x): return x*xprint map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])# 输出 [1, 4, 9, 10, 25, 36, 49, 64, 81] reduce()函数 123def f(x, y): return x + yprint reduce(f, [1, 3, 5, 7, 9]) filter()函数 1234def is_odd(x): return x % 2 == 1filter(is_odd, [1, 4, 6, 7, 9, 12, 17])# 输出 [1, 7, 9, 17] sorted()函数 12345678910sorted([36, 5, 12, 9, 21]) # 排序def reversed_cmp(x, y): if x &gt; y: return -1 if x &lt; y: return 1 return 0sorted([36, 5, 12, 9, 21], reversed_cmp)# 输出 [36, 21, 12, 9, 5] 装饰者模式 1234567891011from functools import reducedef log(f): def fn(x): print('call ' + f.__name__ + '()...') return f(x) return fn@log # 指定被装饰的方法def factorial(n): return reduce(lambda x,y: x*y, range(1, n+1))print(factorial(10)) 偏函数 123import functoolsint2 = functools.partial(int, base=2)# int2就是一个偏函数]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud]]></title>
    <url>%2F2018%2F04%2F10%2FSpringCloud%2F</url>
    <content type="text"><![CDATA[服务注册 spring Cloud eureka他是一个服务注册中心，服务消费者会注册到服务中心，服务实例会通过心跳方式定时通知服务中心（定时向注册中心更新实例。默认30S），Eureka Server收到心跳后，会通知集群里的其它Eureka Server更新此实例的状态。 在Service Provider服务shutdown的时候，主动通知Eureka Server把自己剔除，从而避免客户端调用已经下线的服务。 Eureka Server会定时，进行检查，如果发现实例在在一定时间，内没有收到心跳，则会注销此实例。（间隔值是eureka.server.eviction-interval-timer-in-ms，默认值为60） 保护模式：则会触发自我保护模式，此时Eureka Server此时会认为这是网络问题，它不会注销任何过期的实例。 其他服务注册中心也有Consul和Zookeeper 依赖12345678910&lt;!-- eureka server --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- eureka client --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件server12345678910111213server.port=9990#服务名称spring.application.name=eureka-server#服务地址eureka.instance.hostname=127.0.0.1#是否注册eureka（当高可用模式下才会启用） 是否向服务注册中心注册自己eureka.client.register-with-eureka=false#是否启用获取服务注册信息eureka.client.fetch-registry=false#注册和查询都需依赖该地址，多个以逗号分隔eureka.client.serviceUrl.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/#留存的服务实例低于多少比列进入保护模式 默认是85%eureka.server.renewal-percent-threshold=0.5 client12345678server.port=8083spring.application.name=comment#eureka server地址eureka.client.serviceUrl.defaultZone=http://127.0.0.1:9990/eureka/# 心跳间隔 5s 默认30seureka.instance.lease-renewal-interval-in-seconds=5# 服务失效时间： 如果多久没有收到请求，则可以删除服务 默认90seureka.instance.lease-expiration-duration-in-seconds=10 代码eureka server在启动类添加注解@EnableEurekaServereureka client在启动类添加注解@EnableEurekaClient @EnableEurekaClient和@EnableEurekaClient功能类似，但是@EnableEurekaClient只用于eureka。 网关服务 apigateway我这里的例子是web服务，所有采用的是springBoot作为网关。如果是应用服务可以用spring Cloud zuul 所有的接口都是通过网关提供出去的，所以身份认证、路由服务、流量控制、日志统计代码编写都是在网关服务。 springBoot配置123456server.port=8090spring.application.name=api-gateway###########eureka配置#################eureka.client.serviceUrl.defaultZone=http://127.0.0.1:9990/eureka/#是否向服务注册中心注册自己#eureka.client.register-with-eureka=false spring Cloud zuulzuul主要就是路由转发和过滤器 依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;&lt;/dependency&gt; 配置12345678server.port=8769spring.application.name=service-zuuleureka.client.service-url.defaultZone=http://127.0.0.1:8761/eurekazuul.routes.api-a.path=/api-a/**zuul.routes.api-a.path.serviceId=service-azuul.routes.api-b.path=/api-b/**zuul.routes.api-b.path.serviceId=service-b#api-a 和api-b 都是对应子服务的名称 启动启动类添加@EnableZuulProxy注解 网关与子服务通信两种通信方式：restTemplate+httpclient和feign restTemplate+httpclient1、注入restTemplate12345@Bean//@LoadBalancedRestTemplate restTemplate() &#123; return new RestTemplate();&#125; 2、调用原子服务post1int result = restTemplate.postForObject("http://comment/insert", comment, Integer.class); get123Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put("nid", nid);List&lt;CommentUser&gt; response = restTemplate.getForObject("http://comment/list?nid=&#123;nid&#125;", List.class,map); 其中comment就是服务配置文件中的spring.application.name=comment feign依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt; 请求方式类似于controller编写123456789@FeignClient(value = "comment")public interface NewsFeign &#123; @RequestMapping(value="insert",method=RequestMethod.POST) public int insert(@RequestBody Comment comment); @RequestMapping(value="list",method=RequestMethod.GET) public List&lt;CommentUser&gt; queryAll(int nid);&#125; 负载均衡ribbonrestTemplate+httpclient方式1、需要添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 2、添加注解@LoadBalanced12345@Bean@LoadBalanced // 启动负载均衡public RestTemplate restTemplate()&#123; return new RestTemplate();&#125; feignfeign默认集成了ribbon 断路器hystrix服务隔离（每个服务有单独线程池）、熔断(也可以称为断路)、降级等手段控制依赖服务的延迟与失败。防止单个服务的故障，从而影响整个系统的性能，避免分布式环境里大量级联失败。使用快速失败策略，当调用一个服务超时，或者，线程池满了的情况，会立即拒绝服务而不会排队等待，还有服务降级，当调用失败的时候，就调用备用的服务。 依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 配置12345678910111213###########hystrix配置#################执行超时时间，超过这个时间执行没反应就返回hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=2000#并发执行的最大线程数，默认10hystrix.threadpool.default.coreSize=5#线程最大队列数 默认1hystrix.threadpool.default.maxQueueSize=1#最大的线程池#hystrix.threadpool.default.maximumSize=10#错误比率阀值，如果错误率&gt;=该值，断路器会被打开，并短路所有请求触发fallback。默认50hystrix.command.default.circuitBreaker.errorThresholdPercentage=1#触发短路的时间值，当该值设为5000时，则当触发circuit break后的5000毫秒内都会拒绝request，也就是5000毫秒后才会关闭circuit。默认5000hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds=100000 代码可以使用注解自定义配置12345678910111213141516171819202122232425262728293031323334353637@Repository@DefaultProperties(groupKey="newsDao",commandProperties=&#123;@HystrixProperty(name="execution.isolation.thread.timeoutInMilliseconds",value="2000")&#125;,threadPoolProperties=&#123;@HystrixProperty(name="coreSize",value="10"),@HystrixProperty(name="maxQueueSize",value="1000")&#125;,threadPoolKey="newsDao")public class NewsDao &#123; @Autowired private RestTemplate restTemplate; public int insert(News news)&#123; return restTemplate.postForObject("http://news/news/insert", news, Integer.class); &#125; @HystrixCommand public UserNews queryOne(int id)&#123; Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put("id", id); UserNews response = restTemplate.getForObject("http://news/news/query?id=&#123;id&#125;", UserNews.class, map); return response; &#125; @HystrixCommand(fallbackMethod = "errFallback") public List&lt;News&gt; queryAll()&#123; List&lt;News&gt; response = restTemplate.getForObject("http://news/news/list", List.class); return response; &#125; /** * 有降级方法，但是用户线程池用完了的话，还是会启动短路器。并且一定的时间段调用还是会拒绝所有请求，当这个请求时间过了的时候，等下一次请求正常访问，断路器才会关闭 * @return */ public List&lt;News&gt; errFallback()&#123; return null; &#125;&#125; 启动方式在启动类添加注解@EnableCircuitBreaker 服务跟踪系统Sleuth分布式服务跟踪系统，微服务中，分布式服务架构，业务的调用链越来越复杂。分布式服务跟踪是整个分布式系统中跟踪一个用户请求的过程（包括数据采集、数据传输、数据存储、数据分析、数据可视化）提供链路追踪，故障快速定位，可视化各个阶段耗时，进行性能分析。理清服务依赖关系 依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件12345#############zipkin配置################1就是 100%采样spring.sleuth.sampler.percentage=1#zipkin服务地址spring.zipkin.baseUrl=http://127.0.0.1:9993 通过引入spring-cloud-starter-zipkin依赖和设置spring.zipkin.base-url就可以了。 监控系统1、admin健康检测，监控服务的堆栈，线程、GC、请求等信息 a. 创建一个admin服务，添加依赖。设置端口99921234&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;&lt;/dependency&gt; b. 添加启动类注解@EnableAdminServerc. 子服务添加依赖和admin服务地址配置123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;version&gt;1.5.1&lt;/version&gt;&lt;/dependency&gt; 123456###########spring-admin配置###########spring.boot.admin.url=http://localhost:9992#管理地址management.port=8099#关闭安全访问management.security.enabled=false 2、hystrix dashboard监控信息包括请求成功，失败（客户端抛出的异常），超时和线程拒绝。如果访问依赖服务的错误百分比超过阈值,断路器会跳闸，此时服务会在一段时间内停止对特定服务的所有请求 a. 创建hystrix-dashboard服务，添加依赖，端口为9991123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; b. 启动类添加注解@EnableHystrixDashboard 3、zipkin服务调用在整个链路中的状态可视化界面。sleuth收集数据，然后发送到zipkin存储展示。(默认存储到内存中，也可以存储到redis/mysql) a. 创建zipkin服务，添加依赖，端口为999312345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt;&lt;/dependency&gt; b. 添加启动依赖注解@EnableZipkinServer 本文springCloud源码链接ELK日志分析平台服务产生的日志文件后，logstash去收集，然后解析，输出到ElasticSearch中，最后由kibana展示出来。 ElasticSearchElasticSearch是一个基于 Lucene 的搜索服务器。安装：Elasticsearch 基础入门常见坑：elasticsearch启动常见错误 kibana数据可视化平台，安装最简单，安装完后指向ES地址即可。 logstashLogstash 基础入门Logstash 是一个开源的数据收集引擎，它具有备实时数据传输能力。难点就是编写配置文件中的过滤器部分：grok 插件 grok 插件用于过滤杂乱的内容，将其结构化，增加可读性。 1234567891011121314151617181920212223input&#123; file&#123; path =&gt; "C:\gaojindeng\mooc\api-gateway\logs\house-info*" sincedb_path =&gt; "C:\gaojindeng\logstash-6.2.3\sincedb_house" codec =&gt; multiline &#123; pattern =&gt; "^%&#123;TIMESTAMP_ISO8601&#125;" negate =&gt; true what =&gt; "previous" &#125; &#125;&#125;filter &#123; &#125;output &#123; elasticsearch &#123; hosts =&gt; ["192.168.1.103:9200"] index =&gt; "house-info-%&#123;+YYYY.MM.dd &#125;" &#125; stdout &#123;codec =&gt; rubydebug&#125;&#125; ELK整体搭建：搭建ELK日志分析平台 其他SpringCloud Config：全局配置，比如git,svn，githupSpringCloud Bus： +RabbitMQ 可以实现配置更新通知所有服务 log4j2 和logback日志对比 异步模式性能优秀 插件化架构易扩展 log4j2：多个线程会把日志放入到一个无锁化环形队列，然后由一个异步队列去拉取队列的数据打印到日志里面去]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你读财报]]></title>
    <url>%2F2018%2F04%2F01%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%AF%BB%E8%B4%A2%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[简单公式资产=负债+股东权益 资产负债表一、流动资产（经营性资产） 货币资金 简介：银行存款、现金、准备金、库存现金（保险柜里的钱），存银行的采购，专款专用的钱，同业（冻结和被质押的存款） 影响： 过大的表资金运用能力较弱，过小，在偿债能力不足。 货币资金远小于负债，说明随时有偿债危机爆发，货币充裕，但基本都是高利贷。 其他货币资金巨大，但没有合理解释。 应收票据 简介：银行承兑汇票和商业承兑汇票，急用钱，就会把银行承兑汇票打折出售给银行，这个折扣就叫做银行贴现。银行转给其他银行叫转贴现，还有直接给了央行，拿到现金，这就叫做再贴现。商业承兑汇票是企业开出来的。 应收账款 简介：大部分都是赊账拿货，然后卖完了再把钱给你。 影响：应收账款占收入比例较大，且长期没有还，就说明有问题。 应收账款的时间，如果拖的越久，变成烂账的可能性就越大。而坏账准备就会计提越多。(计提就是预先计入某些已经发生但未实际支付的费用；) 也就是多年未还，就计资产减值损失。熊市好多企业大量的隐藏收入就是这个，然后牛市又把利润释放出来，从而达到套现或者增发的目的。 举例：一些公司，会以客户的名义打入一笔钱，用来冲销数额巨大的期限过长的应收账款，然后再把这笔钱，通过其他应收款和预付款，购货款的名义转出去，于是就不用减值太多，所以资产就增加了。还有利用关联方，先将应收账款收回，然后通过在建工程和无形资产长期投资这些项目把资金流出，这样就能光明正大的折旧了。 预付账款 简介：先交钱再拿货，如果预付款过多的话，那么也就意味着这个公司没什么地位，总是处于资金被压榨的地位。 影响：还有长期挂账的预付款，这很可能就是一种资金挪用，通过预付款把钱拿走不知道干什么去了。给投资者出个招，就是要把历年的预付款占应收的比例都算出来，如果这个比例大幅度波动，就要找原因，如果没有原因，就有可能是个雷了。 其他应收款 简介：这就是个垃圾筐，无关营业的应收款，都会放到这里面。比如借钱给别人。优秀的工作一般都是0 长期应收款 简介：主要是融资租赁和递延分期付款，比如公司卖的房，别人分期还款。 存货 简介：就是企业在生产过程中的原材料。基本上劳务福利，折旧费和修理费，办公水电耗材全都放在这里了。 影响：基本上劳务福利，折旧费和修理费，办公水电耗材全都放在这里了。利用存货造假的手法很多，比如为了虚增利润，故意不对已经贬值的存货计提跌价准备，减少费用就会让利润增多。还有，很多公司还通过让存货大量增长，从而掩护大量现金流出，然后再以关联公司虚构订单方式回来。还有用增加存货的方式来增加毛利率，美化报表。 例子：所以你看到毛利率大幅提升的时候，应该赶紧去看看存货是不是也大幅增加了，如果是的话，那么这个报表就是做出来的。 其他 应收利息：应收利息则是指企业因债权投资而应收取的一年内到期收回的利息 二、非流动资产（生产相关资产） 固定资产 简介：包括房屋建筑物，机器，运输车辆等，按折旧计算。随时间要做减值准备 影响：短期内折旧很快，说明公司在着眼于未来发展，他们希望把更多的业绩留到以后。 在建工程和工程物资 简介：在建工程是不需要折旧的，因为还没建好 影响：如果你发现有一个在建工程很长时间都不转入固定资产，那么有两个可能，一是公司避免折旧，不愿意减少利润。二一个其实我们之前讲过，是上市公司通过在建工程向关联供应商输送资金，然后再采购商品，增加订单，流入公司。最后这种在建工程，往往会通过大比例折旧，或者意外损毁的名义毁尸灭迹。 无形资产 简介：知识产权一类或者是品牌。这其中注意，包括了土地使用权。所以如果买地产股，一定注意这个科目。 影响：无形资产也是有折旧的，但他叫做摊销。这其中有个叫做研发费用的项目，也是用来调整报表的。低收入企业通常把研发费用计算到无形资产里面，而不进入公司费用，也是为了粉饰报表，显得资产多一点，利润高一点。 商誉 简介：说白了就是你花10块钱，愿意买7块钱的东西，3块钱的附加值就是商誉。但只有公司收购之后才会体现，一般公司的报表里都是0。 长期待摊费用 简介：是企业已经支出的，但持续期1年以上的费用。比如装修房子，修理机器等等，这些需要进入当期费用，然后从利润里扣除。比如预交了一年的房租。 递延所得税资产和负债 简介：会计算的所得税和税务算的不一样，但一定要按照税务算的交，于是如果算的少了，多交了钱，回去就把多交的钱，写在递延所得税资产里面。相反就是负债 三、投资相关的资产 交易性金融资产 简介：交易性金融资产主要是指企业为了近期内出售而持有的金融资产，如企业以赚取差价为目的从二级市场购入的股票、债券、基金等。 可供出售金融资产 简介：随时可以卖了，牛市里这块就是低估的金矿。而熊市里这就是地雷。 长期股权投资 简介：指的是上市公司持有其他公司股份，一般是那种战略投资。有这么几个关系，持股大于50%叫做控制，持股在20%-50%之间，叫做联营，持股100%，叫做全资子公司。还有一种合营，持股随便约定。这种长期投资不计入利润，只要不卖，股权价值变动对于公司没影响，如果持有公司分红，还会被计入到利润。 投资性房地产 简介：这里面有一个巨大的陷阱，那就是很多人看房产股的时候发现市盈率和市净率都很低啊，其实主要都是公允价值计量所造成的，每年房价上涨，净利润和净资产都会很多，表现出来就是获利能力强，资产庞大，但事实上公允价值都是财富幻觉，这个很多普通人买房是一样的，总觉得自己很有钱，因为房子值上千万，但其实这都没什么卵用，好比你打高一分钱，买入中石油100股，大概只需要700块钱，但你却能瞬间提高中石油的市值将近20亿，所以懂了吧，这东西都是乘数乘出来的，其实根本就没这么多钱。大量的房地产公司，其实就是用这些公允价值玩出了把戏，而实际上一旦房价不涨了，其实根本就无法变现。 其他 持有至到期投资 固定资产清理：固定资产清理是指企业因出售、报废和毁损等原因转入清理的固定资产价值及其在清理过程中所发生的清理费用和清理收入等。 四、负债和股东权益1. 负债 主要也是为了方便债权人看他到底有没有偿债能力。如果一个公司分红，就会大幅增加分配性负债，从资产的未分配利润科目划入到负债的应付股利科目，如果你发现公司净资产大幅下降，先不要慌，看看是不是因为分红了。很多公司分红并不是真心的，而是出于再融资的考虑，大比例分红后，净资产下降，但净利润却不变，所以净资产收益率就大幅提升了，他就可以符合要求，进行再融资了。所以你要翻翻这个公司的历史，看有没有这个传统，分红之后再融资。如果有千万别踩雷。 注意房地产： 【在会计准则里，房企预收账款按负债计，但预收款本质上是尚待确认的营业收入，不需要支付利息，和通常语境下的负债不是一回事。预收款多，说明房企房子卖得多，经营状况好。】 应付薪酬工资 简介：假如老总年薪百万，会计如果把你的工资计入管理费用，就要从利润里面减掉，公司营业利润就少了上百万，如果想释放这百万的利润出来，就把你同时任命为车间主任，待遇不变。然后你的工资就进入了生产成本，变成了存货。薪资是不会减少的，除了裁员 所有者权益（净资产）、股东权益 股本 简介：总股数 盈余公积金 简介：是利润留下来的，是继续扩大再生产的钱，法定盈余公积是政府强制股东留下来的，一般10%。 未分配利润 简介：企业赚的钱提取了盈余公积金之后，剩下的就是未分配利润了，企业可以利用盈余公积金和未分配利润送红股，前提是有利润，送股后盈余公积金不得低于注册资本的25%。 注意：但未分配利润可不一定都是现金，公司手里的钱就是货币资金里面的现金和现金等价物，未分配利润可能已经被公司挪用出去投资了，比如变成了固定资产或者是土地厂房什么的。 资本公积金 简介：叫做股本溢价或者资本溢价，计入资本公积。换句话说，资本公积金，就是放置股东投入的地方。 库存股 简介：公司将已经发行出去的股票，从市场中买回，存放于公司，而尚未再出售或是注销 归属于母公司股东权益合计 少数股东权益 股东权益合计 简介：净资产所有者权益合计＝母公司股东权益合计母＋少数股东权益合计 负债和股东权益总计 简介：公司将已经发行出去的股票，从市场中买回，存放于公司，而尚未再出售或是注销 注意 也就是所有带应收两字的总和，减去应收票据里的银行承兑汇票金额，然后除以总资产。如果这个比例过大， 比如超过了3成，说明资产质量不佳。欠的钱很可能拿不回来，第二看是否有大的变动，总资产基本上变动不大，应收如果变动很大的话，那么一定是销售出了问题，可能就是公司变坏的苗头。 货币资金除以有息负债，看你抵御危机的能力，特别是在经济逆周期，比如现在，看看有多少现金和现金等价物，是你投资一个公司的根本保证，未来现金会越来越值钱，而如果负债过多，会在加息周期，步伐越来越沉重。 非主业资产比上总资产，无疑就是看公司业务是否聚焦，如果这个比例过大，那么也就意味着他觉得自己的主业已经不赚钱了 利润表公式：利润=收入-支出 营业收入(营业总收入) 描述：企业卖出的产品所获得的收益就是营业收入。一个是销售商品，一个提供劳务，另外一个就是让渡资产使用权 营业成本 描述：卖出去的产品就是营业成本.主要包括两部分，一个是产品成本，以及劳务成本。 营业总成本 描述：营业成本，营业税金及附加，营业费用，营业费用又包括销售费用，管理费用和财务费用。俗称三费。 销售费用是销售产品所产生的费用，比如广告费，促销费保险运输费，装卸费，销售人员的返点等等。销售费用和销售收入应该是同涨共跌的，毕竟多列销售费用的目的就是促进销。 管理费用包含管理者的工资福利，工会经费，职工教育培训，行政开支。比如员工乱开发票。管理费用太大说明管理不行 财务费用主要就是利息和手续费 毛利润 描述：主营收入（营业收入）减去主营成本就是毛利润，而毛利润占主营收入的比例就是毛利率，毛利低的行业，竞争很激烈，毛利高的行业才有护城 营业利润 描述：收入和成本相减 营业利润率 描述：营业利润除以营业总收入。然后跟同行比较一下，如果这个指标高，说明这个公司在行业里的竞争地位很强。 净利润 描述：营业利润加上其他的营业外的收支净额，交完所得税，剩下的钱。 扣非净利润 描述：由于能为公司带来利润的方法很多,比如:股权投资,打新股,财补贴,债务重组…等,这些东西跟公司的主营业务无关,都是一次性的,不可持续的 资产减值损失 描述：一般投资亏了，或者坏账了，才会提这个减值损失。 公允价值变动 描述：主要是交易性金融资产，比如买了很多的房子，房价涨了，这块也就跟着涨而来。 投资收益 描述：是股票分红，债券利息，主要指那些付息的东西，在还本付息之前，拿到的利息收入。 汇兑收益 描述：就是企业持有外汇资产或者负债期间，所造成的汇率变化。 营业外收入 描述：比如卖一栋房，专业投资者上来就会把这些营业外收入给剔除掉，因为这东西根本不可持续。 营业外支出 描述：包括的项目有固定资产盘亏、处置固定资产净损失、处置无形资产净损失、债务重组损失、计提的无形资产减值准备、计提的固定资产减值准备、计提的在建工程减值准备、罚款支出、捐赠支出、非常损失等。 营业税金及附加 描述：营业税、消费税以及城建税、教育费附加、地方教育附加。 所得税 描述： 其他综合收益 描述：可供出售金融资产的公允价值变动、减值及处置导致的其他综合收益的增加或减少。 综合收益总额 描述：综合收益总额是企业净利润搜索与其他综合收益的合计金额。其中净利润好理解，而其他综合收益是指直接计入所有者权益的利得或损失扣除所得税之后的余额，它们都属于利润表大类项目。 公式 (1)营业利润=营业利润=营业收入-营业成本-营业税金及附加-销售费用-管理费用-财务费用-资产减值损失+公允价值变动净收益+投资净收益 (2)利润总额＝营业利润＋营业外收入－营业外支出 (3)净利润=利润总额-所得税费用 注意 净利润必须结合现金一起看，脱离了现金你会被骗的怀疑人生的。很简单打白条，把货拉走，权益发生了，净利润增加了，但钱却压根没见着。看似净利润大增，过几天人家告诉你应收账款全都坏账了，企业分分钟变成巨亏。这都是套路。套的就是那些只看利润不看现金的股市上懒惰的投资者。 重点1. 营业收入 潜在需求增长 市场整个份额扩大了。 市场份额扩大 抢了别人的份额,，很可能会带来价格战和报复。 价格提升 牺牲客户利益为大家。那就看会不会让客户减少了。还要看替代产品强不强。 营业增长速度 还要跟同行比较 2.毛利率 高毛利率就说明很强的竞争优势，我建议大家毛利率40%以下的就可以不看了。因为替代性太强的企业， 3.费用率 三费占营业总收入的比例，这个指标反映的是公司的管理水平。要跟同行比较。销售费用管理费用，财务费用加在一起除以毛利润，比例小于30%，这个企业就算不错 4.营业利润率 营业利润除以营业收入；跟同行比较 经营现金流净额，除以净利润。这个比值越大越好大于1就是好企业了 现金流量表三大类经营活动，投资活动和筹资活动 投资活动 就是收购 筹资活动，公司回购股票，向股东分红，借债，发行股票再融资等等。 经营活动 经营活动现金流入 描述： 主要是销售商品或者提供劳务产生现金，收到税费返还的钱，还有收到其他与企业经营有关的钱，比如出租什么的。 经营活动现金流出 描述：购买商品，接受劳务，付出的钱，支付应付款，减去本期退货收到的现金。支付给职工的工资，奖金以及各种津贴。支付各种税费，还比如支付各种租金。 重点 重点就是要得到流量净额这个数据，要从净利润反推经营活动现金收入净额，拢共分三步，第一步就是把净利润里扣除的费用，比如什么资产减值准备和折旧摊销全部都给他加回去，第二步是把净利润跟经营活动无关的收入，全部减去，比如什么投资收益，募集资金收入，非经常性的损益。第三步，把经营活动中没有包含在成本里的现金支出减去，比如多交了得税，这个在递延所得税资产里，增加了的存货，以及增加了的营收和支付了的应付 销售商品和提供劳务收到的现金，这个数字可以和营收对比，因为前者包含了增值税，所以两个数字按照理论来说应该前者是后者的1.17倍，前面的数字比后面大就对了，如果销售商品提供劳务还没有营收多，那就有问题了。证明大量款项被作为应收账款，打了白条。这笔钱能不能收回，就很难说了。 如果一个企业总是花钱投资，属于扩张阶段，如果一个企业投资活动现金流是往回流的，是正数，那么说明这个企业已经扩张放缓，属于收缩阶段。 8种企业的组合 妖怪型：经营现金流，投资现金流筹资现金流都是正向流入的企业，企业本身赚钱，但是有不投资，而且还向别人借钱。 这类企业现实中还真存在，属于妖怪型，他们可能随时要开展一场大规模的投资活动，要不就是在借着上市公司的壳搞钱，搞到钱之后在给关联方使用。反正这样的企业相当可疑。估计是没憋好屁。 老母鸡型，经营流入，投资流入，筹资流出，很赚钱，而且还能拿钱去赚钱，这都很好。 筹资活动现金流出有两种可能，要么在还债，要么是回报分红，如果是分红，这个企业还不错。应该是价值型的公司。 企业疯牛型，属于经营流入，投资流出，融资流入。企业能够赚到钱，然后赚到的钱，都愿意拿出去扩张，说明很看好未来的发展。 另外还能借到钱，说明外面的人也看好这个企业的项目。这时候两种可能，一个是高增长持续，但也很容易出现资金断流。太多的企业都是死在了冲锋的路上，所以投资这块要谨慎看待，特别是那种打出多元化国际化口号的。务必小心。 最佳类型：经营流入，投资流出，融资也流出，企业能赚钱，然后也能投资，还能够偿债或者回报股东，如果可以持续的话，这应该是最佳的类型了。 他经营的钱能够覆盖对外投资和分红，这就属于那种现金奶牛，比如茅台和格力。增长不见得很快，但每年都会有钱拿。巴菲特最喜欢的企业类型。这时候你要在算算，经营现金减去投资再减去融资，是不是仍然为正，如果仍然为正，这个奶牛的成色非常足。如果减完了得到了负数，那么很可能很快就变成了上面那种企业。 骗吃骗喝型，经营现金流为负值，投资现金流净额为正的，筹资为正的是骗吃骗喝型 筹资活动现金流出有两种可能，要么在还债，要么是回报分红，如果是分红，这个企业还不错。应该是价值型的公司。 混吃等死型，经营现金流为负值，筹资为负的就是是混吃等死型 赌徒型，经营现金流为负值，投资活动为负的就更糟糕，能融到钱的属于赌徒型 大出血型，经营现金流为负值，融不到钱还要还债的属于大出血型 优秀的企业关注以下5组数据就够了。第一就是经营活动现金流量净额大于净利润，并且大于零。第二销售商品提供劳动收入现金大于营业收入，第三投资活动的现金流净流量小于零，且主要是投入的新项目。第四现金及现金等价物净增加额大于零，或者排除分红因素该科目仍然大于零，第五期末现金及现金等价物余额大于有息负债。 三大报表总结要结合历史报表和同行业报表来看 杜邦分析体系安全性分析指标有一个指标你总是要记住的，那就是现金及现金等价物，一定要大于有息负债。 流动比率和速动比率 教科书一般认为，流动比率2，速动比率在1是一个比较理想的状态 资产负债率 净资产负债率 盈利能力的分析营业利润率等于营业收入减去营业成本再减去三费，然后用这个结果再除以营业收入，用以反应收入到底多少能转化成利润。 净资产收益率(ROE)： 最好15%以上。 总资产收益率：净利润除以平均总资产，注意这是总资产，跟净资产就差一个字。 这里面还能体现杠杆的因素，比如只有1成的钱，借来了9成的钱，然后赚了1成，他就收益100%了，但其实他的生意利润也就10%，所以如果两家公司净资产收益率一样，而总资产收益率更强的那家，显然盈利能力更强，承担的风险更小。 成长性分析 营业收入增长率：本期收入减去上期营收，除以上期营收，反应业务能力扩大的速度 营业利润增长率：本期利润减去上期利润除以上期利润 总资产增长率：本期总资产减去上期总资产除以上期总资产 净资产增长率：本期净资产减去上期净资产除以上期净资产 营业增长率和利润增长率是必须要看的指标，我们常用的PEG估值方法，那个G就是增长率的情况，通常保守的价值型企业用利润增长率来算，成长型企业则用营业增长率来计算，增长率20%，顶多给20倍市盈率的估值。成长率为10%，最好买入的市盈率别超过10倍。至于增长率100%，理论上可以给100倍市盈率的估值，但问题是这100%的增长能维持多久？ PEG，是用公司的市盈率（PE）除以公司未来3或5年的每股收益复合增长率。 衡量公司管理水平应收账款周转率，存货周转率和固定资产周转率，说白了就是营运能力，周转率就是周转的次数，如果固定周期中周转的次数越多，说明公司越高效，毕竟存货周期短的话，计提减值就少。 杜邦分析体系净资产收益率=净利润/销售收入 X 销售收入/平均总资产 X 平均总资产/净资产。 分别是净利润除以销售收入，这其实就是产品净利润率，销售收入除以平均总资产，这是总资产周转率，而平均总资产除以净资产，就是杠杆系数。这确实是高人研究出来的，因为这三个部分，刚好表明了企业的有且只有的三种发展模式，也就是茅台模式，沃尔玛模式和银行模式，所谓茅台模式，就是第一个净利润比上销售收入，是产品净利率极高的发展模式。属于现金奶牛，属于超级大白马，属于超高产品附加值。 而沃尔玛模式，就是总资产周转率高的企业，也就是第二个公式销售收入比上平均总资产，说明这个企业的利润并不高，周转效率很高，靠的是效率赚大钱。 第三种是银行模式，利润不高，也没什么周转率，但人家靠的是高杠杆，把本来很低的利润给放大了。所以通过杜邦公式你一眼就能看出这是一个怎样的企业，他的净资产收益率到底高在哪了。所以这个公式是你必须牢记的，4个指标也是你要率先从报表上找出来的。重复一遍，四个指标分别是净利润，销售收入，平均总资产和净资产，杜邦公司的净资产收益率公式是，净资产收益率=净利润/销售收入X销售收入/平均总资产X平均总资产/净资产。 常见的操纵财报的手法1、操纵利润 利润等于收入减去费用，所以只有2个手法，要么虚构收入，要么减少费用。其中虚构收入是比较常见的，比如某上市公司，成立了35家秘密控制的空壳公司，拿出其中一家当低价买农村山地，然后以100倍的价格卖给上市公司，这样上市公司就虚增资产1亿多，而那家卖地的公司，就从上市公司掏出来上亿的现金，接着以类似的手法分转给其他的公司，然后再由那些公司，从这个上市公司采购产品，虚增营业收入。还有的公司，把产品单价提高，然后以高价格卖给关联公司，最后再通过在建工程款，原料采购等名义，把钱返还出去，这样他就有很高的收入。甚至还有的不要脸的公司，会把政策的补助，给化妆成合同采购，假装成销售收入流入公司。 另外，我们之前也讲过，还有很多公司借助一次性的卖资产而来的钱，扩大收入。还有通过收购一个公司，多付出一些钱，然后被收购对象再把钱返回来购买产品，虚增收入。还有些公司会将亏损打包进一个公司和业务部门，高价出售，然后掩盖亏损。然后上市公司会通过，借款，担保，项目合作，并购或者咨询费用再把这些钱补偿给接盘公司。 最无耻的还有互换贸易，就是跟一个公司约定好，我高价采购你的产品，你也高价采购我的产品。这样双方的营业收入就都提升了。 2、互换贸易 就是跟一个公司约定好，我高价采购你的产品，你也高价采购我的产品。这样双方的营业收入就都提升了。 3、操纵费用 经常会把本期费用推迟到未来，来掩盖本期的业绩问题。还有虚增费用，然后给业绩洗澡，把几年的费用一年爆出来，大比例的注销资产或者存货，大额计提减值准备，集中亏一次，总比持续的小亏要强的多。有个上市公司，少记原材料成本1个亿，结果虚增利润7000万。这是比较常见的手法，然后还有的公司不计入对外拆借资金的利息，减少财务费用的。这样的事很多。 4、苦肉计 有一个苦肉计大家要注意，就是公司有时候会恍然大悟，然后承认错误，说我之前漏算了很多费用，现在把这些费用放回去。这就好比，我先打你一嘴巴，然后说对不起一样。您的业绩都披露完好久了，股价也涨了，现在要把之前的业绩改回来，道歉有用吗？ 5、操纵现金流 这是为了专业投资者准备的坑，知道你们老盯着现金流，所以他们就必须要在现金流上面下手脚。例如把投资或者筹资的 现金流入，变成经营活动流入，这个手法有，投资收购一家公司，然后跟对方商量好，你们让客户慢点付款，多保留些应付款，等于我投资下去，收购了很多的应收款，这就把钱变成了经营现金流入。而且有的时候收购未必要出很多钱。所以投资活动现金也不用怎么流出，就能换回经营现金流入。还有公司会出售子公司，把出售款分成首付和未来收入分账两部分，这样收入分账部分，就变成了这家公司的未来经营现金流入。这就把投资现金流入变成了经营现金流入。有的公司还以存货抵押借款，然后签合同的时候说，咱们改一种说法，叫做我先卖给你，然后约定未来再回购从而创造本期经营活动现金流入。还有的上市公司替客户担保，然后让客户大比例购买他的产品，其实也是投资现金流出，而经营现金流入。当然有流入就有流出，上市公司会尽量避免经营现金流出，能放到投资流出的绝不放到经营现金流流出。 6、造假 第一重点关注高毛利率的业务，这块非常多的用来造假，因为空间大，不容易被发现。如果某个产品毛利率显著高于同行，或者大幅波动，那么就要小心了，除非是特别知名的产品，否则很可能就是个坑。 第二是其他业务收入，一般也是玩文字游戏的地方。而报表是可以不披露其他业务收入明细的，所以你很难进一步知道这个东西到底是什么玩意。这就为造假提供可能。 第三是销售费用和管理费用，这是藏污纳垢的重灾区，一定要跟同行对比。 第四是营业外支出和一次性费用，二话不说先把一次费用排除掉。带着其他字眼的东西，最好都给他加回去。对于有经验的投资者来说，其他两个字，就跟标红差不多。那意思就是这里该有故事了。 第五是资产减值损失，这里是业绩洗澡的地方，很多东西会一次性减值注销。 第六是应收账款，这个指标大幅增加，或者显著高于同行，说明打了很多的白条。 第七是其他应收款，这就更可疑了，好公司这块绝对很小的。 第八预付账款，这个大幅增加很可能是在作假，通过预付款流出资金，然后通过营收再流回来，虚增收入。 注意1、小心公司的计划、预计、规划，都有可能是骗人的2、而利润表和现金流量表的作用，只是为了印证资产负债表上的内容。送红股和转增股的区别 用未分配利润或者盈余公积金送股叫做派送红股 如果用资本公积金送股叫做转增多少股。转增股票是不用交税的。]]></content>
      <categories>
        <category>财经</category>
      </categories>
      <tags>
        <tag>金融</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python高级]]></title>
    <url>%2F2018%2F03%2F16%2Fpython%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[一、条件和循环1234567891011121314151617181920212223242526272829303132## if条件判断if condition_1: statement_block_1elif condition_2: statement_block_2else: statement_block_3## while循环和while else语句 count = 0while count &lt; 5: print (count, " 小于 5") count = count + 1else: print (count, " 大于或等于 5") ## for循环for &lt;variable&gt; in &lt;sequence&gt;: &lt;statements&gt;else: &lt;statements&gt; ## range()函数 它会生成数列；range(4) 表述从0到4的税数列for i in range(5,9) : print(i)## break和continue语句 与JAVA相同## pass 语句# Python pass是空语句，是为了保持程序结构的完整性。while True: pass # 等待键盘中断 (Ctrl+C) 二、迭代器与生成器迭代器有两个基本的方法：iter() 和 next()。12345678910list=[1,2,3,4]it = iter(list) # 创建迭代器对象for x in it: print (x, end=" ") while True: try: print (next(it)) except StopIteration: sys.exit() 使用了 yield 的函数被称为生成器（generator），作用是函数执行时遇到这个关键字的时候就会停止执行，知道调用了next之后才能继续执行1234567891011121314151617import sys def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a + b counter += 1f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print (next(f), end=" ") except StopIteration: sys.exit() 三、函数123def 函数名（参数列表）: 函数体 rturn ; 1. 参数 必需参数 关键字参数 调用时：printinfo( age=50, name=&quot;light&quot; ); 默认参数 定义时：def printinfo( name, age = 35 ): 不定长参数 定义时：def printinfo( name, *str ):类似与java的... 字典 定义时：def printinfo( name, **args): 2. 匿名函数python 使用 lambda 来创建匿名函数。 12sum = lambda arg1, arg2: arg1 + arg2;print ("相加后的值为 : ", sum( 10, 20 )) 3. global 和 nonlocal关键字global局部变量修改全局变量的值1234567num = 1def fun1(): global num # 需要使用 global 关键字声明 num = 123 print(num) fun1()print(num) nonlocal关键字12345678def fun(): j = 0 def fun1(): nonlocal j j = 5 print(j) fun1() print(j) 四、数据结构1. python实现堆栈12345678910# 堆栈：先进后出，后进先出stack = [3, 4, 5]stack.append(6) //压栈stack.pop() //出栈# 队列：先进先出from collections import dequequeue = deque([1,2,3,4,56])queue.append(6) # 添加到末尾e = queue.popleft() # 取出队列中第一个参数 2. 列表推导式和遍历12345678910111213141516171819202122232425262728293031323334353637vec = [2, 4, 6]result = [3*x for x in vec]## return [6, 12, 18][[x, x**2] for x in vec]## return [[2, 4], [4, 16], [6, 36]]freshfruit = [' banana', ' loganberry ', 'passion fruit '][weapon.strip() for weapon in freshfruit]## return ['banana', 'loganberry', 'passion fruit'][3*x for x in vec if x &gt; 3]## return [12, 18]vec1 = [2, 4, 6]vec2 = [4, 3, -9][x*y for x in vec1 for y in vec2]## return [8, 6, -18, 16, 12, -36, 24, 18, -54][vec1[i]*vec2[i] for i in range(len(vec1))]## return [8, 12, -54][str(round(355/113, i)) for i in range(1, 6)]## return ['3.1', '3.14', '3.142', '3.1416', '3.14159']matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]][[row[i] for row in matrix] for i in range(4)]## return [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]## 列表转化为字典dict(sape=4139, guido=4127, jack=4098)## 遍历字典for k, v in knights.items(): print(k,v)## 遍历列表，带下标for i, v in enumerate(['tic', 'tac', 'toe']): print(i, v)reversed(list) # 倒叙 五、模块1234567891011from modname import * # 把一个模块的所有内容全都导入到当前的命名空间，但是由单一下划线（_）开头的名字不在此例。from fibo import fib, fib2``` ### `__name__`属性```pythonif __name__ == &apos;__main__&apos;: print(&apos;程序自身在运行&apos;)else: print(&apos;我来自另一模块&apos;) 每个模块都有一个__name__属性，当其值是&#39;__main__&#39;时，表明该模块自身在运行，否则是被引入。 12import fibov = dir(fibo) # return ['__name__', 'fib', 'fib2'] 六、文件12345678910f = open(filename, mode) # 打开文件f.read() # 读文件f.readline() # 读一行f.readlines() # 读所有的行f.write('......') # 写文件f.close() # 释放资源f.writelines(sequence) # 写入多行############os 模块############os 模块提供了非常丰富的方法用来处理文件和目录 六、错误和异常12345678910try: f = 1/0except: print("我是错误") raise ## 往外抛异常else: print("我没有报错")finally: print("我最终会执行") 预定义的清理行为关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法123with open("myfile.txt") as f: for line in f: print(line, end="") 自定义异常1234567class MyError(Exception): a = 'sf'try: i = 1/2 raise MyError('a', '')except MyError : print(MyError.a) 七、面向对象1234567891011121314151617181920212223242526272829303132333435363738class A: name = '父类的普通参数' __name = '父类的私有参数' # 定义私有属性,私有属性在类外部无法直接进行访问 # 定义构造方法 def __init__(self, name): self.name = name self.name2 = '这样也可以定义参数' ### 类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。 def fun(self,name): self.__name = name print('我是父类普通方法')class B: B_name = '我是B类的名称' def __foo(self): # 私有方法 print('这是B类的私有方法')class C(B,A): ## 多继承 def __init__(self,name): A.__init__(self,name) print(A.name) ## 也可以覆写父类的方法 def fun(self,name): self.name = name print('我要重写父类的方法') def fun(self): print('python不支持重载，但是这个方法生效，调用上面的方法将报错')a = A('init_name')print(a.name)print(a.name2)c = C(name='asd')print(A.name)super(C,c).fun('') # 调用父类的方法 八、Python3 标准库概览操作系统接口os模块提供了不少与操作系统相关联的函数。12345678import osos.getcwd() # 返回当前的工作目录os.chdir('/server/accesslogs') # 修改当前的工作目录os.system('mkdir today') # 执行系统命令 mkdir import shutilshutil.copyfile('data.db', 'archive.db')shutil.move('/build/executables', 'installdir') 建议使用 “import os” 风格而非 “from os import *”。这样可以保证随操作系统不同而有所变化的 os.open() 不会覆盖内置函数 open()。 文件通配符123import globglob.glob('*.py')# return ['primes.py', 'random.py', 'quote.py'] 命令行参数12import sysprint(sys.argv) # 打印运行脚本传进来的参数 字符串正则匹配1234import rere.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')'tea for too'.replace('too', 'two') # 字符串替换 数字：import math随机数：import random访问 互联网1234567891011121314151617## URL访问from urllib.request import urlopenfor line in urlopen('http://www.baidu.com'): line = line.decode('utf-8') print(line) ## 发送邮件import smtplibserver = smtplib.SMTP('localhost')server.sendmail('soothsayer@example.org', 'jcaesar@example.org',"""To: jcaesar@example.orgFrom: soothsayer@example.orgBeware the Ides of March.""")server.quit() 日期和时间123456from datetime import datenow = date.today()print(now) # 输出 yyyy-MM-ddnowdate = now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")print(nowdate) # 格式化输出 数据压缩12345678import zlibs = b'witch which has which witches wrist watch'# 字符串前面添加u代表是unicode字符串；r表示非转义的原始字符串 ；b是bytes的意思print(len(s))t = zlib.compress(s) # 压缩print(len(t))tt = zlib.decompress(t) # 解压print(tt) 性能度量12345from timeit import TimerTimer('t=a; a=b; b=t', 'a=1; b=2').timeit()## return 0.57535828626024577Timer('a,b = b,a', 'a=1; b=2').timeit()## return 0.54962537085770791 测试模块1# 待补充......]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基本语法]]></title>
    <url>%2F2018%2F03%2F13%2Fpython3%2F</url>
    <content type="text"><![CDATA[基础语法1. 注释 单行注释：#号 多行注释：&#39;&#39;&#39;和&quot;&quot;&quot; 2. 行与缩进 使用缩进来表示代码块，不需要使用大括号{}。同一个代码块的语句必须包含相同的缩进空格数 3. 多行语句1234567# 使用反斜杠(\)来实现多行语句total = item_one + \ item_two + \ item_three# 在 [], &#123;&#125;, 或 () 中的多行语句，不需要使用反斜杠(\) total = ['item_one', 'item_two', 'item_three', 'item_four', 'item_five'] 4. 数字(Number)类型python中数字有四种类型：整数、长整数、浮点数和复数。 int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 bool (布尔),如 true。 float (浮点数), 如 1.23、3E-2 complex (复数), 如 1 + 2j、 1.1 + 2.2j 5. 字符串(String)12345678910111213141516171819202122232425# python中单引号和双引号使用完全相同。word = '字符串'sentence = "这是一个句子。"# 使用三引号('''或""")可以指定一个多行字符串。paragraph = """这是一个段落，可以由多行组成"""str='Runoob'print(str) # 输出字符串print(str[0:-1]) # 输出第一个到倒数第二个的所有字符print(str[0]) # 输出字符串第一个字符print(str[2:5]) # 输出从第三个开始到第五个的字符print(str[2:]) # 输出从第三个开始的后的所有字符print(str * 2) # 输出字符串两次print(str + '你好') # 连接字符串print('------------------------------')print('hello\nrunoob') # 使用反斜杠(\)+n转义特殊字符print(r'hello\nrunoob') # 在字符串前面添加一个 r，表示原始字符串，不会发生转义a = 'd' in 'bca'print(a) # 返回False 6. 等待用户输入input(&quot;\n\n按下 enter 键后退出。&quot;)7. Print 输出123456y="b"# 换行输出print( y )print('---------')# 不换行输出print( y, end=" " ) 8. import 与 from…import1234将整个模块(somemodule)导入，格式为： import somemodule从某个模块中导入某个函数,格式为： from somemodule import somefunction从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc将某个模块中的全部函数导入，格式为： from somemodule import * 基本数据类型1. 多个变量赋值 a,b,c = 1 ,3, &#39;sdf&#39; 2. 标准数据类型 Number（数字） String（字符串） List（列表） Tuple（元组） Sets（集合） Dictionary（字典） type() 函数和isinstance()可以用来查询变量所指的对象类型 1234a = 1# 返回 &lt;class &apos;int&apos;&gt;isinstance(a, int)# 返回 True 两者区别： type()不会认为子类是一种父类类型。 isinstance()会认为子类是一种父类类型。 注意：在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。 3. del语句del语句删除单个或多个对象del a4. 次方计算用**表示2 ** 3返回85. List（列表）list = [ &#39;abcd&#39;, 786 , 2.23, &#39;lightquant&#39;, 70.2 ] 与Python字符串不一样的是，列表中的元素是可以改变的。list[0] = a 6. Tuple（元组）tuple = ( &#39;abcd&#39;, 786 , 2.23, &#39;lightquant&#39;, 70.2 ) 元组（tuple）与列表类似，不同之处在于元组的元素不能修改。 7. Set（集合）集合（set）是一个无序不重复元素的序列。基本功能是进行成员关系测试和删除重复元素。可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 1234567891011student = &#123;'Tom', 'Jim', 'Mary', 'Tom', 'Jack', 'Rose'&#125;student2 = set('asd')# set可以进行集合运算a = set('abracadabra')b = set('alacazam')print(a)print(a - b) # a和b的差集print(a | b) # a和b的并集print(a &amp; b) # a和b的交集print(a ^ b) # a和b中不同时存在的元素 8. Dictionary（字典）类似与java的map keys()输出所有的key values()输入所有的值 1234567891011dict = &#123;&#125;dict['one'] = "1 - 灯塔量化"dict[2] = "2 - lightquant" tinydict = &#123;'name': 'lightquant','code':1, 'site': 'www.runoob.com'&#125;print (dict['one']) # 输出键为 'one' 的值print (dict[2]) # 输出键为 2 的值print (tinydict) # 输出完整的字典print (tinydict.keys()) # 输出所有键print (tinydict.values()) # 输出所有值 9. Python数据类型转换 123456789101112131415161718192021222324252627282930313233343536373839404142# 1、int(n,base)函数a = int('110',2) # 二进制转换10进制，必须是字符串类型b = int(3.6) # 向下取整# 2、float() 可是是字符串，也可以是数字，转换为浮点类型# 3、complex() 函数 返回复数表达式（复数是什么？有什么用呢？）complex(1, 2) # return (1 + 2j)complex(1) # return (1 + 0j)complex("1+2j") # return (1 + 2j)# 4、str() 函数 将对象转化为适于人阅读的形式。dict = &#123;'light': 'lightquant.com', 'google': 'google.com'&#125;# return "&#123;'light': 'lightquant.com', 'google': 'google.com'&#125;"# 5、repr() 函数 与str() 类似# 6、eval() 函数x = 2 ; eval('x * 2') # return 4# 7、tuple()函数 将列表转换为元组。。# 8、list()方法 将元组转换为列表。# 9、dict() 函数 用于创建一个字典。# 10、frozenset() 函数 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。# 11、chr() 函数 返回值是当前整数对应的ascii字符。print chr(0x30) # return 0print chr(48) # return 0# 12、ord() 函数 与chr()相反print chr(0) # return 0# 13、hex() 函数 返回16进制# 14、oct() 函数 返回8进制# 15、除法计算10 // 3 #等于310 / 3 #3.33333333333333 10. 数字格式化123456789101112 print("&#123;:.2f&#125;".format(3.1415926)); # 保留两位小数 # &#123;:+.2f&#125; 带前缀'+'号 # &#123;:.0f&#125; 不带小数 # &#123;:0&gt;2d&#125; 不足两位 ，前面补0 # &#123;:x&lt;4d&#125; 不足4位，后面补x # &#123;:,&#125; 逗号分隔数字，如：1,000,000 # &#123;:.2%&#125; 保留两位小数，再加'%'后缀'&#123;:b&#125;'.format(11) # 二进制'&#123;:d&#125;'.format(11) # 十进制'&#123;:o&#125;'.format(11) # 八进制'&#123;:x&#125;'.format(11) # 十六进制 11. 字符串内建函数123str.capitalize() # 首字符会转换成大写，其余字符会转换成小写。str.center(10, '*') # 返回10位长度的字符串，前后用'*'补充str.count('a',0,10) # 返回字符'a'在str出现的次数 集合1、列表12345678910111213141516171819202122232425list = ['Google', 'light', 1997, 2000]list[2] = 2001 # 可以更新值del list[2] # 删除第三个参数len([1, 2, 3]) # 返回长度[1, 2, 3] + [4, 5, 6] # 组合['Hi!'] * 4 # 重复3 in [1, 2, 3] # 判断该列表中是否存在某个数for x in [1, 2, 3]: # 遍历 print(x, end=" ") #######函数########len(list) # 列表长度max(list);min(list) # 最大值 最小值list(seq) # 将元组转换为列表list.append(obj) # 在列表末尾添加新的对象list.count(obj) # 统计某个元素在列表中出现的次数list.extend(seq) # 相当于java的addAll(list);list.index(obj) # 找出字符下标 ，没有找到会报错list.insert(index, obj) # 插入数据list.pop(i) # 默认删除最后一个，返回删除的值list.remove(obj) # 删除匹配的第一个值，没有匹配会报错list.sort(l) # 排序list.clear() # 清空列表list.copy() # 复制 2、元组12345678910111213141516171819tup1 = ('Google', 'light', 1997, 2000);tup1 = (); # 创建空元组## 1. 元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用：tup1 = (50) ; tup2 = (50,) # tup1是整数类型，tup2才是元祖 ## 2. 元组中的元素值是不允许修改的，但我们可以对元组进行连接组合tup1 = (12, 34.56);tup2 = ('abc', 'xyz')# 创建一个新的元组tup3 = tup1 + tup2;print (tup3)## 3. 元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组del tup;## 4. 将列表转换为元组。tuple(list1) 3、字典1234567891011121314151617181920d = &#123;key1 : value1, key2 : value2 &#125;## 键必须是唯一的，但值则不必。del dict['Name'] # 删除键 'Name'dict.clear() # 清空字典del dict # 删除字典## 不允许同一个键出现两次。创建时如果同一个键被赋值两次，会以后面的为准## 键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行b = a.fromkeys(seq) # 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值dict.get(key, 'default') #没有就返回'default'，或者Nonedict.items() # 遍历返回dict.setdefault(key, 'default') # 如果 key 在 字典中，返回对应的值。如果不在字典中，则插入 key 及设置的默认值 default，并返回 default ，default 默认值为 None。dict.update(dict2) # dict2 -- 添加到指定字典dict里的字典。pop(key[,default]) # 返回值为被删除的值。key值必须给出。 否则，返回default值。popitem() # 随机返回并删除字典中的一对键和值(一般删除末尾对)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云nginx配置https]]></title>
    <url>%2F2018%2F03%2F01%2Fnginx-https%2F</url>
    <content type="text"><![CDATA[一、阿里云申请免费证书这里有个坑，找这个免费证书要先选择保护类型为“一个域名”，然后选择品牌为“Symantec”，证书类型中才会出现免费的选项。 二、下载证书申请要过一段时间，才能在我的列表中看到，然后补全信息，过几分钟审核通过了，就可以下载了。下载好了，上传到服务器解压，有两个文件：12/usr/local/nginx/cert/214524977110083.pem/usr/local/nginx/cert/214524977110083.key 三、配置 NGINX 的 HTTPS1234567891011121314151617181920server &#123; listen 443; server_name www.lightquant.com; ssl on; root html; index index.html; ssl_certificate /usr/local/nginx/cert/214524977110083.pem ssl_certificate_key /usr/local/nginx/cert/214524977110083.pem ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL; ssl_prefer_server_ciphers on;&#125;server &#123; listen 80; server_name lightquant.com; return 301 https://$server_name$request_uri;&#125; 完成！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[activeMQ]]></title>
    <url>%2F2018%2F02%2F12%2FactiveMQ%2F</url>
    <content type="text"><![CDATA[安装部署：wget http：//archive.apache.org/dist/activemq/apache-activemq/5.9.0/apache-activemq-5.9.0-bin.tar.gz解压运行：activemq start（1）普通启动./activemq start（2）启动并指定日志文件./activemq start&gt; tmp / smlog（3）后台启动方式nohup ./activemq start&gt; / tmp / smlog管理后台为：http://ip:8161/admin/连接默认端口61616 安全配置jetty.xml中&lt;property name=&quot;authenticate&quot; value=&quot;true&quot; /&gt; //开启认证&lt;property name=&quot;port&quot; value=&quot;8191&quot; /&gt; //修改端口jetty-realm.properties中修改密码 username: password [,rolename …]用户名 : 密码 ,角色名如：admin: admin, admin 依赖123&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt; &lt;/dependency&gt; springMVC12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-core&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; 配置123456789101112131415#==================activemq Config Start==================spring.activemq.broker-url=tcp://127.0.0.1:61616?jms.prefetchPolicy.all=2spring.activemq.in-memory=truespring.activemq.password=adminspring.activemq.user=admin#如果为True，则是Topic；如果是false或者默认，则是queuespring.jms.pub-sub-domain=false spring.activemq.packages.trust-all=falsespring.activemq.packages.trusted=spring.activemq.pool.configuration.*=spring.activemq.pool.enabled=falsespring.activemq.pool.expiry-timeout=0spring.activemq.pool.idle-timeout=30000spring.activemq.pool.max-connections=1#==================activemq Config End ================== springMVC配置1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;context:annotation-config /&gt; &lt;amq:connectionFactory id="amqConnectionFactory" brokerURL="tcp://localhost:61616" userName="admin" password="admin" /&gt; &lt;!-- 配置JMS连接工长 --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory"&gt; &lt;constructor-arg ref="amqConnectionFactory" /&gt; &lt;property name="sessionCacheSize" value="100" /&gt; &lt;/bean&gt; &lt;!--spring jms 为我们提供的连接池--&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory" /&gt; &lt;/bean&gt; &lt;!--一个队列的目的地，点对点的--&gt; &lt;bean id="queueDestionation" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="queue" /&gt; &lt;/bean&gt; &lt;!--一个主题，发布订阅--&gt; &lt;bean id="topicDestionation" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="topic" /&gt; &lt;/bean&gt; &lt;!-- 配置JMS模板（Queue），Spring提供的JMS工具类，它发送、接收消息。 --&gt; &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="defaultDestination" ref="demoQueueDestination" /&gt; &lt;property name="receiveTimeout" value="10000" /&gt; &lt;!-- true是topic，false是queue，默认是false，此处显示写出false --&gt; &lt;property name="pubSubDomain" value="false" /&gt; &lt;/bean&gt; &lt;bean class="com.imooc.jms.producer.ProducerServiceImpl"&gt;&lt;/bean&gt; &lt;!--加入监听器 --&gt; &lt;bean id="queueMessageListener" class="com.qqw.active.QueueMessageListener" /&gt; &lt;!-- 显示注入消息监听容器（Queue），配置连接工厂，监听的目标是demoQueueDestination，监听器是上面定义的监听器 --&gt; &lt;bean id="queueListenerContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="queueDestionation" /&gt; &lt;property name="messageListener" ref="queueMessageListener" /&gt; &lt;/bean&gt; 监听1234 @JmsListener(destination="SPEED_DOWN")public void receive(String msg) &#123; System.out.println(msg);&#125; 12345678910111213141516171819202122public class QueueMessageListener implements MessageListener &#123; //当收到消息后，自动调用该方法 @Override public void onMessage(Message message) &#123; TextMessage tm = (TextMessage) message; try &#123; System.out.println("QueueMessageListener监听到了文本消息：\t" + tm.getText()); Person fromJson = JSON.parseObject(tm.getText(), Person.class); System.out.println(fromJson.toString()); //do something ... &#125; catch (JMSException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 发送123Destination destination = new ActiveMQQueue("SPEED_DOWN");// 这里定义了Queue的keyjsmTemplate.convertAndSend(destination, string+price);//首先要注入jmsTemplate springMVC12345678910111213141516171819实现类public class ProducerServiceImpl implements ProducerService &#123; @Autowired JmsTemplate jmsTemplate; @Resource(name = "queueDestionation") Destination destination; @Override public void sendMessage(final String message) &#123; jmsTemplate.send(destination, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; TextMessage textMessage = session.createTextMessage(message); System.out.println("发送消息："+textMessage.getText()); return textMessage; &#125; &#125;); &#125;&#125; 其他队列模式：生产者先发送消息，消费者后消费消息，消息被平均消费掉主题模式：消费者先订阅消息，生产者产出的消息才可以被消费者接收到，而且是全部接收到的]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>activeMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBoot]]></title>
    <url>%2F2018%2F02%2F11%2FspringBoot%2F</url>
    <content type="text"><![CDATA[thymeleaf依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 配置:12345678910111213141516171819202122232425# THYMELEAF (ThymeleafAutoConfiguration)#开启模板缓存（默认值：true）spring.thymeleaf.cache=true #Check that the template exists before rendering it.spring.thymeleaf.check-template=true #检查模板位置是否正确（默认值:true）spring.thymeleaf.check-template-location=true#Content-Type的值（默认值：text/html）spring.thymeleaf.content-type=text/html#开启MVC Thymeleaf视图解析（默认值：true）spring.thymeleaf.enabled=true#模板编码spring.thymeleaf.encoding=UTF-8#要被排除在解析之外的视图名称列表，用逗号分隔spring.thymeleaf.excluded-view-names=#要运用于模板之上的模板模式。另见StandardTemplate-ModeHandlers(默认值：HTML5)spring.thymeleaf.mode=HTML5#在构建URL时添加到视图名称前的前缀（默认值：classpath:/templates/）spring.thymeleaf.prefix=classpath:/templates/#在构建URL时添加到视图名称后的后缀（默认值：.html）spring.thymeleaf.suffix=.html#Thymeleaf模板解析器在解析器链中的顺序。默认情况下，它排第一位。顺序从1开始，只有在定义了额外的TemplateResolver Bean时才需要设置这个属性。spring.thymeleaf.template-resolver-order=#可解析的视图名称列表，用逗号分隔spring.thymeleaf.view-names= 常见使用：1、在html页面中引入thymeleaf命名空间，即&lt;html xmlns:th=http://www.thymeleaf.org&gt;&lt;/html&gt;，此时在html模板文件中动态的属性使用th:命名空间修饰 2、引用静态资源文件，比如CSS和JS文件，语法格式为”@{}”，如@{/js/blog/blog.js}会引入/static目录下的/js/blog/blog.js文件 3、访问spring-mvc中model的属性，语法格式为”${}”，如${user.id}可以获取model里的user对象的id属性 4、循环12345678910&lt;tr th:each="collect,iterStat : $&#123;collects&#125;"&gt; &lt;th scope="row" th:text="$&#123;collect.id&#125;"&gt;1&lt;/th&gt; &lt;td &gt; &lt;img th:src="$&#123;collect.webLogo&#125;"/&gt; &lt;/td&gt; &lt;td th:text="$&#123;collect.url&#125;"&gt;Mark&lt;/td&gt; &lt;td th:text="$&#123;collect.title&#125;"&gt;Otto&lt;/td&gt; &lt;td th:text="$&#123;collect.description&#125;"&gt;@mdo&lt;/td&gt; &lt;td th:text="$&#123;terStat.index&#125;"&gt;index&lt;/td&gt;&lt;/tr&gt; iterStat称作状态变量，属性有：index:当前迭代对象的index（从0开始计算）count: 当前迭代对象的index(从1开始计算)size:被迭代对象的大小current:当前迭代变量even/odd:布尔值，当前循环是否是偶数/奇数（从0开始计算）first:布尔值，当前循环是否是第一个last:布尔值，当前循环是否是最后一个 5、判断，在html标签中，加入th:if=”表达式”可以根据条件显示html元素123&lt;span th:if="$&#123;not #lists.isEmpty(blog.publishTime)&#125;"&gt;&lt;span id="publishtime" th:text="$&#123;#dates.format(blog.publishTime, 'yyyy-MM-dd HH:mm:ss')&#125;"&gt;&lt;/span&gt; &lt;/span&gt; 以上代码表示若blog.publishTime时间不为空，则显示时间 6、时间的格式化，1$&#123;#dates.format(blog.publishTime,&apos;yyyy-MM-dd HH:mm:ss&apos;)&#125; 表示将时间格式化为”yyyy-MM-dd HH:mm:ss”格式化写法与Java格式化Date的写法是一致的。 7、字符串拼接，有两种形式比如拼接这样一个URL:/blog/delete/{blogId}第一种：th:href=&quot;&#39;/blog/delete/&#39; + ${blog.id }&quot;第二种：th:href=&quot;${&#39;/blog/delete/&#39; + blog.id }&quot; 8、布局定义代码片段：123&lt;footer th:fragment="copy"&gt; ? 2016&lt;/footer&gt; 在页面任何地方引入：12345&lt;body&gt; &lt;div th:include="footer :: copy"&gt;&lt;/div&gt; &lt;div th:replace="footer :: copy"&gt;&lt;/div&gt; &lt;div th:insert="footer :: copy"&gt;&lt;/div&gt; &lt;/body&gt; th:include 和 th:replace区别，include只是加载，replace是替换 也可以在引用模版的时候传参:1&lt;head th:include="layout :: htmlhead" th:with="title='Hello'"&gt;&lt;/head&gt; layout 是文件地址，如果有文件夹可以这样写 fileName/layout:htmlheadhtmlhead 是指定义的代码片段 如 th:fragment=”copy” 下面是一个常用的后台页面布局，将整个页面分为头部，尾部、菜单栏、隐藏栏，点击菜单只改变content区域的页面123456789&lt;body class="layout-fixed"&gt; &lt;div th:fragment="navbar" class="wrapper" role="navigation"&gt; &lt;div th:replace="fragments/header :: header"&gt;Header&lt;/div&gt; &lt;div th:replace="fragments/left :: left"&gt;left&lt;/div&gt; &lt;div th:replace="fragments/sidebar :: sidebar"&gt;sidebar&lt;/div&gt; &lt;div layout:fragment="content" id="content" &gt;&lt;/div&gt; &lt;div th:replace="fragments/footer :: footer"&gt;footer&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 任何页面想使用这样的布局值只需要替换中见的 content模块即可1234&lt;html xmlns:th="http://www.thymeleaf.org" layout:decorator="layout"&gt; &lt;body&gt; &lt;div layout:fragment="content"&gt;我是内容&lt;/div&gt; &lt;/body&gt; 9、点击事件：th:onclick=&quot;&#39;javascript:toxueqiu(\&#39;&#39;+${todayBuy.code}+&#39;\&#39;)&#39;&quot;JS中使用1234&lt;script th:inline="javascript"&gt;var data = [[$&#123;data&#125;]]//var dd="&amp;&amp;"+"&lt;";&lt;/script&gt; 10、th:style根据属性值改变背景1&lt;div class="media-object resource-card-image" th:style="'background:url(' + @&#123;($&#123;collect.webLogo&#125;=='' ? 'img/favicon.png' : $&#123;collect.webLogo&#125;)&#125; + ')'" &gt;&lt;/div&gt; 11、内嵌变量为了模板更加易用，Thymeleaf还提供了一系列Utility对象（内置于Context中），可以通过#直接访问： dates ： java.util.Date的功能方法类。calendars : 类似#dates，面向java.util.Calendarnumbers : 格式化数字的功能方法类strings : 字符串对象的功能类，contains,startWiths,prepending/appending等等。objects: 对objects的功能类操作。bools: 对布尔值求值的功能方法。arrays：对数组的功能类方法。lists: 对lists功能类方法setsmaps…举例：123456789101112131415161718$&#123;#dates.format(date, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.arrayFormat(datesArray, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.listFormat(datesList, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.setFormat(datesSet, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;$&#123;#dates.createNow()&#125;$&#123;#dates.createToday()&#125;$&#123;#strings.isEmpty(name)&#125;$&#123;#strings.arrayIsEmpty(nameArr)&#125;$&#123;#strings.listIsEmpty(nameList)&#125;$&#123;#strings.setIsEmpty(nameSet)&#125;$&#123;#strings.startsWith(name,&apos;Don&apos;)&#125; $&#123;#strings.endsWith(name,endingFragment)&#125; $&#123;#strings.length(str)&#125;$&#123;#strings.equals(str)&#125;$&#123;#strings.equalsIgnoreCase(str)&#125;$&#123;#strings.concat(str)&#125;$&#123;#strings.concatReplaceNulls(str)&#125;$&#123;#strings.randomAlphanumeric(count)&#125; AOP添加依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 代码实例1234567891011121314151617181920212223242526272829303132333435363738394041424344@Aspect@Componentpublic class HttpAspect &#123; private final static Logger logger = LoggerFactory.getLogger(HttpAspect.class); @Pointcut("execution(public * com.gjd.controller.GirlController.*(..))") //该类下所有方法 public void log()&#123; //定义一个全局的切入点 下面 可以直接 log()引用 &#125; @Before("log()") public void doBefore(JoinPoint joinPoint)&#123; //之前执行 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); //获取request对象 //url logger.info("url=&#123;&#125;", request.getRequestURL()); //method logger.info("method=&#123;&#125;", request.getMethod()); //ip logger.info("ip=&#123;&#125;", request.getRemoteAddr()); //类方法 logger.info("class_method=&#123;&#125;", joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName()); //通过JoinPoint对象获取类方法的对象 //参数 logger.info("args=&#123;&#125;", joinPoint.getArgs()); //通过JoinPoint对象获取传入的对象 &#125; @After("log()") public void doAfter() &#123; //之后执行 logger.info("222222222222"); &#125; @AfterReturning(returning = "object", pointcut = "log()") //获取调用方法返回的信息 public void doAfterReturning(Object object) &#123; logger.info("response=&#123;&#125;", object.toString()); &#125;&#125; 日志一、设置项目启动的日志等级1 在运行命令后加入–debug标志，如：$ java -jar springTest.jar –debug2 在application.properties中配置debug=true，该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。 二、日志输出路径默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性。 1 logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log 2 logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log 如果只配置 logging.file，会在项目的当前路径下生成一个 xxx.log 日志文件。 如果只配置 logging.path，在 /var/log文件夹生成一个日志文件为 spring.log 注：二者不能同时使用，如若同时使用，则只有logging.file生效 三、日志级别控制 1 logging.level.com.dudu=DEBUG：com.dudu包下所有class以DEBUG级别输出2 logging.level.root=WARN：root日志以WARN级别输出 四、自定义日志配置使用logback，建议使用官方名称logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy；spring boot可以为它添加一些spring boot特有的配置项。如果你即想完全掌控日志配置，但又不想用logback.xml作为Logback配置的名字，可以通过logging.config属性指定自定义的名字：logging.config=classpath:logging-config.xml 五、logback例子1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name="log.path" value="E:\\test\\logback.log" /&gt; &lt;!--输出到控制台--&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt;--&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;log.path&#125;&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;logback.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;!--表示只保留最近30天的日志--&gt; &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; &lt;!--设置为1GB的话，那么到了这个值，就会删除旧的日志。--&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level="info"&gt; &lt;appender-ref ref="console" /&gt; &lt;appender-ref ref="file" /&gt; &lt;/root&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name="com.dudu.controller"/&gt; &lt;!--logback.LogbackDemo：类的全路径 --&gt; &lt;logger name="com.dudu.controller.LearnController" level="WARN" additivity="false"&gt; &lt;appender-ref ref="console"/&gt; &lt;/logger&gt;&lt;/configuration&gt; 注：scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 2 表示对日志进行编码：%d{HH: mm:ss.SSS}——日志输出时间%thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用%-5level——日志级别，并且使用5个字符靠左对齐%logger{36}——日志输出者的名字%msg——日志消息%n——平台的换行符 六、开发，测试环境切换1 必须在该文件名logback-spring.xml文件写12345678&lt;!-- 测试环境+开发环境. 多个使用逗号隔开. --&gt;&lt;springProfile name="test,dev"&gt; &lt;logger name="com.dudu.controller" level="info" /&gt;&lt;/springProfile&gt;&lt;!-- 生产环境. --&gt;&lt;springProfile name="prod"&gt; &lt;logger name="com.dudu.controller" level="ERROR" /&gt;&lt;/springProfile&gt; 2 可以启动服务的时候指定 profile （如不指定使用默认），如指定prod 的方式为：java -jar xxx.jar –spring.profiles.active=prod 热部署pom文件添加12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 加载文件资源文件12@Configuration@PropertySource("classpath:test.properties") xml文件123@Configuration@ImportResource(locations=&#123;"classpath:application-bean.xml"&#125;)//locations= &#123;"file:d:/test/application-bean1.xml"&#125; 文件上传跟springMVC类似 配置从xml转向注解1234567891011@Bean public MultipartConfigElement multipartConfigElement() &#123; MultipartConfigFactory factory = new MultipartConfigFactory(); //// 设置文件大小限制 ,超了，页面会抛出异常信息，这时候就需要进行异常信息的处理了; factory.setMaxFileSize("128KB"); //KB,MB /// 设置总上传数据总大小 factory.setMaxRequestSize("256KB"); //Sets the directory location where files will be stored. //factory.setLocation("路径地址"); returnfactory.createMultipartConfig(); &#125;]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>springBoot</tag>
        <tag>categories</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2F2018%2F02%2F11%2Fnginx%2F</url>
    <content type="text"><![CDATA[一、nginx依赖的包 gcc安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：yum install gcc-c++ PCREPCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。yum install -y pcre pcre-devel注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。 zlibzlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。yum install -y zlib zlib-devel opensslOpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。yum install -y openssl openssl-devel或者wget https://www.openssl.org/source/openssl-1.1.0g.tar.gz//https://www.openssl.org/source 二、安装步骤 第一步：把nginx的源码上传到linux系统第二步：把压缩包解压缩。第三步：进行configure。第四步：make第五步：make install同时编译nginx+openssl:./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_gzip_static_module --with-http_ssl_module --with-openssl=/usr/local/openssl-1.1.0g make &amp;&amp; make install生成证书：openssl req -new -x509 -nodes -out server.crt -keyout server.key 三、启停服务关闭nginx：可以使用kill命令，但是不推荐使用。推荐使用：./nginx -s stop刷新配置：./nginx -s reload 四、配置文件配置文件主要由四部分组成：main(全区设置)，server(主机配置)，upstream(负载均衡服务器设置)，和location(URL匹配特定位置设置)。1）全局变量12345678910111213141516171819202122#Nginx的worker进程运行用户以及用户组#user nobody nobody;#Nginx开启的进程数worker_processes 1;#worker_processes auto;#以下参数指定了哪个cpu分配给哪个进程，一般来说不用特殊指定。如果一定要设的话，用0和1指定分配方式.#这样设就是给1-4个进程分配单独的核来运行，出现第5个进程是就是随机分配了。eg:#worker_processes 4 #4核CPU #worker_cpu_affinity 0001 0010 0100 1000#定义全局错误日志定义类型，[debug|info|notice|warn|crit]#error_log logs/error.log info;#指定进程ID存储文件位置#pid logs/nginx.pid;#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n的值保持一致。#vim /etc/security/limits.conf# * soft nproc 65535# * hard nproc 65535# * soft nofile 65535# * hard nofile 65535worker_rlimit_nofile 65535; 2）事件配置123456789events &#123; #use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。 use epoll; #每个进程可以处理的最大连接数，理论上每台nginx服务器的最大连接数为worker_processes*worker_connections。理论值：worker_rlimit_nofile/worker_processes #注意：最大客户数也由系统的可用socket连接数限制（~ 64K），所以设置不切实际的高没什么好处 worker_connections 65535; #worker工作方式：串行（一定程度降低负载，但服务器吞吐量大时，关闭使用并行方式） #multi_accept on; &#125; 3）http参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream;#日志相关定义 #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #定义日志的格式。后面定义要输出的内容。 #1.$remote_addr 与$http_x_forwarded_for 用以记录客户端的ip地址； #2.$remote_user ：用来记录客户端用户名称； #3.$time_local ：用来记录访问时间与时区； #4.$request ：用来记录请求的url与http协议； #5.$status ：用来记录请求状态； #6.$body_bytes_sent ：记录发送给客户端文件主体内容大小； #7.$http_referer ：用来记录从那个页面链接访问过来的； #8.$http_user_agent ：记录客户端浏览器的相关信息 #连接日志的路径，指定的日志格式放在最后。 #access_log logs/access.log main; #只记录更为严重的错误日志，减少IO压力 error_log logs/error.log crit; #关闭日志 #access_log off; #默认编码 #charset utf-8; #服务器名字的hash表大小 server_names_hash_bucket_size 128; #客户端请求单个文件的最大字节数 client_max_body_size 8m; #指定来自客户端请求头的hearerbuffer大小 client_header_buffer_size 32k; #指定客户端请求中较大的消息头的缓存最大数量和大小。 large_client_header_buffers 4 64k; #开启高效传输模式。 sendfile on; #防止网络阻塞 tcp_nopush on; tcp_nodelay on; #客户端连接超时时间，单位是秒 keepalive_timeout 60; #客户端请求头读取超时时间 client_header_timeout 10; #设置客户端请求主体读取超时时间 client_body_timeout 10; #响应客户端超时时间 send_timeout 10;#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k;#gzip模块设置 #开启gzip压缩输出 gzip on; #最小压缩文件大小 gzip_min_length 1k; #压缩缓冲区 gzip_buffers 4 16k; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_http_version 1.0; #压缩等级 1-9 等级越高，压缩效果越好，节约宽带，但CPU消耗大 gzip_comp_level 2; #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_types text/plain application/x-javascript text/css application/xml; #前端缓存服务器缓存经过压缩的页面 gzip_vary on; 4）虚拟主机基本设置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#虚拟主机定义 server &#123; #监听端口 listen 80; #访问域名 server_name localhost; #编码格式，若网页格式与此不同，将被自动转码 #charset koi8-r; #虚拟主机访问日志定义 #access_log logs/host.access.log main; #对URL进行匹配 location / &#123; #访问路径，可相对也可绝对路径 root html; #首页文件。以下按顺序匹配 index index.html index.htm; &#125;#错误信息返回页面 #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;#访问URL以.php结尾则自动转交给127.0.0.1 # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125;#php脚本请求全部转发给FastCGI处理 # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125;#禁止访问.ht页面 （需ngx_http_access_module模块） # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125;#HTTPS虚拟主机定义 # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; 5）Nignx状态监控123456789101112#Nginx运行状态，StubStatus模块获取Nginx自启动的工作状态（编译时要开启对应功能） #location /NginxStatus &#123; # #启用StubStatus的工作访问状态 # stub_status on; # #指定StubStaus模块的访问日志文件 # access_log logs/Nginxstatus.log; # #Nginx认证机制（需Apache的htpasswd命令生成） # #auth_basic "NginxStatus"; # #用来认证的密码文件 # #auth_basic_user_file ../htpasswd; #&#125;访问：http://IP/NginxStatus(测试就不加密码验证相关) 6）反向代理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#以下配置追加在HTTP的全局变量中#nginx跟后端服务器连接超时时间(代理连接超时)proxy_connect_timeout 5;#后端服务器数据回传时间(代理发送超时)proxy_send_timeout 5;#连接成功后，后端服务器响应时间(代理接收超时)proxy_read_timeout 60;#设置代理服务器（nginx）保存用户头信息的缓冲区大小proxy_buffer_size 16k;#proxy_buffers缓冲区，网页平均在32k以下的话，这样设置proxy_buffers 4 32k;#高负荷下缓冲大小（proxy_buffers*2）proxy_busy_buffers_size 64k;#设定缓存文件夹大小，大于这个值，将从upstream服务器传proxy_temp_file_write_size 64k;#反向代理缓存目录proxy_cache_path /data/proxy/cache levels=1:2 keys_zone=cache_one:500m inactive=1d max_size=1g;#levels=1:2 设置目录深度，第一层目录是1个字符，第2层是2个字符#keys_zone:设置web缓存名称和内存缓存空间大小#inactive:自动清除缓存文件时间。#max_size:硬盘空间最大可使用值。#指定临时缓存文件的存储路径(路径需和上面路径在同一分区)proxy_temp_path /data/proxy/temp#服务配置server &#123; #侦听的80端口 listen 80; server_name localhost; location / &#123; #反向代理缓存设置命令(proxy_cache zone|off,默认关闭所以要设置) proxy_cache cache_one; #对不同的状态码缓存不同时间 proxy_cache_valid 200 304 12h; #设置以什么样参数获取缓存文件名 proxy_cache_key $host$uri$is_args$args; #后7端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #代理设置 proxy_pass http://IP; #文件过期时间控制 expires 1d; &#125; #配置手动清楚缓存(实现此功能需第三方模块 ngx_cache_purge) #http://www.123.com/2017/0316/17.html访问 #http://www.123.com/purge/2017/0316/17.html清楚URL缓存 location ~ /purge(/.*) &#123; allow 127.0.0.1; deny all; proxy_cache_purge cache_one $host$1$is_args$args; &#125; #设置扩展名以.jsp、.php、.jspx结尾的动态应用程序不做缓存 location ~.*\.(jsp|php|jspx)?$ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://http://IP; &#125; 7）负载均衡12345678910111213141516171819202122#负载均衡服务器池upstream my_server_pool &#123; #调度算法 #1.轮循（默认）（weight轮循权值） #2.ip_hash：根据每个请求访问IP的hash结果分配。（会话保持） #3.fair:根据后端服务器响应时间最短请求。（upstream_fair模块） #4.url_hash:根据访问的url的hash结果分配。（需hash软件包） #参数： #down：表示不参与负载均衡 #backup:备份服务器 #max_fails:允许最大请求错误次数 #fail_timeout:请求失败后暂停服务时间。 server 192.168.1.109:80 weight=1 max_fails=2 fail_timeout=30; server 192.168.1.108:80 weight=2 max_fails=2 fail_timeout=30;&#125;#负载均衡调用server &#123; ... location / &#123; proxy_pass http://my_server_pool; &#125;&#125; 8）URL重写123456789101112#根据不同的浏览器URL重写if($http_user_agent ~ Firefox)&#123;rewrite ^(.*)$ /firefox/$1 break; &#125;if($http_user_agent ~ MSIE)&#123;rewrite ^(.*)$ /msie/$1 break; &#125;#实现域名跳转location / &#123; rewrite ^/(.*)$ https://web8.example.com$1 permanent;&#125; 9）IP限制1234567#限制IP访问location / &#123; deny 192.168.0.2； allow 192.168.0.0/24; allow 192.168.1.1; deny all;&#125; 10）Nginx相关命令123456#启动nginxnginx #关闭nginxnginx -s stop#平滑重启kill -HUP `cat /usr/local/nginx/logs/nginx.pid` 11）Nginx启动脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#!/bin/bash#chkconfig: 2345 80 90#description:auto_runPATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATH# Check if user is rootif [ $(id -u) != "0" ]; then echo "Error: You must be root to run this script!\n" exit 1fiNGINXDAEMON=/usr/local/nginx/sbin/nginxPIDFILE=/usr/local/nginx/logs/nginx.pidfunction_start()&#123; echo -en "\033[32;49;1mStarting nginx......\n" echo -en "\033[39;49;0m" if [ -f $PIDFILE ]; then printf "Nginx is runing!\n" exit 1 else $NGINXDAEMON printf "Nginx is the successful start!\n" fi&#125;function_stop()&#123; echo -en "\033[32;49;1mStoping nginx......\n" echo -en "\033[39;49;0m" if [ -f $PIDFILE ]; then kill `cat $PIDFILE` printf "Nginx program is stoped\n" else printf "Nginx program is not runing!\n" fi&#125;function_reload()&#123; echo -en "\033[32;49;1mReload nginx......\n" echo -en "\033[39;49;0m" function_stop function_start&#125;function_restart()&#123; echo -en "\033[32;49;1mRestart nginx......\n" echo -en "\033[39;49;0m" printf "Reload Nginx configure...\n" $NGINXDAEMON -t kill -HUP `cat $PIDFILE` printf "Nginx program is reloding!\n"&#125;function_kill()&#123; killall nginx&#125;function_status()&#123; if ! ps -ef|grep -v grep|grep 'nginx:' &gt; /dev/null 2&gt;&amp;1 then printf "Nginx is down!!!\n" else printf "Nginx is running now!\n" fi&#125;if [ "$1" = "start" ]; then function_startelif [ "$1" = "stop" ]; then function_stopelif [ "$1" = "reload" ]; then function_reloadelif [ "$1" = "restart" ]; then function_restartelif [ "$1" = "kill" ]; then function_killelif [ "$1" = "status" ]; then function_statuselse echo -en "\033[32;49;1m Usage: nginx &#123;start|stop|reload|restart|kill|status&#125;\n" echo -en "\033[39;49;0m"fi]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合]]></title>
    <url>%2F2018%2F02%2F10%2FSSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[配置文件web.xml配置12345678910111213141516171819202122232425262728293031&lt;!-- 配置Spring字符编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件 spring-dao.xml,spring-service.xml,spring-web.xml Mybatis - &gt; spring -&gt; springmvc --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;!-- 默认匹配所有的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; spring配置springMVC配置1234567891011121314151617181920&lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven validator="validator"/&gt; &lt;!-- &lt;mvc:annotation-driven /&gt; --&gt; &lt;!-- 2.静态资源默认servlet配置 (1)加入对静态资源的处理：js,gif,png (2)允许使用"/"做整体映射 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--2.获取使用下面的：配置静态资源的访问映射，此配置中的文件，将不被前端控制器拦截 --&gt; &lt;mvc:resources mapping="/js/**" location="/js/"/&gt; &lt;mvc:resources mapping="/css/**" location="/css/"/&gt; &lt;mvc:resources mapping="/fonts/**" location="/fonts/"/&gt; &lt;mvc:resources mapping="/images/**" location="/images/"/&gt; &lt;!-- 3.配置jsp 显示ViewResolver --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; spring-dao配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!-- 加载数据库资源文件 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!-- 配置数据库连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name="maxPoolSize" value="30" /&gt; &lt;property name="minPoolSize" value="10" /&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name="autoCommitOnClose" value="false" /&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name="checkoutTimeout" value="10000" /&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name="acquireRetryAttempts" value="2" /&gt; &lt;/bean&gt; &lt;!-- 配置sqlSessionFactory对象 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml" /&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="com.gao.entity" /&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml" /&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="com.gao.dao" /&gt; &lt;/bean&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package="com.gao.service"/&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" &gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; mybatis配置1234567891011&lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name="useGeneratedKeys" value="true" /&gt; &lt;!-- 使用列别名替换列名 默认:true --&gt; &lt;setting name="useColumnLabel" value="true" /&gt; &lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt; &lt;/settings&gt; mybatis配置建议使用注解方式:12345@Mapperpublic interface UserMapper &#123; @Select("select * from `user` where username=#&#123;name&#125; and status=0") public User query(String name);&#125; 代码编写Controller代码123456789@Controller @RequestMapping("/mvc") public class mvcController &#123; @RequestMapping("/hello") public String hello()&#123; return "hello"; &#125; &#125; 常用注解@Controller负责注册一个bean 到spring 上下文中@RequestMapping注解为控制器指定可以处理哪些 URL 请求@ResponseBody返回json@ModelAttribute在方法定义上使用@ModelAttribute注解：Spring MVC 在调用目标处理方法前，会先逐个调用在方法级上标注了@ModelAttribute 的方法在方法的入参前使用 @ModelAttribute 注解：可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数 –绑定到对象中，再传入入参将方法入参对象添加到模型中@RequestParam 在处理方法入参处使用 @RequestParam 可以把请求参 数传递给请求方法@RequestParam(value=&quot;name&quot;,defaultValue=&quot;Guest&quot;)//修饰在方法参数里面@PathVariable绑定 URL 占位符到入参123456@RequestMapping("/path/&#123;language&#125;/&#123;id&#125;") public String documentView(Model model, @PathVariable(value = "language") String language, @PathVariable(value = "id") Long id ) &#123; &#125; @ExceptionHandler注解到方法上，出现异常时会执行该方法 @ControllerAdvice使一个Contoller成为全局的异常处理类，类中用@ExceptionHandler方法注解的方法可以处理所有Controller发生的异常@Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。@Component组件@EnableScheduling启动定时任务 传递参数123456789@RequestMapping("/show") public String showPerson(Map&lt;String,Object&gt; map)&#123; Person p =new Person(); map.put("p", p); p.setAge(20); p.setName("jayjay"); return "show";&#125;//前台可在Request域中取到"p" Model model这个放在方法里面的参数，然后就可以model.addAttibute(“key”,value);页面可以获取到Model model, Map model2, ModelMap model3都是同一个对象 request传统方式 123public String view(HttpServletRequest req,HttpSession session)&#123;&#125; 使用redirect方式处理请求12345//redirect @RequestMapping("/redirect")public String redirect()&#123; return "redirect:hello";&#125; 异常的处理12345678@ExceptionHandler(value = UnauthorizedException.class) // 处理访问方法时权限不足问题 public String handle(Exception e) &#123; ModelAndView mv = new ModelAndView("error"); mv.addObject("exception", ex); System.out.println("in testExceptionHandler"); return mv; &#125; //ModelAndView 跳转加设置参数 自定义拦截器创建一个MyInterceptor类，并实现HandlerInterceptor接口123456789101112131415161718建一个MyInterceptor类，并实现HandlerInterceptor接口 @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; System.out.println("afterCompletion"); &#125; @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; System.out.println("postHandle"); &#125; @Override public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, //先執行, Object arg2) throws Exception &#123; System.out.println("preHandle"); return true; &#125; 编写拦截器类实现接口HandlerInterceptor，重写方法afterCompletion，postHandler，preHandler(执行时三种方法的执行步骤为，controller方法前执行preHandler，执行controller方法后执行postHandler、afterCompletion) 将拦截器注册到springMVC框架中（springmvc配置文件）：12345678910&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;bean class="com.gao.interceptor.LoginInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/news/del"/&gt; &lt;bean class="com.gao.interceptor.LimitInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 数据效验12345678910111213141516171819202122&lt;!-- 配置校验器 --&gt;&lt;bean id="validator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"&gt; &lt;!-- 校验器，使用hibernate校验器 --&gt; &lt;property name="providerClass" value="org.hibernate.validator.HibernateValidator"/&gt; &lt;!-- 指定校验使用的资源文件，在文件中配置校验错误信息，如果不指定则默认使用classpath下面的ValidationMessages.properties文件 --&gt; &lt;property name="validationMessageSource" ref="messageSource"/&gt;&lt;/bean&gt;&lt;!-- 校验错误信息配置文件 --&gt;&lt;bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt; &lt;!-- 资源文件名 --&gt; &lt;property name="basenames"&gt; &lt;list&gt; &lt;value&gt;classpath:CustomValidationMessage&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 资源文件编码格式 --&gt; &lt;property name="fileEncodings" value="utf-8"/&gt; &lt;!-- 对资源文件内容缓存时间，单位秒 --&gt; &lt;property name="cacheSeconds" value="120"/&gt;&lt;/bean&gt;&lt;!--注入--&gt;&lt;mvc:annotation-driven validator="validator"/&gt; 实体类1234 @Size(min=3,max=10,message="&#123;errors.title&#125;")private String tTitle;@NotNull(message="&#123;errors.content&#125;")private String tContent; controller12345678910111213@RequestMapping(value="/add",method=RequestMethod.POST)public String add(@Validated News news,BindingResult br,Model model)&#123; //@validated 是@valid一次封装 if(br.hasErrors())&#123; List&lt;ObjectError&gt; errors = br.getAllErrors(); model.addAttribute("errors", errors); //errors.get(0).getDefaultMessage(); FieldError name = br.getFieldError("tTitle"); System.out.println(name.getDefaultMessage()); return "addnews"; &#125; &#125; 文件上传12345678910111213141516171819&lt;!-- 文件上传的配置 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 指定所上传文件的总大小不能超过200KB。注意maxUploadSize属性的限制不是针对单个文件，而是所有文件的容量之和 --&gt; &lt;property name="maxUploadSize" value="200000" /&gt; &lt;property name="defaultEncoding" value="UTF-8"/&gt; &lt;/bean&gt; &lt;!-- 该异常是SpringMVC在检查上传的文件信息时抛出来的，而且此时还没有进入到Controller方法中 --&gt; &lt;bean id="exceptionResolver" class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;!-- 遇到MaxUploadSizeExceededException异常时，自动跳转到WebContent目录下的error.jsp页面 --&gt; &lt;prop key="org.springframework.web.multipart.MaxUploadSizeExceededException"&gt;404&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; controller123456789101112131415161718192021222324252627282930313233343536373839404142@RequestMapping(value="/upload") public String upload(@RequestParam MultipartFile[] myfile,HttpServletRequest request) throws Exception&#123; for (MultipartFile multipartFile : myfile) &#123; if(multipartFile.isEmpty())&#123; System.out.println("文件未上传"); &#125;else&#123; String fileName = multipartFile.getOriginalFilename(); String path1 = request.getSession().getServletContext().getRealPath("image")+File.separator; String path = path1 + new SimpleDateFormat("yyyyMMddHHmmss").format(new Date())+fileName; System.out.println(path); File localFile = new File(path); multipartFile.transferTo(localFile); &#125; &#125; return ""; &#125; @RequestMapping("/download") public String download(String fileName, HttpServletRequest request, HttpServletResponse response) throws Exception&#123; response.setCharacterEncoding("utf-8"); response.setContentType("multipart/form-data"); response.setHeader("Content-Disposition", "attachment;fileName=" + fileName); String path = request.getSession().getServletContext().getRealPath ("image")+File.separator; InputStream inputStream = new FileInputStream(new File(path + fileName)); OutputStream os = response.getOutputStream(); byte[] b = new byte[2048]; int length; while ((length = inputStream.read(b)) &gt; 0) &#123; os.write(b, 0, length); &#125; // 这里主要关闭。 os.close(); inputStream.close(); return null; &#125;]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务中的隔离级别]]></title>
    <url>%2F2018%2F01%2F21%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[来自： 数据库事务中的隔离级别和锁+spring Transactional注解 数据库事务中的隔离级别和锁 数据库事务在后端开发中占非常重要的地位，如何确保数据读取的正确性、安全性也是我们需要研究的问题。ACID首先总结一下数据库事务正确执行的四个要素（ACID）： 原子性（Atomicity）：即事务是不可分割的最小工作单元，事务内的操作要么全做，要么全不做，不能只做一部分；一致性（Consistency）：在事务执行前数据库的数据处于正确的状态，而事务执行完成后数据库的数据还是处于正确的状态，即数据完整性约束没有被破坏；比如我们做银行转账的相关业务，A转账给B，要求A转的钱B一定要收到。如果A转了钱而B没有收到，那么数据库数据的一致性就得不到保障，在做高并发业务时要注意合理的设计。隔离性（Isolation）：并发事务执行之间无影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性；持久性（Durability）：事务一旦执行成功，它对数据库的数据的改变必须是永久的，不会因各种异常导致数据不一致或丢失。事务隔离级别大部分数据库事务操作都是并发执行的，这就可能遇到下面的几种问题： 丢失更新：两个事务同时更新一行数据，最后一个事务的更新会覆盖掉第一个事务的更新，从而导致第一个事务更新的数据丢失，后果比较严重。一般是由于没加锁的原因造成的。脏读（Dirty reads）：一个事务A读取到了另一个事务B还没有提交的数据，并在此基础上进行操作。如果B事务rollback，那么A事务所读取到的数据就是不正确的，会带来问题。不可重复读（Non-repeatable reads）：在同一事务范围内读取两次相同的数据，所返回的结果不同。比如事务B第一次读数据后，事务A更新数据并commit，那么事务B第二次读取的数据就与第一次是不一样的。幻读（Phantom reads）：一个事务A读取到了另一个事务B新提交的数据。比如，事务A对一个表中所有行的数据按照某规则进行修改（整表操作），同时，事务B向表中插入了一行原始数据，那么后面事务A再对表进行操作时，会发现表中居然还有一行数据没有被修改，就像发生了幻觉，飘飘欲仙一样。注意：不可重复读和幻读的区别是，不可重复读对应的表的操作是更改(UPDATE)，而幻读对应的表的操作是插入(INSERT)，两种的应对策略不一样。对于不可重复读，只需要采用行级锁防止该记录被更新即可，而对于幻读必须加个表级锁，防止在表中插入数据。有关锁的问题，下面会讨论。 为了处理这几种问题，SQL定义了下面的4个等级的事务隔离级别： 未提交读（READ UNCOMMITTED ）：最低隔离级别，一个事务能读取到别的事务未提交的更新数据，很不安全，可能出现丢失更新、脏读、不可重复读、幻读；提交读（READ COMMITTED）：一个事务能读取到别的事务提交的更新数据，不能看到未提交的更新数据，不会出现丢失更新、脏读，但可能出现不可重复读、幻读；可重复读（REPEATABLE READ）：保证同一事务中先后执行的多次查询将返回同一结果，不受其他事务影响，不可能出现丢失更新、脏读、不可重复读，但可能出现幻读；序列化（SERIALIZABLE）：最高隔离级别，不允许事务并发执行，而必须串行化执行，最安全，不可能出现更新、脏读、不可重复读、幻读，但是效率最低。隔离级别越高，数据库事务并发执行性能越差，能处理的操作越少。所以一般地，推荐使用REPEATABLE READ级别保证数据的读一致性。对于幻读的问题，可以通过加锁来防止。MySQL支持这四种事务等级，默认事务隔离级别是REPEATABLE READ。Oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别，所以Oracle数据库不支持脏读。Oracle数据库默认的事务隔离级别是READ COMMITTED。 各种锁下面总结一下MySQL中的锁，有好几种分类。其它RDBMS也差不多是这样。首先最重要的分类就是乐观锁(Optimistic Lock)和悲观锁(Pessimistic Lock)，这实际上是两种锁策略。乐观锁，顾名思义就是非常乐观，非常相信真善美，每次去读数据都认为其它事务没有在写数据，所以就不上锁，快乐的读取数据，而只在提交数据的时候判断其它事务是否搞过这个数据了，如果搞过就rollback。乐观锁相当于一种检测冲突的手段，可通过为记录添加版本或添加时间戳来实现。悲观锁，对其它事务抱有保守的态度，每次去读数据都认为其它事务想要作祟，所以每次读数据的时候都会上锁，直到取出数据。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性，但随之而来的是各种开销。悲观锁相当于一种避免冲突的手段。选择标准：如果并发量不大，或数据冲突的后果不严重，则可以使用乐观锁；而如果并发量大或数据冲突后果比较严重（对用户不友好），那么就使用悲观锁。 从读写角度，分共享锁（S锁，Shared Lock）和排他锁（X锁，Exclusive Lock），也叫读锁（Read Lock）和写锁（Write Lock）。理解： 持有S锁的事务只读不可写。如果事务A对数据D加上S锁后，其它事务只能对D加上S锁而不能加X锁。持有X锁的事务可读可写。如果事务A对数据D加上X锁后，其它事务不能再对D加锁，直到A对D的锁解除。从锁的粒度角度，主要分为表级锁（Table Lock）和行级锁（Row Lock）。表级锁将整个表加锁，性能开销最小。用户可以同时进行读操作。当一个用户对表进行写操作时，用户可以获得一个写锁，写锁禁止其他的用户读写操作。写锁比读锁的优先级更高，即使有读操作已排在队列中，一个被申请的写锁仍可以排在所队列的前列。行级锁仅对指定的记录进行加锁，这样其它进程可以对同一个表中的其它记录进行读写操作。行级锁粒度最小，开销大，能够支持高并发，可能会出现死锁。 MySQL的MyISAM引擎使用表级锁，而InnoDB支持表级锁和行级锁，默认是行级锁。还有BDB引擎使用页级锁，即一次锁定一组记录，并发性介于行级锁和表级锁之间。 三级锁协议三级加锁协议是为了保证正确的事务并发操作，事务在读、写数据库对象是需要遵循的加锁规则。 一级封锁协议：事务T在修改数据R之前必须对它加X锁，直到事务结束方可释放。而若事务T只是读数据，不进行修改，则不需加锁，因此一级加锁协议下可能会出现脏读和不可重复读。二级加锁协议：在一级加锁协议的基础上，加上这样一条规则——事务T在读取数据R之前必须对它加S锁，直到读取完毕以后释放。二级加锁协议下可能会出现不可重复读。三级加锁协议：在一级加锁协议的基础上，加上这样一条规则——事务T在读取数据R之前必须对它加S锁，直到事务结束方可释放。三级加锁协议避免了脏读和不可重复读的问题。 spring @Transactional注解参数详解 事物注解方式: @Transactional 当标于类前时, 标示类中所有方法都进行事物处理 , 例子: 1 @Transactional public class TestServiceBean implements TestService {}当类中某些方法不需要事物时: 1234567891011@Transactional public class TestServiceBean implements TestService &#123; private TestDao dao; public void setDao(TestDao dao) &#123; this.dao = dao; &#125; @Transactional(propagation =Propagation.NOT_SUPPORTED)public List getAll() &#123; return null; &#125; &#125; 事物传播行为介绍: 123456789101112@Transactional(propagation=Propagation.REQUIRED) ;//如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)@Transactional(propagation=Propagation.NOT_SUPPORTED) ;//容器不为这个方法开启事务@Transactional(propagation=Propagation.REQUIRES_NEW) ;//不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务@Transactional(propagation=Propagation.MANDATORY) ;//必须在一个已有的事务中执行,否则抛出异常@Transactional(propagation=Propagation.NEVER) ;//必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)@Transactional(propagation=Propagation.SUPPORTS) ;//如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务. 事物超时设置: @Transactional(timeout=30) //默认是30秒 事务隔离级别: @Transactional(isolation = Isolation.READ_UNCOMMITTED)：读取未提交数据(会出现脏读, 不可重复读) 基本不使用 @Transactional(isolation = Isolation.READ_COMMITTED)：读取已提交数据(会出现不可重复读和幻读) @Transactional(isolation = Isolation.REPEATABLE_READ)：可重复读(会出现幻读) @Transactional(isolation = Isolation.SERIALIZABLE)：串行化 MYSQL: 默认为REPEATABLE_READ级别 SQLSERVER: 默认为READ_COMMITTED 脏读 : 一个事务读取到另一事务未提交的更新数据不可重复读 : 在同一事务中, 多次读取同一数据返回的结果有所不同, 换句话说,后续读取可以读到另一事务已提交的更新数据. 相反, “可重复读”在同一事务中多次读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事务已提交的更新数据幻读 : 一个事务读到另一个事务已提交的insert数据 @Transactional注解中常用参数说明 参数名称 功能描述 readOnly 该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。例如：@Transactional(readOnly=true) rollbackFor 该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。例如： 指定单一异常类：@Transactional(rollbackFor=RuntimeException.class) 指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class}) rollbackForClassName 该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。例如： 指定单一异常类名称：@Transactional(rollbackForClassName=“RuntimeException”) 指定多个异常类名称：@Transactional(rollbackForClassName={“RuntimeException”,”Exception”}) noRollbackFor 该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。例如： 指定单一异常类：@Transactional(noRollbackFor=RuntimeException.class) 指定多个异常类：@Transactional(noRollbackFor={RuntimeException.class, Exception.class}) noRollbackForClassName 该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。例如： 指定单一异常类名称：@Transactional(noRollbackForClassName=“RuntimeException”) 指定多个异常类名称： @Transactional(noRollbackForClassName={“RuntimeException”,”Exception”}) propagation 该属性用于设置事务的传播行为，具体取值可参考表6-7。 例如：@Transactional(propagation=Propagation.NOT_SUPPORTED,readOnly=true) isolation 该属性用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置 timeout 该属性用于设置事务的超时秒数，默认值为-1表示永不超时 注意的几点: 1、@Transactional 只能被应用到public方法上, 对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能. 2、用 spring 事务管理器,由spring来负责数据库的打开,提交,回滚.默认遇到运行期例外(throw new RuntimeException(“注释”);)会回滚，即遇到不受检查（unchecked）的例外时回滚；而遇到需要捕获的例外(throw new Exception(“注释”);)不会回滚,即遇到受检查的例外（就是非运行时抛出的异常，编译器会检查到的异常叫受检查例外或说受检查异常）时，需我们指定方式来让事务回滚要想所有异常都回滚,要加上 @Transactional( rollbackFor={Exception.class,其它异常}) .如果让unchecked例外不回滚：@Transactional(notRollbackFor=RunTimeException.class)如下: 12345678@Transactional(rollbackFor=Exception.class) //指定回滚,遇到异常Exception时回滚public void methodName() &#123; throw new Exception("注释");&#125;@Transactional(noRollbackFor=Exception.class)//指定不回滚,遇到运行期例外(throw new RuntimeException("注释");)会回滚public ItimDaoImpl getItemDaoImpl() &#123; throw new RuntimeException("注释");&#125; 3、@Transactional 注解应该只被应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。 4、@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。然而，请注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅 是一种元数据，能够被可以识别 @Transactional 注解和上述的配置适当的具有事务行为的beans所使用。上面的例子中，其实正是 元素的出现 开启 了事务行为。 5、Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因此，请接受Spring团队的建议并且在具体的类上使用 @Transactional 注解。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centOS 7]]></title>
    <url>%2F2018%2F01%2F19%2FcentOs7%2F</url>
    <content type="text"><![CDATA[FTP的搭建和使用https://help.aliyun.com/knowledge_detail/60152.htmlcentos7通过yum安装JDK1.8 安装之前先检查一下系统有没有自带open-jdk命令：rpm -qa |grep javarpm -qa |grep jdkrpm -qa |grep gcj 如果没有输入信息表示没有安装。如果安装可以使用rpm -qa | grep java | xargs rpm -e –nodeps 批量卸载所有带有Java的文件 这句命令的关键字是java首先检索包含java的列表 yum list java* 检索1.8的列表 yum list java-1.8* 安装1.8.0的所有文件 yum install java-1.8.0-openjdk* -y 使用命令检查是否安装成功 java -version CentOS7安装ActiveMQ1、下载activemq，下载地址：http://archive.apache.org/dist/activemq。测试版本为apache-activemq-5.14.1。 2、在/ursr/local/目录下新建activemq文件夹，并进入该文件夹，执行如下命令解压文件。123cd /ursr/localmkdir activemqtar -xzvf apache-activemq-5.14.1-bin.tar.gz 3、在/etc/init.d/目录增加增加activemq文件，文件内容为：12cd /etc/init.d/vi activemq 12345678910111213141516171819202122232425262728293031#!/bin/sh## /etc/init.d/activemq# chkconfig: 345 63 37# description: activemq servlet container.# processname: activemq 5.14.3 # Source function library.#. /etc/init.d/functions# source networking configuration.#. /etc/sysconfig/network #export JAVA_HOME=/usr/local/jdk1.8.0_121export CATALINA_HOME=/usr/local/activemq/apache-activemq-5.14.3 case $1 in start) sh $CATALINA_HOME/bin/activemq start ;; stop) sh $CATALINA_HOME/bin/activemq stop ;; restart) sh $CATALINA_HOME/bin/activemq stop sleep 1 sh $CATALINA_HOME/bin/activemq start ;; esacexit 0 4、对activemq文件授予权限。 hmod 777 activemq5、设置开机启动并启动activemq hkconfig activemq onervice activemq start 5、访问地址：http://IP地址:8161/。 访问成功，ActiveMQ安装完毕。默认用户名密码为：admin/admin。 6、其他 查看activemq状态service activemq status其他和关闭activemq服务12service activemq startservice activemq stop 设置开机启动或不启动activemq服务12chkconfig activemq onchkconfig activemq off Linux系统下yum命令查看安装了哪些软件包：$yum list installed //列出所有已安装的软件包yum针对软件包操作常用命令：1.使用YUM查找软件包命令：yum search2.列出所有可安装的软件包命令：yum list3.列出所有可更新的软件包命令：yum list updates4.列出所有已安装的软件包命令：yum list installed5.列出所有已安装但不在 Yum Repository 内的软件包命令：yum list extras6.列出所指定的软件包命令：yum list7.使用YUM获取软件包信息命令：yum info8.列出所有软件包的信息命令：yum info9.列出所有可更新的软件包信息命令：yum info updates10.列出所有已安装的软件包信息命令：yum info installed11.列出所有已安装但不在 Yum Repository 内的软件包信息命令：yum info extras12.列出软件包提供哪些文件命令：yum provides如何查看yum安装的软件路径 rpm -qa|grep 软件包名 rpm -ql 软件包名 (l是L的小写,不是坚线) rpm常用命令1.安装一个包rpm -ivh2.升级一个包rpm -Uvh3.移走一个包rpm -e4.安装参数–force 即使覆盖属于其它包的文件也强迫安装–nodeps 如果该RPM包的安装依赖其它包，即使其它包没装，也强迫安装。5.查询一个包是否被安装rpm -q &lt; rpm package name&gt;6.得到被安装的包的信息rpm -qi &lt; rpm package name&gt;7.列出该包中有哪些文件rpm -ql &lt; rpm package name&gt;8.列出服务器上的一个文件属于哪一个RPM包rpm -qf9.可综合好几个参数一起用rpm -qil &lt; rpm package name&gt;10.列出所有被安装的rpm packagerpm -qa11.列出一个未被安装进系统的RPM包文件中包含有哪些文件？rpm -qilp &lt; rpm package name&gt; apt-get常用命令apt-cache search package 搜索软件包apt-cache show package 获取包的相关信息，如说明、大小、版本等sudo apt-get install package 安装包sudo apt-get install package –reinstall 重新安装包sudo apt-get -f install 修复安装sudo apt-get remove package 删除包sudo apt-get remove package –purge 删除包，包括配置文件等sudo apt-get update 更新源sudo apt-get upgrade 更新已安装的包sudo apt-get dist-upgrade 升级系统apt-cache depends package 了解使用该包依赖那些包apt-cache rdepends package 查看该包被哪些包依赖sudo apt-get build-dep package 安装相关的编译环境apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包sudo apt-get check 检查是否有损坏的依赖 其他源码安装1 ./configure 相关库文人件以及配置参数并生成make file2 make 对源码进行编译，生成可执行文件3 make install 将生成的可执行文件安装到当前计算机中rpm 基础命令安装软件 ： rpm -i software.rpm卸装软件 : rpm -e software升级形式安装: rpm -U software-new.rpmrpm支持通过http,ftp协议安装软件rpm -lvh http://www.linuxcast.net/software.rpm可以加入以下参数-v显示相关信息-h显示进度条 通常都会加上参数eg: rpm -ivh software.rpm 使用service 管理cd /etc/init.d新建 文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA注解]]></title>
    <url>%2F2018%2F01%2F15%2FJAVA%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. 注解的定义注解通过 @interface 关键字进行定义。12public @interface TestAnnotation &#123;&#125; 2. 注解的应用123@TestAnnotationpublic class Test &#123;&#125; 3. 元注解元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种 1、@RetentionRetention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。 它的取值如下： RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 我们可以这样的方式来加深理解，@Retention 去给一张标签解释的时候，它指定了这张标签张贴的时间。@Retention 相当于给一张标签上面盖了一张时间戳，时间戳指明了标签张贴的时间周期。123@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123;&#125; 2、Documented顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。 3、@TargetTarget 是目标的意思，@Target 指定了注解运用的地方。 你可以这样理解，当一个注解被 @Target 注解时，这个注解就被限定了运用的场景。 类比到标签，原本标签是你想张贴到哪个地方就到哪个地方，但是因为 @Target 的存在，它张贴的地方就非常具体了，比如只能张贴到方法上、类上、方法参数上等等。@Target 有下面的取值 ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 4、@Inherited被@Inherited注解过的类，子类继承它，同时子类也拥有该注解 5、@RepeatableRepeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。 什么样的注解会多次应用呢？通常是注解的值可以同时取多个。 举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。123456789101112131415@interface Persons &#123; Person[] value();&#125;@Repeatable(Persons.class)@interface Person&#123; String role default "";&#125;@Person(role="artist")@Person(role="coder")@Person(role="PM")public class SuperMan&#123;&#125; 4. 注解的属性12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TestAnnotation &#123; int id(); String msg(); int age() default 18; //默认值&#125; 使用：1234@TestAnnotation(id=3,msg="hello annotation") //age默认值18public class Test &#123; &#125; 如果该注解只有value一个属性 那可以直接使用@TestAnnotation(“value”) 5. Java 预置的注解1、@Deprecated过时的方法、过时的类、过时的成员变量 2、@SuppressWarnings忽略@Deprecated这种警告 3、@FunctionalInterface函数式接口注解，这个是 Java 1.8 版本引入的新特性。函数式编程很火，所以 Java 8 也及时添加了这个特性。 5. 注解与反射。(如何被使用)1、通过反射获取注解解通过反射获取。首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {} 然后通过 getAnnotation() 方法来获取 Annotation 对象。public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {} 或者是 getAnnotations() 方法。public Annotation[] getAnnotations() {} 前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。如果获取到的 Annotation 如果不为 null，则就可以调用它们的属性方法了。比如1234567891011121314151617@TestAnnotation()public class Test &#123; public static void main(String[] args) &#123; boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class); if ( hasAnnotation ) &#123; TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class); System.out.println("id:"+testAnnotation.id()); System.out.println("msg:"+testAnnotation.msg()); &#125; &#125;&#125; 2、属性、方法上的注解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@TestAnnotation(msg="hello")public class Test &#123; @Check(value="hi") int a; @Perform public void testMethod()&#123;&#125; @SuppressWarnings("deprecation") public void test1()&#123; Hero hero = new Hero(); hero.say(); hero.speak(); &#125; public static void main(String[] args) &#123; boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class); if ( hasAnnotation ) &#123; TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class); //获取类的注解 System.out.println("id:"+testAnnotation.id()); System.out.println("msg:"+testAnnotation.msg()); &#125; try &#123; Field a = Test.class.getDeclaredField("a"); a.setAccessible(true); //获取一个成员变量上的注解 Check check = a.getAnnotation(Check.class); if ( check != null ) &#123; System.out.println("check value:"+check.value()); &#125; Method testMethod = Test.class.getDeclaredMethod("testMethod"); if ( testMethod != null ) &#123; // 获取方法中的注解 Annotation[] ans = testMethod.getAnnotations(); for( int i = 0;i &lt; ans.length;i++) &#123; System.out.println("method testMethod annotation:"+ans[i].annotationType().getSimpleName()); &#125; &#125; &#125; catch (NoSuchFieldException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(e.getMessage()); &#125; catch (SecurityException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(e.getMessage()); &#125; catch (NoSuchMethodException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); System.out.println(e.getMessage()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA泛型]]></title>
    <url>%2F2018%2F01%2F15%2FJAVA%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、介绍泛型只在编译阶段有效。泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。Java泛型中常用的标记符含义： E - Element (在集合中使用，因为集合中存放的是元素) T - Type（Java 类） K - Key（键） V - Value（值） N - Number（数值类型） ? - 表示不确定的java类型 泛型判断：T instanceof Object 二、泛型的使用1. 泛型类泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。 举例：123456789101112public class Test&lt;T&gt;&#123; private T key; public Test(T key) &#123; this.key = key; &#125; public T getKey()&#123; return key; &#125;&#125; 2. 泛型接口泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子： 定义一个泛型接口123public interface Generator&lt;T&gt; &#123; public T next();&#125; 当实现泛型接口的类，也要定义泛型，不然会报错1234567891011/**java * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot; */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125; 传入泛型实参就不会123public class FruitGenerator implements Generator&lt;String&gt; &#123; //...&#125; 3. 泛型通配符定义一个泛型通配符方法123public void showKeyValue1(Generic&lt;?&gt; obj)&#123; Log.d("泛型测试","key value is " + obj.getKey());&#125; ?代表 当具体类型不确定的时候，这个通配符就是 ?123List&lt;? extends Number&gt; eList = null;eList = new ArrayList&lt;Integer&gt;();eList = new ArrayList&lt;Long&gt;(); 4. 泛型方法定义一个泛型方法12345678910111213141516171819/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 * 泛型的数量也可以为任意多个 * 如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; * ... * &#125; */public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException , IllegalAccessException&#123; T instance = tClass.newInstance(); return instance;&#125; 5. 泛型方法与可变参数T… args 6. 静态方法与泛型如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。 参考:http://blog.csdn.net/s10461/article/details/53941091/]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql常用]]></title>
    <url>%2F2018%2F01%2F11%2FMySql%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[常用1. 常用函数 DATE_ADD(date,INTERVAL i keyword)返回date加上 i 时期keyword可以为：SECONDMINUTEHOURDAYWEEKMONTHQUARTERYEAR DATE_SUB(date,INTERVAL i keyword) 与上面相反 DATE_FORMAT(create_date,’%H%i’)时间格式化：%Y %D %M %h:%i:%s %Y%m%d MONTHNAME(date) 返回date的月份名(英语月份，如October)DAYNAME(date) 返回date的星期名(英语星期几，如Saturday)NOW() 返回当前的日期和时间 如：2016-10-08 18:57:39CURDATE()或CURRENT_DATE() 返回当前的日期CURTIME()或CURRENT_TIME() 返回当前的时间QUARTER(date) 返回date在一年中的季度(1~4)WEEK(date) 返回日期date为一年中第几周(0~53)DAYOFYEAR(date) 返回date是一年的第几天(1~366)DAYOFMONTH(date) 返回date是一个月的第几天(1~31)DAYOFWEEK(date) 返回date所代表的一星期中的第几天(1~7)YEAR(date) 返回日期date的年份(1000~9999)MONTH(date) 返回date的月份值(1~12)DAY(date) 返回date的天数部分HOUR(time) 返回time的小时值(0~23)MINUTE(time) 返回time的分钟值(0~59)SECOND(time) 返回time的秒值（0-59）DATE(datetime) 返回datetime的日期值TIME(datetime) 返回datetime的时间值 TO_DAYS(create_date)返回从0年开始 到date之间的天数 2.系统表 DATABASE() 返回当前数据库名BENCHMARK(count,expr) 将表达式expr重复运行count次CONNECTION_ID() 返回当前客户的连接IDFOUND_ROWS() 返回最后一个SELECT查询进行检索的总行数USER()或SYSTEM_USER() 返回当前登陆用户名VERSION() 返回MySQL服务器的版本 MySQL常用系统表大全：http://blog.csdn.net/xlxxcc/article/details/51754524 3.连接查询 INNER JOIN：如果表中有至少一个匹配，则返回行LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行FULL JOIN：只要其中一个表中存在匹配，则返回行 4.优化速度MySQL数据库优化的八种方式(经典必看)https://www.cnblogs.com/zhyunfe/p/6209074.html https://blog.csdn.net/u014421556/article/details/52063904 centOS 7 安装mysql1.使用安装命令 ：yum -y install mysql mysql-server mysql-devel安装完成却发现Myserver安装缺失，在网上找原因，原来是因为CentOS 7上把MySQL从默认软件列表中移除了，用MariaDB来代替，所以这导致我们必须要去官网上进行下载，找到链接，用wget打开： a. wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm b. rpm -ivh mysql-community-release-el7-5.noarch.rpm c. yum -y install mysql mysql-server mysql-devel，安装成功。 启动服务service mysqld start 进入客户端mysql -u root -p 输入密 常用数据库操作 mysql数据库使用总结本文主要记录一些mysql日常使用的命令，供以后查询。1.更改root密码mysqladmin -uroot password ‘yourpassword’2.远程登陆mysql服务器mysql -uroot -p -h192.168.137.10 -P33063.查询数据库show databases;4.进入某个数据库use databasename;5.列出数据库中的表show tables;6.查看某个表全部字段desc slow_log;show create table slow_log\G; （不仅可以显示表信息，还可以显示建表语句）7.查看当前用户select user();8.查看当前所在数据库select database();9.创建新数据库（可以指定字符集）create database db1 charset utf8;10.创建新表create table t1 (id int(4), name char(40));11.查看数据库版本select version();12.查看数据库状态show status; 当前会话状态show global status; 全局数据库状态show slave status\G; 查看主从数据库状态信息13.查询数据库参数show variables;14.修改数据库参数show variables like ‘max_connect%’;set global max_connect_errors = 1000;（重启数据库会失效，要在配置文件中修改）15.查看当前数据库队列show processlist;16.创建普通用户并授权给某个数据库grant all on databasename. to ‘user1’@’localhost’ identified by ‘123456’;17.查询表数据select from mysql.db; //查询该表中的所有字段select count() from mysql.user; //count()表示表中有多少行select db,user from mysql.db; //查询表中的多个字段select * from mysql.db where host like ‘10.0.%’;在查询语句中可以使用万能匹配 “%”18.插入一行数据insert into db1.t1 values (1, ‘abc’);19.更改表的某一行数据update db1.t1 set name=’aaa’ where id=1;20.清空表数据truncate table db1.t1;21.删除表drop table db1.t1;22.清空数据库中的所有表（数据库名是eab12）mysql -N -s information_schema -e “SELECT CONCAT(‘TRUNCATE TABLE ‘,TABLE_NAME,’;’) FROM TABLES WHERE TABLE_SCHEMA=’eab12’” | mysql -f eab1223.删除数据库drop database db1;24.数据库备份mysqldump -uroot -p’yourpassword’ mysql &gt;/tmp/mysql.sql25.数据库恢复mysql -uroot -p’yourpassword’ mysql &lt;/tmp/mysql.sql26.新建普通用户CREATE USER name IDENTIFIED BY ‘ssapdrow’;27.更改普通用户密码SET PASSWORD FOR name=PASSWORD(‘fdddfd’);28.查看name用户权限SHOW GRANTS FOR name;29.脚本中执行mysql命令mysql -uuser -ppasswd -e”show databases”echo “show databases”|mysql -uuser -ppassword以下是执行大量mysql语句采用的方式mysql -uuser -hhostname -ppasswd &lt;&lt; EOFmysql语句EOF 原文链接：https://www.cnblogs.com/suxiaoman/p/7693066.html MySQL创建用户与授权一. 创建用户命令: CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;说明： username：你将创建的用户名host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器例子：12345CREATE USER 'dog'@'localhost' IDENTIFIED BY '123456';CREATE USER 'pig'@'192.168.1.101_' IDENDIFIED BY '123456';CREATE USER 'pig'@'%' IDENTIFIED BY '123456';CREATE USER 'pig'@'%' IDENTIFIED BY '';CREATE USER 'pig'@'%'; 二. 授权:命令: GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;说明: privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALLdatabasename：数据库名tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用表示，如.*例子:12GRANT SELECT, INSERT ON test.user TO &apos;pig&apos;@&apos;%&apos;;GRANT ALL ON *.* TO &apos;pig&apos;@&apos;%&apos;; 注意: 用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令: GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39; WITH GRANT OPTION; 三.设置与更改用户密码命令: SET PASSWORD FOR &#39;username&#39;@&#39;host&#39; = PASSWORD(&#39;newpassword&#39;);如果是当前登陆用户用: SET PASSWORD = PASSWORD(“newpassword”);例子: SET PASSWORD FOR &#39;pig&#39;@&#39;%&#39; = PASSWORD(&quot;123456&quot;); 四. 撤销用户权限命令: REVOKE privilege ON databasename.tablename FROM &#39;username&#39;@&#39;host&#39;;说明: privilege, databasename, tablename：同授权部分 例子: REVOKE SELECT ON *.* FROM &#39;pig&#39;@&#39;%&#39;;注意: 假如你在给用户’pig’@’%’授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO ‘pig’@’%’，则在使用REVOKE SELECT ON . FROM ‘pig’@’%’;命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON . TO ‘pig’@’%’;则REVOKE SELECT ON test.user FROM ‘pig’@’%’;命令也不能撤销该用户对test数据库中user表的Select权限。 具体信息可以用命令SHOW GRANTS FOR ‘pig’@’%’; 查看。 五.删除用户命令: DROP USER &#39;username&#39;@&#39;host&#39;; 原文链接：https://www.jianshu.com/p/d7b9c468f20d]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle常用]]></title>
    <url>%2F2018%2F01%2F10%2FOracle%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、基本常用语句1. 索引、主键、序列、权限 索引新建索引：create index 索引名 on 表名(列名,……)删除索引：drop index ttt;新建唯一索引：create unique index 索引名 on 表名（列名……）唯一索引用途：一个数据列，不能作为主键，而且允许为空，但是业务上要求唯一特性，这个时候用唯一性索引就是最好的旋转 主键新建主键：alter table 表名 add constraint 主键名 primary key(主键列)删除主键/外键：alter table drop constraint 主键名新建外键：alter table add constraint 外键名 foreign key(外键列) references 表名(列名) 序列创建序列：create sequence squ_tstart with 1minvalue 1maxvalue 999increment by 1nocycle //是否循环，建议不使用nocache; //是否启用缓存。使用缓存可以提高sequence的访问效率序列属性：1.nextval : 返回下一个可用的序列值。就算是被不同的用户调用，每次也返回一个唯一的值。2.currval ：获取序列当前的值。在currval调用之前，必须保证nextval已经获取过一次值。删除序列：drop sequence squ_t 权限：grant 权限等级(select,insert,update,delete) on 权限内容（table,视图，sequence,index） to (aaaaa)aaaaaa:public:对所有用户开放权限group 分组名:对该组所有用户开放权限username:对指定用户开放权限grant select on tablename to scott回收权限：revoke select on tablename from scott exists in区别：IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情 2.常用函数 nvl(x1,x2)当x1为null时返回X2,否则返回x1 instr(C1,C2,i,j)C1 被搜索的字符串C2 希望搜索的字符串I 搜索的开始位置,默认为1J 出现的位置,默认为1i为负数，从右边开始算起 length()字符串长度 ltrim(‘’,’’)左截取，对应右截取rtrim(‘’,’’)trim() 修剪 substr(s,i,j) abs() 绝对值 add_months(date,i)返回日期date加上i月的结果。i小数，直接向下取整 last_day(d)返回d月的最后一天日期 trunc(date,format)1.select trunc(sysdate) from dual –2011-3-18 今天的日期为2011-3-182.select trunc(sysdate, ‘mm’) from dual –2011-3-1 返回当月第一天.3.select trunc(sysdate,’yy’) from dual –2011-1-1 返回当年第一天4.select trunc(sysdate,’dd’) from dual –2011-3-18 返回当前年月日5.select trunc(sysdate,’yyyy’) from dual –2011-1-1 返回当年第一天6.select trunc(sysdate,’d’) from dual –2011-3-13 (星期天)返回当前星期的第一天7.select trunc(sysdate, ‘hh’) from dual –2011-3-18 14:00:00 当前时间为14:418.select trunc(sysdate, ‘mi’) from dual –2011-3-18 14:41:00 TRUNC()函数没有秒的精确Number 需要截尾取整的数字。Num_digits 用于指定取整精度的数字Num_digits 的默认值为 0。TRUNC()函数截取时不进行四舍五入 to_char(data,format)to_char(oper_time,’yyyyMMddhh24’) DECODE(x,y,z,k,j,i)if (x==y) :z else if(x==k) :j else :i 3.其他常用： SQL执行顺序(8) SELECT (9) DISTINCT (11) (1) FROM (3) JOIN (2) ON (4) WHERE (5) GROUP BY (6) WITH {CUBE | ROLLUP}(7) HAVING (10) ORDER BY 二、系统内置表：https://www.cnblogs.com/jiangxinnju/p/5840420.html 三、提高oracle查询效率https://www.2cto.com/database/201301/181269.html]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本常用]]></title>
    <url>%2F2018%2F01%2F09%2Fshell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一.内部常用命令 echo 在屏幕上输出-n 不会换行-e 会识别换行符\n printf 产生各种格式的输出 export 定义全局变量 export 变量名=变量值 read 读入数据read -p “我是提示语句” file-t 指定等待时间-n指定字符串长度-s 隐藏输入的数据-p：输入提示符 exec如：exec echo $ashell里，作为独立进程去执行该命令 exprexpr length “this is a test”expr substr “this is a test” 3 5expr index “sarasara” aexpr 10 + 10 //+、-、、/、%expr 30 \ 3 //乘用 反斜杠*表示 二、控制、循环语句1. if语句1234567891011#!/bin/bashcd ..if [ -f test1.txt ]then echo test.txt is a fail; cat test1.txtelif [ -d shell ]then echo in shell is dir; dir shell #打印出shell目录中的内容fi 注意： 数值判断： -eq 等于 -ge 大于等于 -gt 大于 -le 小于等于 -lt 小于 -ne 不等于字符串判断（两边有个空格） = 等于 != 不等于 -z 字符串长度为零 -n 字符串长度不为零文件测试 -d 如果文件存在且为目录，则为真 -e 如果文件存在 -f 如果文件存在且为普通文件 -r ….且可读 -w ….且可写 -x ….且可执行 -s ….且至少有一个字符 2.switch语句123456789101112#!/bin/bashcd ..echo "please choice to display is file";echo "1:display test.txt";echo "2:display test1.txt";echo enter your choice;read -p "please in num:" varcase $var in 1) cat test.txt;; 2) cat test1.txt;; *) echo error;;esac 3.for语句123456#!/bin/bashfor num in 1 2 3 4 5 6 7 8 9 10 do echo $num is: expr $num \* $numdone 4.while语句123456789#!/bin/bashecho "please input number(gt 100 will quit)"; read num;while [ $num -lt 100 ]do echo result: expr $num \* $num; read num; done 5. until语句12345678910#!/bin/bash echo "please input fileName:" read filename; echo "please input fileContent(in 'end! quit!!!'):" read fileContent; until [ $fileContent = "end!" ] do $fileContent &gt;&gt; $filename #写内容到这个文件去 echo "please input fileContent(in 'end! quit!!!'):" read fileContent done 三、其他常用 引号含义：反引号：shell中 会首先执行反引号的代码单引号：不是解释，原封不动打印出来双引号：解释变量，而且保留空格没有引号：解释变量，不会保留空格 $符号含义$#表示用户输入参数的个数$0 是脚本本身的名字$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误$$ 是脚本运行的当前进程ID号$@$*$! 后台运行程序的pid都是代表说有， $@每一个会被区别对待num# 8# 16# 2# 代表进制 运算sum=$(($sum$i)) 等于 let “sum=sumi” == s$i == ${i} 小括号，中括号，双括号，大括号区别if ($i&lt;5) 12345678if [ $i -lt 5 ] if [ $a -ne 1 -a $a != 2 ] if [ $a -ne 1] &amp;&amp; [ $a != 2 ] if [[ $a != 1 &amp;&amp; $a != 2 ]] for i in $(seq 0 4);do echo $i;done for i in `seq 0 4`;do echo $i;done for ((i=0;i&lt;5;i++));do echo $i;done for i in &#123;0..4&#125;;do echo $i;done 注意shell脚本对空格有严格的规定，赋值语句等号两边不能有空格，而字符串比较，等号两边必须有空格]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux高级]]></title>
    <url>%2F2018%2F01%2F09%2Flinux%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[sed命令sed命令行格式为： sed [-nefri] ‘command’ 输入文本 常用选项： -n∶使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。 set -n ‘20,30p’ 文件 常与p结合使用 set -参数 ‘/条件/ c\ sfdasf’ 文件 -e∶直接在指令列模式上进行 sed 的动作编辑； set -e -n 20,30p’ a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～ sed ‘/100/ a bbb’ 文件 c ∶取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！ d ∶删除，因为是删除啊，所以 d 后面通常不接任何咚咚； sed ‘/^9/d’ count.log sed ‘100d’ count.log sed ‘2,$d’ count.log i ∶插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)； p ∶列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作～ s ∶取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！ 要替换时，如果“原内容”或“新内容”中含有特殊字符（比如”/”或者”#”等），可以使用其它符号把各部分隔开，比如以下几种格式都是正确的 sed -i ‘s,原内容,新内容,g’ 文件 sed -i ‘s#原内容#新内容#g’ 文件 sed -i ‘s:原内容:新内容:g’ 文件 sed -i ‘s~原内容~新内容~g’ 文件 匹配规则： . 匹配任意一个字符 * 匹配0 个或多个*前的字符 ^ 匹配行开头 $ 匹配行结尾 awk命令 格式 格式:awk -F: ‘BEGIN {处理文件前执行的代码块} ｛处理文件过程中执行的代码块} END {处理文件后执行的代码块}’ filename如：cat count.log|awk ‘BEGIN{a=1;b=2}{print $(a+b)}END{print $1}’awk -F: ‘BEGIN {print “这是第一行”} {print $0} END {print “这是最后一行”}’print $1,$2 打印多个用逗号，$0代表整行。其中+和?只适用于awk而不适用于grep或sed:+ 匹配一个或一个以上前面的单字符? 匹配0个或一个前面的单字符举例:/XY+Z/ 匹配XYZ、XYYYYZ/XY?Z/ 匹配XYZ、XZ~ 匹配正则表达式!~ 不匹配正则表达式 awk有许多内置变量用来设置环境信息，常用的有 ARGC 命令行参数个数ARGV 命令行参数排列ENVIRON 支持队列中系统环境变量的使用FILENAME awk读取的文件名FNR 当前文件已处理的记录行数FS 设置域分隔符，相当于-FNF 域的列数echo ‘/user/apache/conf/httpd.conf’|awk -F/ ‘{print $NF}’NR 已处理的记录总行数OFS 设置输出字段域分隔符RS/ORS 换行符 举例 awk ‘{name=$1;belts=$4;if(belts ~ /Yellow/) print name “is belt “belts}’ grade.txtawk ‘{if($1==”ley”)$7=$7-40; print $0}’ grade.txtawk ‘BEGIN{print “Name\tDifference”}{if ($6&lt;$7){$8=$7-$6;print $1,$8}}’ gra //模拟第8列出来awk ‘BEGIN {print “Name\tDifference”} {if ($6 &lt; $7) {diff = $7 - $6; print $1,diff}}’ grade.txt //同上，不模拟列，直接给变量awk ‘total+=$6;END{print total}’ gradeawk ‘{total+=$6;END{print total}}’ grade*//区别： 上面的所有内容就将会打印出来，下面的只会打印结果 函数 awk有很多强大的字符串函数:gsub(r,s,t) 在整个字符串t中用字符串s替代所有满足正则表达式r的字符串（如没指定t则默认为$0）index(s,t) 返回字符串s中字符串t第一次出现的位置（如不存在则为0）length(s) 返回s字符串的长度（如没指定s则默认为$0）match(s,r) 返回第一个满足正则表达式r的字符串在s字符串里面的位置（如无匹配的则为0）split(s,a,sep) 使用sep将字符串s分隔成为数组a的元素，返回数组元素的数量（如果没指定分隔符则默认与FS相同用法）sprint(“fmt”,exp) 使用printf的格式说明对表达式exp 进行格式化输出sub(r,s,t) 在字符串t中用s字符串替换满足正则表达式r的第一个字符串，返回1如果成功，否则返回0（如没指定t则默认为$0）substr(s,p,n) 返回字符串s中以p位置开始长度为n的字符串（如果没指定n则返回从p位置开始的所有字符串）tolower(s) 将字符串s中的所有大写字母转换为小写，返回转换后的字符串toupper(s) 将字符串s中的所有小写字母转换为大写，返回转换后的字符串 vim 插入命令 i 在当前位置生前插入I 在当前行首插入a 在当前位置后插入A 在当前行尾插入o 在当前行之后插入一行O 在当前行之前插入一行 查找命令 ngg 12gg 跳转12行 或者 :12/xxx ?xxx 向上查找 向下查找ctrl + f 向下翻页 同 page down.ctrl + b 向上翻页 同 page up.ctrl + d 向下翻半页 此比较有用ctrl + u 向上翻半页 此比较有用ctrl + e 向下翻一行ctrl + y 向上一行跳到文本的最后一行：按“G”,即“shift+g” 其他常用 u 撤销（Undo）Ctrl + r 重做（Rx 删除当前字符edo），即撤销的撤销。x 删除当前字符dd 删除当前行10d 删除当前行开始的10行。 其他常用 加载文件顺序 etc/profile–&gt;~/.bash_profile–&gt;~/.bashrc–&gt;/etc/bashrc source /etc/profile 重新加载该文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令进阶]]></title>
    <url>%2F2018%2F01%2F09%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[df命令（查看磁盘情况） 12345678df -i 以inode模式来显示磁盘使用情况df -t ext3 显示指定类型磁盘df -ia 列出各文件系统的i节点使用情况df -h 以更易读的方式显示目前磁盘空间和使用情况 du命令 12345678du log30.tar.gz log31.tar.gz显示多个文件所占空间du -s 只显示总和的大小du -ah test文件和目录都显示du -c log30.tar.gz log31.tar.gz显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和 cp -R 连目录一起复制 chmod命令 12345678u ：目录或者文件的当前的用户g ：目录或者文件的当前的群组o ：除了目录或者文件的当前用户或群组之外的用户或者群组a ：所有的用户及群组chmod 751 file 给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限chmod u=rwx,g=rx,o=x file 同上 chown命令 1234567chown [选项]... [所有者][:[组]] 文件...chown mail:mail log2012.log 改变拥有者和群组chown :mail log2012.log 改变文件群组chown -R root:mail test6 改变指定目录以及其子目录下的所有文件的拥有者和群组 ftp命令 123456789ftp 192.168.1.1get 路径 //下载文件mget *.* //下载多个文件put 1.htm /usr/your/2.htm 把本地的1.htm传送到远端主机/usr/your,并改名为2.htmmput *.htm 将本地主机中一批文件传送至远端主机。bye 断开连接 tar 123 -v ：压缩的过程中显示文件！这个常用-c 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。相当于打包。-f ：使用档名，请留意，在 f 之后要立即接档 grep 参数 查找条件 文件名。 1234567891011121314151617181920212223 主要参数： －c：只输出匹配行的计数。 －I：不区分大 小写(只适用于单字符。 －l：查询多文件时只输出包含匹配字符的文件名。 －n：显示匹配行及 行号。 －s：不显示不存在或无匹配文本的错误信息。 －v：显示不包含匹配文本的所有行。－r：**递归**文件夹查询。 grep: . 匹配任意一个字符 * 匹配0 个或多个*前的字符 ^ 匹配行开头 $ 匹配行结尾 [options]主要参数： \： 忽略正则表达式中特殊字符的原有含义。 ^：匹配正则表达式的开始行。 $: 匹配正则表达式的结束行。 \&lt;：从匹配正则表达 式的行开始。 \&gt;：到匹配正则表达式的行结束。 [ ]：单个字符，如[A]即A符合要求 。 [ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。 .：所有的单个字符。 * ：有字符，长度可以为0。 env 显示当前用户变量，set显示全局变量 cut 12-f列号：提取第几列-d分隔符：按照指定分隔符分隔列（默认是一个制表符当分隔符） sort排序 123456789sort [选项]-f 忽略大小写-n 以数值型进行排序-r 反向排序-t 指定分隔符,默认是制表符-k n[,m] 按照指定的字段范围排序.从第n字段开始,m字段结束(默认到行尾) sort -n -t &quot;:&quot; -k 3,3 /etc/passwd sort -t &quot;:&quot; -k 3,3 /etc/passwd sort -r /etc/passwd find 1234567891011121314151617181920212223242526 find . -size 25k 查找文件大小是25K的文件 -25K 小于 25K 等于25K +25K 大于 find /etc -size +20K -a -size 50k 查找/etc下，大于20K并且小于50K文件 -a 逻辑与 and -o 逻辑或 or find /etc -size +20K -a -size -50k -exec ls -lh &#123;&#125; \; -exec 命令 &#123;&#125; \; 对搜索结果执行操作 find /var/log/ -mtime +10 查找10天前修改的文件 -10 10天内修改文件 10 10天当天修改的文件 +10 10天前修改的文件 atime 文件访问时间 ctime 改变文件属性 mtime 修改文件内容find / -name *.java查询.java后缀的文件find . -type 类型参数f 普通文件d 目录find ./ -name *.java | awk &apos;&#123;print $1 &#125;&apos;|xargs grep &apos;USER_&apos;重要（ awk &apos;&#123;print $1 &#125;&apos; 可以不要） crontab命令选项: 1234-u指定一个用户-l列出某个用户的任务计划-r删除某个用户的任务-e编辑某个用户的任务 ssh 123456ssh ip/用户名@ip 两种方式ssh ip -p 222 指定端口SCP[-r] 用户名@ip：文件路径 本地路径下载文件scp [-r] 本地文件 用户名@ip：上传路径上传文件 nohupnohup 命令 &amp; crontab 1234备份：crontab -l&gt;crontab20161还原：crontab crontab20161]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用 150 个命令汇总]]></title>
    <url>%2F2018%2F01%2F08%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[命令 功能说明 线上查询及帮助命令 (2 个) man 查看命令帮助，命令的词典，更复杂的还有 info，但不常用。 help 查看 Linux 内置命令的帮助，比如 cd 命令。 文件和目录操作命令 (18 个) ls 全拼 list，功能是列出目录的内容及其内容属性信息。 cd 全拼 change directory，功能是从当前工作目录切换到指定的工作目录。 cp 全拼 copy，其功能为复制文件或目录。 find 查找的意思，用于查找目录及目录下的文件。 mkdir 全拼 make directories，其功能是创建目录。 mv 全拼 move，其功能是移动或重命名文件。 pwd 全拼 print working directory，其功能是显示当前工作目录的绝对路径。 rename 用于重命名文件。 rm 全拼 remove，其功能是删除一个或多个文件或目录。 rmdir 全拼 remove empty directories，功能是删除空目录。 touch 创建新的空文件，改变已有文件的时间戳属性。 tree 功能是以树形结构显示目录下的内容。 basename 显示文件名或目录名。 dirname 显示文件或目录路径。 chattr 改变文件的扩展属性。 lsattr 查看文件扩展属性。 file 显示文件的类型。 md5sum 计算和校验文件的 MD5 值。 查看文件及内容处理命令（21 个） cat 全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。 tac tac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。 more 分页显示文件内容。 less 分页显示文件内容，more 命令的相反用法。 head 显示文件内容的头部。 tail 显示文件内容的尾部。 cut 将文件的每一行按指定分隔符分割并输出。 split 分割文件为不同的小片段。 paste 按行合并文件内容。 sort 对文件的文本内容排序。 uniq 去除重复行。oldboy wc 统计文件的行数、单词数或字节数。 iconv 转换文件的编码格式。 dos2unix 将 DOS 格式文件转换成 UNIX 格式。 diff 全拼 difference，比较文件的差异，常用于文本文件。 vimdiff 命令行可视化文件比较工具，常用于文本文件。 rev 反向输出文件内容。 grep/egrep 过滤字符串，三剑客老三。 join 按两个文件的相同字段合并。 tr 替换或删除字符。 vi/vim 命令行文本编辑器。 文件压缩及解压缩命令（4 个） tar 打包压缩。oldboy unzip 解压文件。 gzip gzip 压缩工具。 zip 压缩工具。 信息显示命令（11 个） uname 显示操作系统相关信息的命令。 hostname 显示或者设置当前系统的主机名。 dmesg 显示开机信息，用于诊断系统故障。 uptime 显示系统运行时间及负载。 stat 显示文件或文件系统的状态。 du 计算磁盘空间使用情况。 df 报告文件系统磁盘空间的使用情况。 top 实时显示系统资源使用情况。 free 查看系统内存。 date 显示与设置系统时间。 cal 查看日历等时间信息。 搜索文件命令（4 个） which 查找二进制命令，按环境变量 PATH 路径查找。 find 从磁盘遍历查找文件或目录。 whereis 查找二进制命令，按环境变量 PATH 路径查找。 locate 从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用 updatedb 更新库。 用户管理命令（10 个） useradd 添加用户。 usermod 修改系统已经存在的用户属性。 userdel 删除用户。 groupadd 添加用户组。 passwd 修改用户密码。 chage 修改用户密码有效期限。 id 查看用户的 uid,gid 及归属的用户组。 su 切换用户身份。 visudo 编辑 / etc/sudoers 文件的专属命令。 sudo 以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。 基础网络操作命令（11 个） telnet 使用 TELNET 协议远程登录。 ssh 使用 SSH 加密协议远程登录。 scp 全拼 secure copy，用于不同主机之间复制文件。 wget 命令行下载文件。 ping 测试主机之间网络的连通性。 route 显示和设置 linux 系统的路由表。 ifconfig 查看、配置、启用或禁用网络接口的命令。 ifup 启动网卡。 ifdown 关闭网卡。 netstat 查看网络状态。 ss 查看网络状态。 深入网络操作命令（9 个） nmap 网络扫描命令。 lsof 全名 list open files，也就是列举系统中已经被打开的文件。 mail 发送和接收邮件。 mutt 邮件管理命令。 nslookup 交互式查询互联网 DNS 服务器的命令。 dig 查找 DNS 解析过程。 host 查询 DNS 的命令。 traceroute 追踪数据传输路由状况。 tcpdump 命令行的抓包工具。 有关磁盘与文件系统的命令（16 个） mount 挂载文件系统。 umount 卸载文件系统。 fsck 检查并修复 Linux 文件系统。 dd 转换或复制文件。 dumpe2fs 导出 ext2/ext3/ext4 文件系统信息。 dump ext2/3/4 文件系统备份工具。 fdisk 磁盘分区命令，适用于 2TB 以下磁盘分区。 parted 磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。 mkfs 格式化创建 Linux 文件系统。 partprobe 更新内核的硬盘分区表信息。 e2fsck 检查 ext2/ext3/ext4 类型文件系统。 mkswap 创建 Linux 交换分区。 swapon 启用交换分区。 swapoff 关闭交换分区。 sync 将内存缓冲区内的数据写入磁盘。 resize2fs 调整 ext2/ext3/ext4 文件系统大小。 系统权限及用户授权相关命令（4 个） chmod 改变文件或目录权限。 chown 改变文件或目录的属主和属组。 chgrp 更改文件用户组。 umask 显示或设置权限掩码。 查看系统用户登陆信息的命令（7 个） whoami 显示当前有效的用户名称，相当于执行 id -un 命令。 who 显示目前登录系统的用户信息。 w 显示已经登陆系统的用户列表，并显示用户正在执行的指令。 last 显示登入系统的用户。 lastlog 显示系统中所有用户最近一次登录信息。 users 显示当前登录系统的所有用户的用户列表。 finger 查找并显示用户信息。 内置命令及其它（19 个） echo 打印变量，或直接输出指定的字符串 printf 将结果格式化输出到标准输出。 rpm 管理 rpm 包的命令。 yum 自动化简单化地管理 rpm 包的命令。 watch 周期性的执行给定的命令，并将命令的输出以全屏方式显示。 alias 设置系统别名。 unalias 取消系统别名。 date 查看或设置系统时间。 clear 清除屏幕，简称清屏。 history 查看命令执行的历史纪录。 eject 弹出光驱。 time 计算命令执行时间。 nc 功能强大的网络工具。 xargs 将标准输入转换成命令行参数。 exec 调用并执行指令的命令。 export 设置或者显示环境变量。 unset 删除变量或函数。 type 用于判断另外一个命令是否是内置命令。 bc 命令行科学计算器 系统管理与性能监视命令 (9 个) chkconfig 管理 Linux 系统开机启动项。 vmstat 虚拟内存统计。 mpstat 显示各个可用 CPU 的状态统计。 iostat 统计系统 IO。 sar 全面地获取系统的 CPU、运行队列、磁盘 I/O、分页（交换区）、内存、 CPU 中断和网络等性能数据。 ipcs 用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。 ipcrm 用来删除一个或更多的消息队列、信号量集或者共享内存标识。 strace 用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。 ltrace 命令会跟踪进程的库函数调用, 它会显现出哪个库函数被调用。 关机 / 重启 / 注销和查看系统信息的命令（6 个） shutdown 关机。 halt 关机。 poweroff 关闭电源。 logout 退出当前登录的 Shell。 exit 退出当前登录的 Shell。 Ctrl+d 退出当前登录的 Shell 的快捷键。 进程管理相关命令（15 个） bg 将一个在后台暂停的命令，变成继续执行 （在后台执行）。 fg 将后台中的命令调至前台继续运行。 jobs 查看当前有多少在后台运行的命令。 kill 终止进程。 killall 通过进程名终止进程。 pkill 通过进程名终止进程。 crontab 定时任务命令。 ps 显示进程的快照。 pstree 树形显示进程。 nice/renice 调整程序运行的优先级。 nohup 忽略挂起信号运行指定的命令。 pgrep 查找匹配条件的进程。 runlevel 查看系统当前运行级别。 init 切换运行级别。 service 启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。 来源：banana 童www.cnblogs.com/bananaaa/p/7774467.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro在SpringBoot中配置]]></title>
    <url>%2F2018%2F01%2F08%2FShiro%E5%9C%A8SpringBoot%E4%B8%AD%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一、什么是Shiro​ Shiro是一个很易用与Java项目的的安全框架，主要提供了提供了认证、授权、加密、会话管理功能。 二、Shiro主要记住哪些 ShiroFilterFactory Shiro核心类 SecurityManager 用于管理所有的Subject Subject 当前用户操作 Realms 用于进行权限信息的验证，也是我们需要自己实现的。 三、步骤：1.pom.xml中添加Shiro依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; 2.注入ShiroFilterFactory和SecurityManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/** * shiro配置 * * @Description: * @author: gaojindeng * @Time: 2018年1月6日 下午4:31:00 * */@Configurationpublic class ShiroConfig &#123; /** * ShiroFilterFactoryBean 处理拦截资源文件问题。 * 注意：单独一个ShiroFilterFactoryBean配置是或报错的，以为在 * 初始化ShiroFilterFactoryBean的时候需要注入：SecurityManager * * Filter Chain定义说明 1、一个URL可以配置多个Filter，使用逗号分隔 2、当设置多个过滤器时，全部验证通过，才视为通过 * 3、部分过滤器可指定参数，如perms，roles * */ @Bean public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 必须设置 SecurityManager shiroFilterFactoryBean.setSecurityManager(securityManager); // 如果不设置默认会自动寻找Web工程根目录下的"/login.jsp"页面 shiroFilterFactoryBean.setLoginUrl("/login"); // 登录成功后要跳转的链接 shiroFilterFactoryBean.setSuccessUrl("/index"); // 未授权界面; shiroFilterFactoryBean.setUnauthorizedUrl("/error"); // 拦截器. Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;(); // 配置不会被拦截的链接 顺序判断 // 配置退出过滤器,其中的具体的退出代码Shiro已经替我们实现了 filterChainDefinitionMap.put("/logout", "logout"); filterChainDefinitionMap.put("/css/**", "anon"); filterChainDefinitionMap.put("/fonts/**", "anon"); filterChainDefinitionMap.put("/image/**", "anon"); filterChainDefinitionMap.put("/js/**", "anon"); filterChainDefinitionMap.put("/favicon.ico", "anon"); filterChainDefinitionMap.put("/", "anon"); filterChainDefinitionMap.put("/register", "anon"); filterChainDefinitionMap.put("/index/**", "anon"); // 首页 filterChainDefinitionMap.put("/charts/**", "anon");// 图表 filterChainDefinitionMap.put("/statistics/**", "anon");// 统计 filterChainDefinitionMap.put("/about/**", "anon");// 关于 // filterChainDefinitionMap.put("/setup/**", "authc"); // filterChainDefinitionMap.put("/capital/entrustment", // "perms[user:admin:*]"); // filterChainDefinitionMap.put("/capital/entrustment", "authc"); // &lt;!-- 过滤链定义，从上向下顺序执行，一般将 /**放在最为下边 --&gt;:这是一个坑呢，一不小心代码就不好使了; // &lt;!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问--&gt; filterChainDefinitionMap.put("/**", "authc"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); System.out.println("Shiro拦截器工厂类注入成功"); return shiroFilterFactoryBean; &#125; @Bean public SecurityManager securityManager() &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 设置realm. securityManager.setRealm(myShiroRealm()); return securityManager; &#125; /** * 身份认证realm; (这个需要自己写，账号密码校验；权限等) * * @return */ @Bean public MyShiroRealm myShiroRealm() &#123; MyShiroRealm myShiroRealm = new MyShiroRealm(); myShiroRealm.setCredentialsMatcher(hashedCredentialsMatcher()); return myShiroRealm; &#125; /** * 开启shiro aop注解支持. 使用代理方式;所以需要开启代码支持; * * @param securityManager * @return */ @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) &#123; AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; &#125; /** * 该方法不加上，权限认证也可以通过 * * @return */ /* @Bean public static LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() &#123; return new LifecycleBeanPostProcessor(); &#125;*/ /** * 不加上这个 权限注解通过不了 * * @return */ @Bean public static DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() &#123; return new DefaultAdvisorAutoProxyCreator(); &#125; /** * 凭证匹配器 （由于我们的密码校验交给Shiro的SimpleAuthenticationInfo进行处理了 * 所以我们需要修改下doGetAuthenticationInfo中的代码; ） * * @return */ @Bean public HashedCredentialsMatcher hashedCredentialsMatcher() &#123; HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher(); hashedCredentialsMatcher.setHashAlgorithmName("md5");// 散列算法:这里使用MD5算法; hashedCredentialsMatcher.setHashIterations(2);// 散列的次数，比如散列两次，相当于 // md5(md5("")); return hashedCredentialsMatcher; &#125;&#125;注入ShiroFactory==&gt;SecurityManager==&gt;RealmRealm是实现权限认证、授权的，所有要自己手动新建这个类### 3.Realm代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class MyShiroRealm extends AuthorizingRealm &#123; @Autowired private IUserSV userSV; /** * 认证信息.(身份验证) : Authentication 是用来验证用户身份 * * @param token * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; // 获取用户的输入的账号. String username = (String) token.getPrincipal(); // 通过username从数据库中查找 User对象，如果找到，没找到. // 实际项目中，这里可以根据实际情况做缓存，如果不做，Shiro自己也是有时间间隔机制，2分钟内不会重复执行该方法 User userInfo = userSV.queryByName(username); if (userInfo == null) &#123; return null; &#125; // 加密方式; // 交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配，如果觉得人家的不好可以自定义实现 SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(userInfo, // 用户名 userInfo.getPassword(), // 密码 ByteSource.Util.bytes(userInfo.getSalt()), // //salt=username+salt getName() // realm name ); // 明文: 若存在，将此用户存放到登录认证info中，无需自己做密码对比，Shiro会为我们进行密码对比校验 // SimpleAuthenticationInfo authenticationInfo = new // SimpleAuthenticationInfo( // userInfo, //用户名 // userInfo.getPassword(), //密码 // getName() //realm name // ); return authenticationInfo; &#125; /** * 此方法调用 hasRole,hasPermission的时候才会进行回调. * * 权限信息.(授权): 1、如果用户正常退出，缓存自动清空； 2、如果用户非正常退出，缓存自动清空； * 3、如果我们修改了用户的权限，而用户不退出系统，修改的权限无法立即生效。 （需要手动编程进行实现；放在service进行调用） * 在权限修改后调用realm中的方法，realm已经由spring管理，所以从spring中获取realm实例， 调用clearCached方法； * :Authorization 是授权访问控制，用于对用户进行的操作授权，证明该用户是否允许进行当前操作，如访问某个链接，某个资源文件等。 * * @param principals * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; /* * 当没有使用缓存的时候，不断刷新页面的话，这个代码会不断执行， 当其实没有必要每次都重新设置权限信息，所以我们需要放到缓存中进行管理； * 当放到缓存中时，这样的话，doGetAuthorizationInfo就只会执行一次了， 缓存过期之后会再次执行。 */ System.out.println("权限配置--&gt;MyShiroRealm.doGetAuthorizationInfo()"); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); User userInfo = (User) principals.getPrimaryPrincipal(); // 实际项目中，这里可以根据实际情况做缓存，如果不做，Shiro自己也是有时间间隔机制，2分钟内不会重复执行该方法 // UserInfo userInfo = userInfoService.findByUsername(username) // 权限单个添加; // authorizationInfo.addRole("admin"); // 添加权限 // authorizationInfo.addStringPermission("userInfo:query"); for (Role role : userInfo.getRoles()) &#123; authorizationInfo.addRole(role.getType()); for (Permission p : role.getPermissions()) &#123; authorizationInfo.addStringPermission(p.getPermission()); &#125; &#125; return authorizationInfo; &#125;&#125; 4.controller层代码1234567891011121314151617181920212223242526272829// 登录提交地址和配置文件的登录url一致 @RequestMapping(value = "/login", method = RequestMethod.POST) public String login(HttpServletRequest request, Map&lt;String, Object&gt; map) throws Exception &#123; System.out.println("HomeController.login()"); // 登录失败从request中获取shiro处理的异常信息。 // shiroLoginFailure:就是shiro异常类的全类名. String exception = (String) request.getAttribute("shiroLoginFailure"); System.out.println("exception=" + exception); String msg = ""; if (exception != null) &#123; if (UnknownAccountException.class.getName().equals(exception)) &#123; System.out.println("UnknownAccountException -- &gt; 账号不存在："); msg = "UnknownAccountException -- &gt; 账号不存在："; &#125; else if (IncorrectCredentialsException.class.getName().equals(exception)) &#123; System.out.println("IncorrectCredentialsException -- &gt; 密码不正确："); msg = "IncorrectCredentialsException -- &gt; 密码不正确："; &#125; else if ("kaptchaValidateFailed".equals(exception)) &#123; System.out.println("kaptchaValidateFailed -- &gt; 验证码错误"); msg = "kaptchaValidateFailed -- &gt; 验证码错误"; &#125; else &#123; msg = "else &gt;&gt; " + exception; System.out.println("else -- &gt;" + exception); &#125; &#125; map.put("msg", msg); // 此方法不处理登录成功,由shiro进行处理. return "/login"; &#125; 5.没有权限页面跳转​ 新建全局异常类123456789@ControllerAdvicepublic class ExceptionHandle &#123; @ExceptionHandler(value = UnauthorizedException.class) // 处理访问方法时权限不足问题 @ResponseBody public String handle(Exception e) &#123; return "&lt;script&gt;alert('没有权限访问！');window.history.back();&lt;/script&gt;"; &#125;&#125; 四、其他1.获取密文：1Object obj = new SimpleHash("md5", user.getPassword(), ByteSource.Util.bytes(user.getSalt()) , 2); //获取MD5加密后的密文 2是加密次数 2.错误页面处理​ 新建error文件夹，404，500错误会自动找到该页面 ​ springBoot错误，也可以新建error.html视图，也会自动找该页面 3.为什么要用盐​ 希望即使两个原始密码相同，加密得到的两个字符串也不同。 4.前端怎么传值过来​ 表单中的参数固定name写法是username、password、rememberMe。]]></content>
      <categories>
        <category>安全认证框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis多对一、多对多注解方式实现]]></title>
    <url>%2F2018%2F01%2F07%2FMyBatis%E5%A4%9A%E5%AF%B9%E4%B8%80%E3%80%81%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[用户和角色多对多，角色和权限多对多。用户表、角色表、权限表、加两个中间表。 不用多说，直接上代码用户表：123456789public interface UserMapper &#123; @Select("select * from `user` where username=#&#123;name&#125;") @Results(&#123;@Result(id=true,property="id",column="id"), @Result(property="name",column="name"), @Result(property="type",column="type"), @Result(property="roles",column="id",javaType=List.class, many=@Many(select="com.gjd.dao.RoleMapper.queryById"))&#125;) User queryByName(String name);&#125; 角色表：1234567891011public interface RoleMapper &#123; @Select("select * from `role` r,`user_role` u where u.rid=r.id and u.uid=#&#123;id&#125;") @Results(&#123;@Result(id=true,property="id",column="id"), @Result(property="name",column="name"), @Result(property="permission",column="permission"), @Result(property="resourceType",column="resourceType"), @Result(property="url",column="url"), @Result(property="permissions",column="id",javaType=List.class, many=@Many(select="com.gjd.dao.PermissionMapper.queryById"))&#125;) List&lt;Role&gt; queryById(long id);&#125; 权限表：1234public interface PermissionMapper &#123; @Select("select * from `role_permission` r,`permission` p where r.rid=#&#123;id&#125; and r.pid=p.id") List&lt;Permission&gt; queryById(long id);&#125; 一对多、多对一把many=@Many替换成one=@One就好了。]]></content>
      <categories>
        <category>JAVA框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2017%2F12%2F30%2Fredis%2F</url>
    <content type="text"><![CDATA[安装、启动安装 源码1 安装步骤第一步：安装gcc编译环境 yum install gcc-c++第二步：把redis的源码上传到linux服务器。第三步：解压缩。 tar -zxvf redis-3.0.0.tar.gz第四步：make第五步：make install PREFIX=/usr/local/redis yum 安装yum install redis -y 启动启动redis两种启动方式，前端启动、后台启动。前端启动：./redis-server后台启动：1、复制redis.conf到redis的安装目录2、修改redis.conf。修改daemonize yes3、[root@bogon redis]# ./redis-server redis.conf centos: service redis start/stop/restart客户端redis-cli -p 端口 -h ip地址 &lt;-c&gt;连接集群时使用此参数默认端口：6379Ip：localhost（127.0.0.1） 常用命令1 PING 命令，该命令用于检测 redis 服务是否启动。 2 $ redis-cli -h host -p port -a password 在远程 redis 服务上执行命令，同样我们使用的也是 redis-cli 命令。 3 设值：set key value 取值：get key 删除：del key 4 DUMP key DUMP 命令用于序列化给定 key ，并返回被序列化的值。 5 exists key EXISTS 命令用于检查给定 key 是否存在。 6 expire key 60 为 key 设置过期时间 7 expireat key 1293840000 Redis Expireat 命令用于以 UNIX 时间戳(unix timestamp)格式设置 key 的过期时间。key 过期后将不再可用。 8 pexpireat key 1555555555005 PEXPIREAT 命令用于设置 key 的过期时间，以毫秒计。key 过期后将不再可用。 9 keys s* Keys 命令用于查找所有符合给定模式 pattern 的 key 。。 10 select 1 (数据库编号) 切换数据库 11 move key 1 MOVE 命令用于将当前数据库的 key 移动到给定的数据库 1 当中。 12 ttl key TTL 命令以秒为单位返回 key 的剩余过期时间。 13 persist key PERSIST 命令用于移除给定 key 的过期时间，使得 key 永不过期。 14 pttl key Pttl 命令以毫秒为单位返回 key 的剩余过期时间。 15 randomkey RANDOMKEY 命令从当前数据库中随机返回一个 key 。 16 flushdb 删除当前数据库所有 key 17 rename key newkey Rename 命令用于修改 key 的名称 。(newkey 已存在时， RENAME 会覆盖旧 newkey) 18 renamenx key newkey Renamenx 命令用于在新的 key 不存在时修改 key 的名称 。 19 type key Type 命令用于返回 key 所储存的值的类型。 字符串处理：1 getrange key start end Getrange 命令用于获取存储在指定 key 中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。 0 -1 表示获取所有 2 getset key “value” Getset 命令用于设置指定 key 的新值，并返回 key 旧的值。 3 setbit key offset o/get bit key offset 4 mget key1 key2 … Mget 命令返回所有(一个或多个)给定 key 的值。 没有返回空 5 setex key 30 “value” Setex 命令为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。 6 setnx key “value” Setnx（SET if Not eXists） 命令在指定的 key 不存在时，为 key 设置指定的值。 7 setrange key 5 “value” Setrange 命令用指定的字符串覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始。 8 strlen key Strlen 命令用于获取指定 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误。 9 mset key1 “va1” key2 “va2” Mset 命令用于同时设置一个或多个 key-value 对。 10 msetnx key1 “va1” key2 “va2” Msetnx 命令用于所有给定 key 都不存在时，同时设置一个或多个 key-value 对。 11 psetex key 1000 “value” Psetex 命令以毫秒为单位设置 key 的生存时间。 12 incr key Incr 命令将 key 中储存的数字值增一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。 13 incrby key 30 Incrby 命令将 key 中储存的数字加上指定的增量值。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。 14 incrybyfloat key 1.2 Incrbyfloat 命令为 key 中所储存的值加上指定的浮点数增量值。 15 decr key Decr 命令将 key 中储存的数字值减一。 16 decrby key 20 Decrby 命令将 key 所储存的值减去指定的减量值。 17 append key “value” Append 命令用于为指定的 key 追加值。 redis.conf 配置项说明1.Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no2.当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid3.指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 63794.绑定的主机地址 bind 127.0.0.15.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 3006.指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose7.日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout8.设置数据库的数量，默认数据库为0，可以使用SELECT命令在连接上指定数据库id databases 169.指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。10.指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes11.指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb12.指定本地数据库存放目录 dir ./13.设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof 14.当master服务设置了密码保护时，slav服务连接master的密码 masterauth 15.设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭 requirepass foobared16.设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 12817.指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory 18.指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no appendonly no19.指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof20.指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec21.指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no22.虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap23.将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 024.Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 3225.设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 13421772826.设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 427.设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes28.指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 51229.指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes30.指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf 查看CONFIG GET CONFIG_SETTING_NAME例如：CONFIG GET loglevel查看所有：config get * 修改CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE例如：CONFIG SET loglevel “notice” 高级操作数据备份与恢复1 save 备份 2 config get dir 获取 redis 安装目录 恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。 3 bgsave 后台执行 备份 安全1 config get requirepass 查看密码(默认密码为空) 2 config set requirepass “password” 设置密码 3 auth password Auth 命令用于检测给定的密码和配置文件中的密码是否相符。 4 ping 查看服务是否运行 reids 性能测试1 redis-benchmark [option] [option value]-h 指定服务器主机名 127.0.0.1-p 指定服务器端口 6379-s 指定服务器 socket-c 指定并发连接数 50-n 指定请求数 10000-d 以字节的形式指定 SET/GET 值的数据大小 2-k 1=keep alive 0=reconnect 1-r SET/GET/INCR 使用随机 key, SADD 使用随机值-P 通过管道传输 请求 1-q 强制退出 redis。仅显示 query/sec 值–csv 以 CSV 格式输出-l 生成循环，永久执行测试-t 仅运行以逗号分隔的测试命令列表。-I Idle 模式。仅打开 N 个 idle 连接并等待。 例如：redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -q Redis 客户端连接 1 redis-server –maxclients 100000 设置最大连接数为 100000 2 config get maxclients 查看最大连接数 3 client setname 设置当前连接的名称 4 client pause 10 挂起客户端连接，指定挂起的时间以毫秒计 5 client kill 关闭客户端连接 数据类型一、基本命令启动：$ redis-serve进入客户端测试：redis-cli设值：set key value取值：get key二、数据类型1.String(字符串)2.Hash(哈希) 设值：hmset user:1 v1 v2 v3 v4 v5 200.. //貌似最后一个必须为数字？ 取值：hmgetall user:13.List(列表) Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 设置：lpush key value lpush key value2 lpush key value3 …. 取值：lrange key 0 104.Set(集合) 添加一个string元素到,key对应的set集合中，成功返回1,如果元素已经在集合中返回0,key对应的set不存在返回错误。 设值：sadd key value sadd key value2 sadd key value3 sadd key value (该value已经在集合中存在，故应返回0) 根据集合内元素的唯一性，第二次插入的元素将被忽略。 取值：smembers key5.zset(sorted set：有序集合) Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型 的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。 设值：(zadd key score member) zadd key 0 value zadd key 1 value2 取值：zrangebyscore key 0 1000]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js常用和AJAX]]></title>
    <url>%2F2017%2F12%2F30%2Fjs%E5%92%8CJQuery%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[JS项目常用 判断数据类型typeof(s) 字符串：&quot;string&quot;，数字：&quot;number&quot;； 找指定的子标签单个：$(order).find(&quot;i&quot;);多个：$(order).find(&quot;i&quot;).each (function(i,data) ....)； 遍历指定class 元素$(&quot;.capital-order&quot;).each(function(i, data) {...} DOM获取value和namedata.value data.name jquery获取value和name$().val() ；$().attr(&quot;name&quot;) jquery中attr和prop的区别对应DOM中attribute()和properties() attr获取的是原始的值，prop是结果，比如checked、selected、disabled attr获取到的是里面的值，而prop是true或者false 设置标签属性的值$().attr(&quot;key&quot;,&quot;value&quot;); 修改css的值$(&quot;&quot;).css(&quot;key&quot;,&quot;value&quot;);dom.style.${css名称} 获取/设置标签内容$(&quot;&quot;).html(&quot;&quot;);$(&quot;&quot;).text()dom.innerHTML dom.innerText 四舍五入Number(数值).toFixed(2) 转intparseInt(s) 跳转页面window.location.href=url; 追加append(text); 找出其他同类元素，除了自己$(&quot;&quot;).siblings() 把from里的有name标签的封装成对象$(&quot;form表单&quot;).serialize() 判断标签是否存在某个class$(i).hasClass(&quot;c-red&quot;) 隐藏光标，设置字体为红色text-shadow:0 0 0 red;color:transparent; 触发按钮事件$(&quot;#close&quot;).trigger(&quot;click&quot;); 显示/隐藏切换jq：$(&quot;p&quot;).hide(); $(&quot;p&quot;).show();js：ui.style.display=&quot;none&quot;; ui.style.display=&quot;&quot;;其他：ui.style.visibility= &quot;visible/hidden&quot;; 查询父标签$(&#39;#items1&#39;).closest(&#39;.parent1&#39;);$(&#39;#items1&#39;).parents(&#39;.parent1&#39;); 点击事件$(&quot;#strategy&quot;).trigger(&quot;click&quot;); 添加/删除class$(&quot;#&quot;).addClass();$(&quot;#&quot;).removeClass(); AJAX js原生方式： 创建XMLHttpRequest对象 12345if (window.ActiveXObject) &#123; req = new ActiveXObject("Microsoft.XMLHTTP");&#125; else &#123; req = new XMLHttpRequest();&#125; 与服务器建立连 1234//method:get|post url:服务器相对或绝对路径 asynch:true|false 默认为true;req.open("post", "user",true);//Post提交方式需要设置Request头部信息req.setRequestHeader("Content-type","application/x-www-form-urlencoded"); 发送请求 1req.send("name=" + name + "&amp;pwd=" + pwd); 设置回调函数 ​ 123456//readyState 0未初始化 1正在加载 2已加载 3交互中 4响应完成 req.onreadystatechange = function() &#123; if (req.readyState == 4 &amp;&amp; req.status == 200) &#123; var text = req.responseText; &#125;&#125; JQuery方式方式1：12345678910111213141516$.ajax(&#123; type:"get", //请求类型get/post url:"goods", //待载入页面的URL地址 data:&#123;"uId":v&#125;, //待发送 Key/value 参数。 dataType:"json", //数据类型 error:function(data)&#123; alert("出现错误"+data); &#125;, success:function(data,status)&#123; //alert("调用成功"); &#125;, beforeSend:function(req)&#123; //alert("发送之前"); &#125; &#125;); 方式2：1234567$.get(url, [data], [callback], [type]);//$.post()同上//url:待载入页面的URL地址//data:待发送 Key/value 参数。//callback:载入成功时回调函数。//timeout:超时时间//type:返回内容格式，xml, html, script, json, text, _default。 方式3：123$.getJSON(url).done(function(data)&#123; alert('请求成功！json数据：'+data);&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb]]></title>
    <url>%2F2017%2F01%2F16%2Fjavaweb%2F</url>
    <content type="text"><![CDATA[ServletTomcat：Web 应用服务器，属于轻量级应用服务器，也叫Servlet容器 1. 生命周期生命周期方法： void init(ServletConfig)：出生之后（1次）； void service(ServletRequest request, ServletResponse response)：每次处理请求时都会被调用； void destroy()：临死之前（1次）； 特性： 单例，一个类只有一个对象；当然可能存在多个Servlet类！ 2. 实现Servlet的方式实现Servlet有三种方式： 实现javax.servlet.Servlet接口； 继承javax.servlet.GenericServlet类； 继承javax.servlet.http.HttpServlet类； 通常我们会去继承HttpServlet类来完成我们的Servlet 3. 常用方法1. HttpServletRequest方法： String getParameter(String paramName)：获取指定请求参数的值； String getMethod()：获取请求方法，例如GET或POST； String getHeader(String name)：获取指定请求头的值； void setCharacterEncoding(String encoding)：设置请求体的编码！因为GET请求没有请求体，所以这个方法只只对POST请求有效。当调用request.setCharacterEncoding(“utf-8”)之后，再通过getParameter()方法获取参数值时，那么参数值都已经通过了转码，即转换成了UTF-8编码。所以，这个方法必须在调用getParameter()方法之前调用！ request.getRequestDispatcher(“/ServletTest”).forward(request,response)：转发 2. HttpServletResponse方法： PrintWriter getWriter()：获取字符响应流，使用该流可以向客户端输出响应信息。例如response.getWriter(). print(“&lt;h1&gt;Hello JavaWeb!&lt;/h1&gt;”)； ServletOutputStream getOutputStream()：获取字节响应流，当需要向客户端响应字节数据时，需要使用这个流，例如要向客户端响应图片； void setCharacterEncoding(String encoding) ：用来设置字符响应流的编码，例如在调用setCharacterEncoding(“utf-8”);之后，再response.getWriter()获取字符响应流对象，这时的响应流的编码为utf-8，使用response.getWriter()输出的中文都会转换成utf-8编码后发送给客户端； void setHeader(String name, String value) ：向客户端添加响应头信息，例如setHeader(“Refresh”, “3;url=http://www.itcast.cn”)，表示3秒后自动刷新到http://www.itcast.cn； void setContentType(String contentType) ：该方法是setHeader(“content-type”, “xxx”)的简便方法，即用来添加名为content-type响应头的方法。content-type响应头用来设置响应数据的MIME类型，例如要向客户端响应jpg的图片，那么可以setContentType(“image/jepg”)，如果响应数据为文本类型，那么还要台同时设置编码，例如setContentType(“text/html;chartset=utf-8”)表示响应数据类型为文本类型中的html类型，并且该方法会调用setCharacterEncoding(“utf-8”)方法； void sendError(int code, String errorMsg) ：向客户端发送状态码，以及错误消息。例如给客户端发送404：response(404, “您要查找的资源不存在！”)。 response.sendRedirect(“http:…..”)：重定向某个地址3. ServletConfig方法：ServletConfig对象是由服务器创建的，然后传递给Servlet的init()方法，你可以在init()方法中使用它 String getServletName() ：获取Servlet在web.xml文件中的配置名称，即&lt;servlet-name&gt;指定的名称； ServletContext getServletContext() ：用来获取ServletContext对象。 String getInitParameter(String name) ：用来获取在web.xml中配置的初始化参数，通过参数名来获取参数值； Enumeration getInitParameterNames() ：用来获取在web.xml中配置的所有初始化参数名称；在元素中还可以配置初始化参数： 4. Servlet与线程安全因为一个类型的Servlet只有一个实例对象，那么就有可能会现时出一个Servlet同时处理多个请求，那么Servlet是否为线程安全的呢？答案是：“不是线程安全的”。这说明Servlet的工作效率很高，但也存在线程安全问题！所以我们不应该在Servlet中便宜创建成员变量，因为可能会存在一个线程对这个成员变量进行写操作，另一个线程对这个成员变量进行读操作。 5. ServletContext概述服务器会为每个应用创建一个ServletContext对象： ServletContext对象的创建是在服务器启动时完成的； ServletContext对象的销毁是在服务器关闭时完成的。 ServletContext是JavaWeb四大域对象之一： PageContext； ServletRequest； HttpSession； ServletContext；所有域对象都有存取数据的功能，因为域对象内部有一个Map，用来存储数据setAttribute()、getAttribute()、removeAttribute() 6. 请求转发与重定向比较 请求转发是一个请求，而重定向是两个请求； 请求转发后浏览器地址栏不会有变化，而重定向会有变化，因为重定向是两个请求； 请求转发的目标只能是本应用中的资源，重定向的目标可以是其他应用； 请求转发对AServlet和BServlet的请求方法是相同的，即要么都是GET，要么都是POST，因为请求转发是一个请求； 重定向的第二个请求一定是GET； 6. 其他配置servlet初始化时间 &lt;load-on-startup&gt;3&lt;/load-on-startup&gt; 通配符使用 &lt;url-pattern&gt;/servlet/*&lt;url-patter&gt;：/servlet/a、/servlet/b，都匹配/servlet/*； &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;：/abc/def/ghi.do、/a.do，都匹配*.do； &lt;url-pattern&gt;/*&lt;url-pattern&gt;：匹配所有URL； 配置默认参数1234&lt;context-param&gt;&lt;param-name&gt;paramName1&lt;/param-name&gt;&lt;param-value&gt;paramValue1&lt;/param-value&gt; &lt;/context-param&gt; 获取值：this.getServletContext(). getInitParameter(&quot;paramName1&quot;); 获取真实路径servletContext.getRealPath(“/WEB-INF/b.txt”)； 读文件InputStream in = servletContext. getResourceAsStream(“/WEB-INF/b.txt”)； Class类的getResourceAsStream(String path) 路径以“/”开头，相对classes路径； 路径不以“/”开头，相对当前class文件所有路径，例如在cn.itcast.servlet.MyServlet中执行，那么相对/classes/cn/itcast/servlet/路径； ClassLoader类的getResourceAsStream(String path) 相对classes路径； get请求乱码name = new String(name.getBytes(“iso-8859-1”), “utf-8”); post乱码request.setCharacterEncoding(“utf-8”); String name = request.getParameter(“name”); JSPjsp其实就是一个servlet，jsp第一次被请求的时候，会编译成class文件，然后再去执行servlet 1. JSP脚本 &lt;%…%&gt;：Java语句； &lt;%=…%&gt;：Java表达式； &lt;%!…%&gt;：Java定义类成员；其中&lt;%=…%&gt;与out.print()功能是相同的！它们都是向客户端输出，例如：&lt;%=s1%&gt;等同于&lt;% out.print(s1); %&gt; 2. JSP指令JSP中有三大指令：page、include、taglib，page最常用。page指令1&lt;%@page language=”java” contenType=”text/html;charset=gb2312” session=”true” buffer=”64kb” autoFlush=”true” isThreadSafe=”true” info=”text” errorPage=”error.jsp” isErrorPage=”true” isELIgnored=”true” pageEncoding=”gb2312” import=”java.sql.*”%&gt; web.xml也可以配置错误页面12345678910111213141516&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error404.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt;&lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error500.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt;&lt;exception-type&gt;java.lang.RuntimeException&lt;/exception-type&gt; &lt;location&gt;/error.jsp&lt;/location&gt; &lt;/error-page&gt; 其他指令&lt;%@include file=&quot;filename.jsp&quot;%&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 九大内置对象 out（JspWriter）：等同与response.getWriter()，用来向客户端发送文本数据； config（ServletConfig）：对应“真身”中的ServletConfig； page（当前JSP的真身类型）：当前JSP页面的“this”，即当前对象； pageContext（PageContext）：页面上下文对象。 exception（Throwable）：只有在错误页面中可以使用这个对象； request（HttpServletRequest）：即HttpServletRequest类的对象； response（HttpServletResponse）：即HttpServletResponse类的对象； application（ServletContext）：即ServletContext类的对象； session（HttpSession）：即HttpSession类的对象，不是每个JSP页面中都可以使用，如果在某个JSP页面中设置&lt;%@page session=”false”%&gt;，说明这个页面不能使用session。 JSP动作标签 include指令是在编译级别完成的包含，即把当前JSP和被包含的JSP合并成一个JSP，然后再编译成一个Servlet。include动作标签是在运行级别完成的包含，即当前JSP和被包含的JSP都会各自生成Servlet，然后在执行当前JSP的Servlet时完成包含另一个JSP的Servlet。它与RequestDispatcher的include()方法是相同的！ forward标签的作用是请求转发！forward标签的作用与RequestDispatcher.forward()方法相同 123&lt;jsp:include page="/b.jsp"&gt; &lt;jsp:param value="zhangSan" name="username"/&gt; &lt;/jsp:include&gt; EL表达式判断字符串长度是否为0或者集合为0${empty “”}集合对象：${map.key}、${map[‘key’]} 内置对象访问 pageScope：${pageScope.name}等同与pageContext.getAttribute(“name”)； requestScope：${requestScope.name}等同与request.getAttribute(“name”)； sessionScoep： ${sessionScope.name}等同与session.getAttribute(“name”)； applicationScope：${applicationScope.name}等同与application.getAttribute(“name”)； 其他对象 ${header.Host} ${initParam.par} //获取web.xml配的参数 ${cookie.} ${pageContext.servletContext.serverInfo} ${pageContext.session.id} ${pageContext.request.requestURL} JSTL表达式 out和set&lt;c:out value=”${aaa}” default=”xxx”/&gt; 等于${aaa}c:set var=”a” value=”hello” scope=”session”/&gt; 在session中添加name为a，value为hello的数据。 remove&lt;c:remove var=&quot;a&quot;/&gt; 删除所有域中name为a的数据！也可以指定：scope=”page” urlc:url value=&quot;/&quot;/&gt; 输入当前项目路径 如：test/ if 1234&lt;c:set var="a" value="hello"/&gt;&lt;c:if test="$&#123;not empty a &#125;"&gt; &lt;c:out value="$&#123;a &#125;"/&gt;&lt;/c:if&gt; choose 1234567&lt;c:set var="score" value="$&#123;param.score &#125;"/&gt;&lt;c:choose&gt; &lt;c:when test="$&#123;score &gt; 100 || score &lt; 0&#125;"&gt;错误的分数：$&#123;score &#125;&lt;/c:when&gt; &lt;c:when test="$&#123;score &gt;= 90 &#125;"&gt;A级&lt;/c:when&gt; &lt;c:when test="$&#123;score &gt;= 60 &#125;"&gt;D级&lt;/c:when&gt; &lt;c:otherwise&gt;E级&lt;/c:otherwise&gt;&lt;/c:choose&gt; forEach 1234&lt;c:set var="sum" value="0" /&gt;&lt;c:forEach var="i" begin="1" end="10" step="2"&gt; &lt;c:set var="sum" value="$&#123;sum + i&#125;" /&gt;&lt;/c:forEach&gt; 123&lt;c:forEach var="item" items="$&#123;ns &#125;"&gt; &lt;c:out value="name: $&#123;item &#125;"/&gt;&lt;br/&gt;&lt;/c:forEach&gt; 1234567&lt;c:forEach var="item" items="$&#123;ns &#125;" varStatus="vs"&gt; &lt;c:if test="$&#123;vs.first &#125;"&gt;第一行：&lt;/c:if&gt; &lt;c:if test="$&#123;vs.last &#125;"&gt;最后一行：&lt;/c:if&gt; &lt;c:out value="第$&#123;vs.count &#125;行: "/&gt; &lt;c:out value="[$&#123;vs.index &#125;]: "/&gt; &lt;c:out value="name: $&#123;vs.current &#125;"/&gt;&lt;br/&gt;&lt;/c:forEach&gt; count：int类型，当前以遍历元素的个数； index：int类型，当前元素的下标； first：boolean类型，是否为第一个元素； last：boolean类型，是否为最后一个元素； current：Object类型，表示当前项目。fmt标签库常用标签&lt;fmt:formatDate value=&quot;${d }&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;fmt:formatNumber value=&quot;${d2 }&quot; pattern=&quot;#.##&quot;/&gt;&lt;fmt:formatNumber value=&quot;${d1 }&quot; pattern=&quot;0.00&quot;/&gt; 其他在请求url后加上sessionId&lt;%=response.encodeURL (&quot;/test/index.jsp&quot;) %&gt; href=&#39;/test/index.jsp;jsessionid=&lt;%=session.getId() %&gt;&#39; JDBC和数据库1. JDBC六大步骤 加载驱动类 Class.forName (&quot;oracle.jdbc.OracleDriver&quot;); 建立连接 Connection conn = DriverManager. getConnection(url,name,password); 创建statement Statement state = conn.createStatement(); 执行SQL语句 String sql = &quot;select id,name from s_emp&quot;; ResultSet rs = state.executeQuery(sql); 处理结果集 123456while(rs.next())&#123; int id = rs.getInt(&quot;id&quot;); String name = rs.getString(2); System.out.println(id+&quot; &quot;+name); &#125; 关闭连接rs.close(); state.close(); conn.close(); PreparedStatement与Statement区别PreparedStatement叫预编译声明！PreparedStatement是Statement的子接口，你可以使用PreparedStatement来替换Statement。PreparedStatement的好处： 防止SQL攻击； 提高代码的可读性，以可维护性； 提高效率。 预处理的原理每个pstmt都与一个sql模板绑定在一起，先把sql模板给数据库，数据库先进行校验，再进行编译。执行时只是把参数传递过去而已！若二次执行时，就不用再次校验语法，也不用再次编译！直接执行！ JDBC中的事务Connection的三个方法与事务相关： setAutoCommit(boolean)：设置是否为自动提交事务，如果true（默认值就是true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，如果设置false，那么就相当于开启了事务了；con.setAutoCommit(false)表示开启事务！ commit()：提交结束事务; rollback()：回滚结束事务。 2. 事务事务的四大特性是： 原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。 一致性（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。 隔离性（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。 持久性（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据。 开启事务：start transaction；结束事务：commit或rollback。 事务的并发读问题 脏读：读取到另一个事务未提交数据； 不可重复读：两次读取不一致(读取到了另一事务的更新；) 幻读（虚读）：读到另一事务已提交数据。 四大隔离级别 SERIALIZABLE（串行化） 不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的； 性能最差；三种问题都能处理 REPEATABLE READ（可重复读）（MySQL） 防止脏读和不可重复读，不能处理幻读问题； 性能比SERIALIZABLE好 READ COMMITTED（读已提交数据）（Oracle） 防止脏读，没有处理不可重复读，也没有处理幻读； 性能比REPEATABLE READ好 READ UNCOMMITTED（读未提交数据） 可能出现任何事务并发问题 性能最好 MySQL的默认隔离级别为REPEATABLE READ。 3. 连接池4. 监听器、过滤器、拦截器 拦截器是基于java的反射机制的，而过滤器是基于函数回调 过滤器依赖与servlet容器，而拦截器不依赖与servlet容器 拦截器是AOP的一种实现 过滤器的生命周期 init(FilterConfig)：服务器启动创建Filter实例，并且每个类型的Filter只创建一个实例，创建完Filter实例后，这个方法只会被执行一次； doFilter(ServletRequest req,ServletResponse res,FilterChain chain)：这个方法会在用户每次访问就会执行。 destroy()：服务器会在创建Filter对象之后，把Filter放到缓存中一直使用，通常不会销毁它。一般会在服务器关闭时销毁Filter对象，在销毁Filter对象之前，服务器会调用Filter对象的destory()方法。配置过滤器拦截方式：REQUEST、FORWARD、INCLUDE、ERROR。123456&lt;filter-mapping&gt; &lt;filter-name&gt;myfilter&lt;/filter-name&gt; &lt;url-pattern&gt;/b.jsp&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt; &lt;/filter-mapping&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iconfont使用教程]]></title>
    <url>%2F2017%2F01%2F06%2F%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0icon%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[自己项目中用到了第三方登录的功能，来记录下怎么添加第三方登录的图标。 1.寻找合适的图标库我这里是用阿里的iconfont矢量图标，官方网址：http://www.iconfont.cn/ 2.添加图标，下载到本地，解压 这是解压后的目录： 3.将iconfont.css导入到你的css文件。把url中的文件拷贝到CSS能访问到的路径 4.html代码中直接引用&lt;i class=&quot;iconfont icon-qq1&quot;&gt;&lt;/i&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>icon图标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH框架]]></title>
    <url>%2F2016%2F12%2F30%2FSSH%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[web.xml配置1. spring启动方式三种方式： 本地文件ApplicationContext ac = new FileSystemXmlApplicationContext (“applicationContext.xml”); ClasspathApplicationContext ctx = new ClassPathXmlApplicationContext (“ApplicationContext.xml”); Web应用中依赖servlet或Listener （1）利用Listener接口来实现 （2）利用Servlet接口来实现 （1）利用Listener接口来实现12345678910&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;!--&lt;param-value&gt;/WEB-INF/spring-context.xml&lt;/param-value&gt; --&gt;&lt;/context-param&gt; （2）利用Servlet接口来实现12345678910111213141516171819202122232425&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;Servlet&gt; &lt;servlet-name&gt;context&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; ``` ### 2. struts2配置```xml&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 配置文件1. hibernate.cfg.xml配置1234567891011121314151617181920212223242526&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 数据库驱动程序类 --&gt; &lt;property name="connection.driver_class"&gt;oracle.jdbc.OracleDriver&lt;/property&gt; &lt;!-- 数据库连接字符串 --&gt; &lt;property name="connection.url"&gt;jdbc:oracle:thin:@192.168.1.249:1522:oracle&lt;/property&gt; &lt;!-- 数据库用户名 --&gt; &lt;property name="connection.username"&gt;sc160501&lt;/property&gt; &lt;!-- 数据库密码 --&gt; &lt;property name="connection.password"&gt;sc160501&lt;/property&gt; &lt;!-- Hibernate 使用数据方言 --&gt; &lt;property name="dialect"&gt;org.hibernate.dialect.OracleDialect&lt;/property&gt; &lt;!-- 是否创建数据库表 create 每次启动都创建 update 如果数据库没有表就创建 validate 每次启动就校验数据库表和model是否匹配 create-drop 启动时创建，停止时删除 --&gt; &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 是否显示SQL语句 --&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;!-- 是否格式化SQL语句 --&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;mapping resource="com/gjd/model/User.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; hbm.xml映射文件12345678910111213141516171819202122232425262728293031323334353637&lt;hibernate-mapping package="com.hzcl.model"&gt; &lt;class name="User" table="t_user"&gt; &lt;id name="id" column="id" type="integer"&gt; &lt;generator class="sequence"&gt; &lt;param name="sequence"&gt; seq_t_user &lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; &lt;property name="name" column="user_name" type="string" /&gt; &lt;property name="pwd" column="pwd" type="string" /&gt; &lt;property name="createDate" column="create_date" type="date" not-null="false" /&gt; &lt;property name="sex" column="sex" length="2" type="string" not-null="false" /&gt; &lt;property name="imgSrc" column="img_src" type="string" not-null="false" /&gt; &lt;property name="loginTime" column="loginTime" type="date" /&gt; &lt;!-- 一对多 &lt;set name="comm" table="t_com" cascade="all" lazy="false"&gt; &lt;key column="tid"&gt;&lt;/key&gt; &lt;one-to-many class="Comment"/&gt; &lt;/set&gt; --&gt; &lt;!-- 多对一 &lt;many-to-one name="user" class="User" column="tid" lazy="false"&gt;&lt;/many-to-one&gt; --&gt; &lt;!-- 多对多 &lt;set name="projects" table="PROEMP"&gt; &lt;key column="RPROID"&gt;&lt;/key&gt; &lt;many-to-many class="Project" column="REMPID"&gt; &lt;/many-to-many&gt; &lt;/set&gt; --&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; User.hbm.xml常用配置 12345678910111213141516171819202122&lt;hibernate-mappingschema=&quot;schemaName&quot; //模式的名字catalog=&quot;catalogName&quot; //目录的名称default-cascade=&quot;cassade_style&quot; //级联风格 @default-access=&quot;field/property/CalssName&quot; //访问策略 @default-lazy=&quot;true/false&quot; //加载策略 @package=&quot;packagename&quot; //默认包名/&gt;&lt;classname=&quot;ClassName&quot; //对应映射的类table=&quot;tableName&quot; //对应映射数据库的表batch-size=&quot;N&quot; //抓取策略，一次抓取多少记录where=&quot;condition&quot; //条件 eg:抓取条件entity-name=&quot;EntiyName&quot; //如果需要映射多张表/&gt;&lt;id //表的主键name=&quot;propertyName&quot; //对应的属性type=&quot;typeName&quot; //对应类型column=&quot;column_nam&quot; //映射数据库中表当中字段名的名称length=&quot;length&quot; //指定长度&lt;generator class=&quot;generatorClass&quot;/&gt; //主键生成策略 @/&gt; 关联操作 关联查询 1）延迟加载对于关联属性，Hibernate默认采用延迟记载的机制。 lazy=”true”：采用延迟记载（默认） lazy=”false”：不采用延迟加载2）采用连接查询 fetch=”select”不采用连接查询（默认） fetch=”join”采用连接查询，此时lazy属性失效 级联操作1）什么叫级联操作 在Hibernate里，在对一方进行增、删、改时要自动的对另一方也进行增、删、改，这样的行为称之为级联操作。2）如何实现级联添加、修改、删除在要操作的对象的映射关系文件中，在关联属性上追加cascade属性，用这个属性的值来指定级联方式：cascade=”none” 不支持级联（默认）cascade=”save-update” 支持级联添加、修改cascade=”delete” 支持级联删除cascade=”all” 支持级联添加、修改、删除//级联删除时，需要在配置文件的关联属性上追加inverse=”true”。 单一主键（1）assigned 由java应用程序负责生成（手工赋值）（2）native 由底层数据库自动生成标示符，如果是MySQL就是increment，如果是Oracle就是sequence，等等 2. applicationContext.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!-- 引入资源文件 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties" /&gt; &lt;!-- 配置druid连接池 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;!-- 数据库基本信息配置 --&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClass&#125;" /&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name="initialSize" value="1" /&gt; &lt;property name="minIdle" value="1" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;/bean&gt; &lt;!-- 配置Hibernate的相关属性 --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.OracleDialect&lt;/prop&gt; &lt;prop key="hibernate.hbm2ddl.auto"&gt;create&lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;prop key="hibernate.format_sql"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name="mappingResources"&gt; &lt;list&gt; &lt;value&gt;com/model/User.hbm.xml&lt;/value&gt; &lt;value&gt;com/model/News.hbm.xml&lt;/value&gt; &lt;value&gt;com/model/Comment.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器： --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 开启事务注解 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt; &lt;!-- 注入 dao --&gt; &lt;bean id="userDao" class="com.dao.UserDaoImpl"&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注入 service --&gt; &lt;bean id="userService" class="com.service.UserServiceImpl"&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注入 action --&gt; &lt;bean id="userAction" class="com.action.UserAction"&gt; &lt;property name="userService" ref="userService"&gt;&lt;/property&gt; &lt;/bean&gt; 3. struts.xml配置详解1234567891011121314151617181920212223242526272829303132333435363738394041&lt;struts&gt; &lt;!-- 让Spring 来创建Action对象 --&gt; &lt;constant name="struts.objectFactory" value="spring"/&gt; &lt;constant name="struts.action.extension" value="html,"&gt;&lt;/constant&gt; &lt;constant name="struts.custom.i18n.resources" value="message"&gt;&lt;/constant&gt; &lt;package name="user" extends="struts-default" namespace="/"&gt; &lt;interceptors&gt; &lt;interceptor name="login" class="com.interceptor.LoginInterceptor"/&gt; &lt;interceptor-stack name="myStack"&gt; &lt;interceptor-ref name="login"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;default-interceptor-ref name="myStack"&gt;&lt;/default-interceptor-ref&gt; &lt;global-results&gt; &lt;result name="error" type="redirect"&gt;/login.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name="user_*" class="userAction" method="&#123;1&#125;"&gt; &lt;result type="redirectAction"&gt;news_list&lt;/result&gt; &lt;result name="login"&gt;/login.jsp&lt;/result&gt; &lt;result name="info"&gt;/userInfo.jsp&lt;/result&gt; &lt;result name="logout"&gt;/login.jsp&lt;/result&gt; &lt;result name="input"&gt;/register.jsp&lt;/result&gt; &lt;result name="lang"&gt;/register.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="news_*" class="newsAction" method="&#123;1&#125;"&gt; &lt;result name="del" type="redirectAction"&gt;news_list&lt;/result&gt; &lt;result&gt;/news.jsp&lt;/result&gt; &lt;result name="modify"&gt;/addnews.jsp&lt;/result&gt; &lt;result name="new"&gt;/new.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="comm_*" class="commentAction" method="&#123;1&#125;"&gt; &lt;result name="newComm" type="chain"&gt;news_newCom&lt;/result&gt; &lt;/action&gt; &lt;action name="file" class="fileAction"&gt; &lt;result&gt;/login.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; struts.xml中包含的内容： 1、全局属性2、用户请求和相应Action之间的对应关系3、Action可能会用到的参数和返回结果4、各种拦截器的配置 配置详解 package提供了将多个Action组织成为一个模块的方式package的名字必须是唯一的，可以在这个包上加一些拓展的包 为拦截器可以为拦截器定义name(名称)和class（类路径） 拦截器栈 定义默认的拦截器，每个Action都会自动引用 包含其他配置文件 注意：1.被include的标签一定要符合struts的dtd规范。也就是说被include的xml文件的内部格式要符合struts的xml文件规范。2.xml文件的编码格式要相同，如果是utf-8，那么都是utf-8。配置编码： 工作原理： 用户的请求HttpServletRequest—&gt;过滤器filter—&gt;ActionMapper(.action)请求—-&gt;过滤器—-&gt;ActionProxy—-&gt;通过ConfigurationManager读取struts.xml中的ActionInvocation具体的Action类—-&gt;通过ActionProxy创建Action反向实例—-&gt;拦截器—&gt;action,返回result(字符串对象)对应的视图—-&gt;拦截器—-&gt;HttpServletResponse返回请求 action搜索顺序 例子：localhost:8080/product_one/hellowworld.jsp可以进入result.jsp页面localhost:8080/product_one/aaa/ddd/ccc/hellowworld.jsp也可以进入result.jsp页面Action搜索顺序：localhost:8080/struts2/path1/path2/path3/student.action第一步：判断package是否存在，如：path1/path2/path3/ 如果package存在第二步：则判断该package中action是否存在，如果不存在则去默认namespace的package里面寻找action第三步：如果没有，则报错 如果package不存在：第二步：检查上一级路径的package是否存在（直到默认namespace），重复第一步第三步：如果没有则报错 如果请求为/login.action，系统会根据根命名空间（”/“）中查找名为login的Action，如果在根命名空间中找到了名为login的Action，则该Action处理用户的请求；否则系统将转为在默认命名空间中寻找名为login的Action，如果默认的命名空间中有名为login的Action，则由该Action处理用户的请求。如果两个命名空间中都找不到名为login的Action，那么系统将出现错误。 注意：命名空间只有一个级别。如果请求的URL是/bookservice/search/get.action系统将先在/bookservice/search的命名空间下查找名为get的Action，如果在该系统命名空间内找到名为get的Action，则由该Action处理该用户的请求；如果在该命名空间中没有找到名为get的Action，系统将直接进入默认的命名空间中查找名为get的Action，而不会在bookservice的命名空间下查找名为get的Action。可以多个包使用同一个命名空间，但是相同的命名空间相当于同一个模块，也就是同一个包。一个包中可以有name值相同的action，但是后面的action会把前面同名的action覆盖掉 动态方法调用： 动态方法调用是为了解决一个Action对应多个请求的处理，以免Action太多。三种方式：指定method属性、感叹号方式、通配符方式（这种方式较方便） method属性 感叹号 123456&lt;constant name="struts.enable.DynamicMethodInvocation" value="true"&gt;&lt;/constant&gt;&lt;action name="hellowword" class="com.Action.hellowAction"&gt;&lt;result &gt;/result.jsp&lt;/result&gt;&lt;result name="add"&gt;/add.jsp&lt;/result&gt;&lt;result name="update"&gt;/update.jsp&lt;/result&gt;&lt;/action&gt; localhost:8080/struts_hellowworld/aaa/hellowworld!.action 通配符12345&lt;action name="*_*" method="&#123;2&#125;" class="com.Action.&#123;1&#125;Action"&gt;&lt;result &gt;/&#123;2&#125;.jsp&lt;/result&gt;&lt;result name="add"&gt;/&#123;2&#125;.jsp&lt;/result&gt;&lt;result name="update"&gt;/&#123;2&#125;.jsp&lt;/result&gt;&lt;/action&gt; localhost:8080/struts_hellowworld/aaa/hellow_add.action 默认的action 12345&lt;default-action-ref name="index"&gt;&lt;/default-action-ref&gt;&lt;action name="index"&gt;&lt;result&gt;/error.jsp&lt;/result&gt;&lt;br&gt;&lt;/action&gt; 结果类型input的效果 1.当参数类型转换错误时，如age输入框中的类型是字母等情况，方法自动返回input 2.当action中存在addFiledError时： 1）addFileError放在一般执行方法，addFieldError(“”, “”);语句后面有返回input的语句 2）addFileError放在validate()中*3.FileError的表现形式： 在jsp页面中使用标签，该标签name属性为addFieldError方法中的参数fieldName，在jsp页面中使用struts标签， 需要导入标签库 语句：&lt;%@ taglib prefix=”s” uri=”/struts-tags” %&gt; 【Structs2处理流程】 用户请求Structs框架控制器(Action)Structs框架视图资源返回String，提供代码复用性，有利于框架分离。【Action中五种内置属性(com.opensymphony.xwork2.Action)】(1) SUCCESS Action正确的执行完成，返回相应的视图，success是name属性的默认值。(2) NONE 表示Action正确的执行完成，但并不返回任何事视图。(3) ERROR 表示Action执行失效，返回错误处理视图。(4) LOGIN Action因为用户没有登录的原因没有正确执行，将返回该登录视图，要求用户进行登录验证(5) INPUT Action的执行，需要从前端界面获取参数，INPUT就是代表这个参数输入界面，一般在应用中，会对这些 参数进行验证，如果验证没有通过，将自动返回该视图。返回 1.在result里面最重要的属性是type类型，type的默认值为dispatcher（转发），这个类型支持JSP视图技术。2.Struts2支持多种视图技术，例如JSP、Valocity（模板引擎）、FreeMaker（模板引擎）等。3.常用三个：chain，redirect，plaintext。1）、chain：将action和另外一个action链接起来，必须是一个action不能是jsp页面。2）、redirect：重定向（会丢失请求参数）。3）、plaintext：返回网页源代码。4）、stream：返回inputstream用于文件下载。5）、默认”dispatcher” jsp传值 请求转发 客户端通过httpservletrequest向servlet容器,也就是tomcat提交一个请求,这个请求会经过一些列的过滤器,如ActionContentClearUp过滤器,最终被struts核心过滤器过滤,也就是FilterDispatcher.从struts2.1.3版本以后struts的核心控制器发生了变化,变成了PrepqreAndExecuteFiletr,核心过滤器过滤以后,调用访问ActionMapping,决定是否调用某一action,如果用户请求的是jsp页面或者是其他资源,不会调用某一action,如果决定调用某一action,ActionMapping会将控制权委派给ActionProxy,也叫action代理,此时action代理会通过一个Configuration Manager也就是配置管理器对象加载struts核心配置文件,也就是struts.xml.如果在struts.xml找到需要创建的action,ActionProxy会创建一个Action Invocation实例,action Invocation包括一些列的拦截器和action,先顺序执行一些列的拦截器,然后执行action处理,返回一个结果,通过result返回一个视图或者调用另外某个action.当返回这个视图以后,将之前执行过的拦截器反向执行一遍,然后通过response响应客户端的请求. 12345678&lt;!-- 注册拦截器 --&gt; &lt;interceptors&gt; &lt;interceptor name="auth" class="com.imooc.interceptor.AuthInterceptor"&gt; &lt;/interceptor&gt;&lt;!-- 引用拦截器 --&gt; &lt;interceptor-ref name="mytimer"&gt;&lt;/interceptor-ref&gt; 默认拦截器栈 在struts-default.xml中定义一个defaulStack拦截器栈,并将其指定为默认拦截器. 只要在定义包的过程中继承struts-default包,那么defaultStack将是默认的拦截器. 当为包中的某个action显式指定了某个拦截器,则默认拦截器不会起作用. 拦截器栈中的各个拦截器的顺序很重要. 引用默认的拦截器栈&lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt;在引用拦截器的时候一般先引用默认的拦截器。WEB-INF里的文件默认情况下是不允许被外部直接访问的，可以通过action间接来访问如果action的class不写，则默认是ActionSupport这个类 struts.xml 定义顺序 result-typesinterceptorsinterceptor-stackdefault-interceptor-ref 默认拦截器default-action-ref 默认actiondefault-class-ref Action默认处理的类global-results 全局返回global-exception-mappings 全局异常action 核心代码编写1. hibernate一级缓存 什么是一级缓存Hibernate在创建Session时，会给每一个Session分配一块内存空间，用于缓存Session查询到的对象数据，这块内存空间称之为一级缓存。由于该空间是给Session使用的，也称Session级缓存。重点： –一级缓存又称Session级缓存 –一级缓存是Session独享的 为什么用一级缓存1）作用： 一级缓存可以降低数据库访问次数，提高 代码执行效率。2）步骤： –Session取值时会优先向它的一级缓存取值 –如果缓存中没有数据，它会向数据库取值， 并将取到的值放入一级缓存，然后Session 从缓存中取出数据 –当再次查询相同的数据时，由于一级缓存中 已经存在了该数据，则直接返回，不需要重新 访问数据库 如何使用一级缓存 1）一级缓存是默认开启的，自动使用。 2）规则： --一级缓存是Session独享的，即一个Session 不能访问另一个Session缓存的数据。 --每次查询，Session仅仅是把本次查询结果 放到一级缓存中 --如果查询的结果是多条数据，Session会将 这些数据拆开，以单个对象的形式存入一级缓存。 --在执行save、update、delete时，会自动触发 缓存的更新。 3）一级缓存是给Session使用的，并且是由Session 负责管理，Session管理一级缓存的方式如下： a、session.evict(obj); evict可以将obj对象从当前session的缓存区 移除。 b、session.clear(); clear可以将当前session的缓存区清空。 c、session.close(); session关闭时，它会释放自己的缓存区域， 从而缓存数据也释放了。 二、对象持久性 1、Hibernate下，可以把对象看做具有3种状态，分别 为临时态、持久态、游离态，对象持久性是值对象 在这三种状态之间的转换规则。 2、3种状态的转换及规则 1）临时态 a、转换 –new出来的对象是临时态的 –delete持久态的对象，它将转变为临时态 b、规则 –临时态的对象可以被垃圾回收 –临时态的对象没有被持久化过， 并且没有与session建立关联。 2）持久态（） a、转换 –通过save/update操作过的对象， 是持久态的。 –经过get/load/list/iterate方法查询得到的 对象是持久态的。 b、规则 –持久态的对象不能被垃圾回收 –持久态的对象被持久化了，并且与 session建立起了关联。 –（）持久态的对象存在于一级缓存中。 –（*）持久态的对象可以自动与数据库同步， 同步的时机是在调用session.flush()时， 实际上事务提交时也可以同步，原因是 ts.comit() = session.flush() + commit; 3）游离态 a、转换 –通过evict/clear/close操作过的对象， 是游离态的。 b、规则 –游离态的对象可以被垃圾回收 –游离态的对象被持久化过， 但是已经与session解除了关联。 3、问题 当大批量插入数据时，每次插入都会导致对象存在 于一级缓存中，如果数据量太大，可能导致缓存 溢出，如何解决？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 public void batchDdd(List&lt;Emp&gt; emps) &#123; if(emps == null || emps.size() == 0) &#123; return; &#125; Session session = HibernateUtil.getSession(); Transaction ts = session.beginTransaction(); try &#123; for(int i=0;i&lt;emps.size();i++) &#123; //循环添加Emp session.save(emps.get(i)); //每100批次，要同步并清理缓存 if(i%100 == 0) &#123; //每隔100次触发同步，但不提交事务 session.flush(); //清理缓存 session.clear(); &#125; &#125; //统一的提交事务 ts.commit(); &#125; catch(HibernateException e) &#123; ts.rollback(); &#125; &#125;``` **三、延迟加载** 1、什么是延迟加载 Hibernate中存在一些查询方法，在查询时并没有 立刻访问数据库查询数据，而是返回了空对象（ 对象并不是null，而是经过new的对象，但对象中 除ID外其他属性都为null），当程序使用此对象 时，Hibernate才真正去查询数据库，将数据填充 到返回的对象中。这种将查询推迟到使用对象时的 机制，称之为延迟加载。 2、为什么用延迟加载 1）推迟的时间内，由于数据没有加载，可以节约 内存空间，可以提升内存使用率。 2）如果有对象查询后并没有使用，那么在延迟加载 的方法中实际上没有访问数据库，可以减少一定 数量的数据库访问次数。 3、如何使用延迟加载 1）有一些方法本身自动支持延迟加载，只要调用 这些方法就可以使用延迟加载。 2）具有延迟加载的方法如下 a、session.load() b、query.iterate() c、关联映射中的关联属性加载**四、二级缓存**1、什么是二级缓存，二级缓存就是SessionFactory缓存 比Session作用范围更广2、先查一级缓存，如果查询不到再查二级缓存，如果二级缓存也查询不到，就直接查数据库 查询到数据以后保持到一级缓存和二级缓存中 如果一级缓存查询不到数据 就从二级缓存中查询 一级缓存和二级缓存的区别 1、作用范围不一样一个属于session的一个属于sessionFactory 2、一级缓存默认开启 二级缓存必须手动开启 3、一级缓存数据缓存在内存中 二级缓存数据缓存在磁盘中 使用二级缓存步骤 1、导入ehcache.jar 2、编写ehcache.xml缓存配置文件 3、在hibernate.cfg.xml中开启二级缓存的支持 ```xml &lt;!-- 开启二级缓存 --&gt; &lt;property name="cache.use_second_level_cache"&gt; true&lt;/property&gt;&lt;!-- 配置二级缓存驱动类 --&gt;&lt;property name="cache.provider_class"&gt;org.hibernate.cache.EhCacheProvider&lt;/property&gt;&lt;!-- 开启查询缓存 --&gt;&lt;property name="cache.use_query_cache"&gt;true&lt;/property&gt; 4、开启二级缓存 持久化对象映射文件添加 持久层增删改查dao层继承 该类：HibernateDaoSupportthis.getHibernateTemplate().save(); //增删改查 2. struts获取request、response采用耦合IOC方式注入属性 三个接口ServletRequestAwareServletresponseAwareServletContextAwareServletSessionAwareActionContext struts2自己封装了Servlet的方法ServletActionContext 可以获取原生态的Servlet的方法表单验证方法validate() //支持表单验证的方法 国际化123456789101112国际化：第一步：struts.xml中加入&lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;message&quot;&gt;&lt;/constant&gt;第二步：在与struts.xml文件同目录下创建一下两个文件. message_en_US.properties(配置英文信息） message_zh_CN.properties(配置中文信息）切换：&lt;a href=&quot;changeLanguage.action?request_locale=zh_CN&quot; &gt;中文&lt;/a&gt;&lt;a href = &quot;changeLanguage.action?request_locale=en_US&quot;&gt;英文&lt;/a&gt;jsp中使用：(必须用ognl标签) &lt;s:text name=&quot;m_name&quot;/&gt; 新建拦截器的步骤 1 建立一个拦截器类继承自Abstractlnertceptor类，并实现inertcept方法。invocation.invoke()方法调用下一个拦截器，如果已经是最后一个拦截器，则执行目标action1234567891011public String intercept(ActionInvocation invoaction) throws Exception &#123; //1.执行action之前 long start = System.currentTimeMillis(); //2.执行下一个拦截器，如果已经是最后一个拦截器，则执行目标Action String result = invoaction.invoke(); //3.执行action之后 long end = System.currentTimeMillis(); System.out.println(end-start); return result; &#125; 自定义拦截器： 方法一：实现Interceptor接口-void init():初始化拦截器所需资源-void destroy() :释放在init（）中分配的资源-String intercept(ActionInvocation ai)throws Exception 实现拦截器功能，利用ActionInvocation参数获取Action状态，返回result字符串作为逻辑视图。 方式二：继承AbstractInterceptor类-提供了init()和destroy() 方法的空实现-只需要实现intercept方法即可 实际开发当中一般会去继承AbstractInterceptor这个父类 2 在strut的配置文件的package中注册拦截器，注册拦截器在action调用之前，在相应的action配置中个，通过intercepor-ref标签中来引用拦截器 接收参数 1，使用Action的属性接受参数，在Action中定义需要接受的属性，并写它的set/get方法。2，使用DomainModel接受参数，创建实体类定义需要接受的属性，并set/get方法，在Action中创建实体类名属性。并在界面进行指定。3，使用ModelDriver接受参数，在Action中实现ModelDriver&lt;实体类名&gt;接口，并实现方法返回当前需要转换的对象，删除set/get方法，并对 对象 进行实例化，并取消指定。4，request5，获取List集合中的参数。获取多个参数。 字段驱动方式第一种接收参数的方法：直接在action类中创建相应的属性和getter和setter，和前端的name名字相同。eg:前端的username，在action类中就要建立一个private String username; Struts会自动映射为这个属性赋值 模型驱动方式第二种接受参数的方法：使用DomainModel，将username 和password两个属性封装为一个类User（必须是标准的JavaBean），在action中声明这个属性：private User user; 同时为user设置getter和setter；在前端中的name需要设置为user.name和user.password,才能映射成功 第三种接收参数的方法：使用ModelDriven接口，这个action必须实现这个接口的public T getModel()方法。此时声明的属性必须实例化，eg: private User user = new User(); 同时不需要getter和setter。前端的name也只需要写username和password就可以，不需要再加域了。这种方法时最推荐的方法，因为可以减少前后端的耦合]]></content>
      <categories>
        <category>java框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么绑定域名]]></title>
    <url>%2F2016%2F07%2F11%2F%E6%80%8E%E4%B9%88%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[购买域名我是在godaddy上面买的，一个国外的网站，在国内买需要备案，所以选择国外，而且这个还支持支付宝。 1.查找你想要的域名 2.查到适合自己的域名选择，然后点击「continue to Cart」这里都是些附加的服务，不用管，继续点击「continue to Cart」 3.确认购买这里可以修改购买年限，我们还可以上网搜 godaddy 的优惠码，可以优惠一点点，土豪请忽略。 4.结算。登录或注册界面，填完必要的信息之后，选择用支付宝结算。 将域名与 GitHub Pages 的空间绑定1.DNS 设置注册DNSpod，添加域名，如下图设置。其中A的两条记录指向的ip地址是github Pages的提供的ip * 192.30.252.153 * 192.30.252.154 如博客不能登录，有可能是 github 更改了空间服务的 ip 地址，只需要修改即可。www 指定的记录是你在 github 注册的仓库。（gaojindeng.github.io.） 去 Godaddy 修改 DNS 地址将域名服务器更改成 f1g1ns1.dnspod.net 和 f1g1ns2.dnspod.net 过几分钟你就可以访问你的域名了。]]></content>
      <categories>
        <category>建站相关</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2016%2F07%2F09%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[创建版本库1.pwd 显示当前目录2.git init 把当前目录变成git可以管理的仓库 提交文件到仓库1.git add 文件名.后缀2.git commit -m “描述文字 注释”3.git status 查看文件是否提交4.git diff file 查看文件对比5.git log 查看git提交日志，git log --pretty=oneline 简化输出 版本回退和撤消1.git reset --hard HEAD^ 回退上一个版本2.git reset --hard HEAD^^回退上上一个版本3.git reset --hard HEAD~100 回退前100个版本4.git reflog 获取版本号5.git reset --hard 版本号 恢复这个版本6.git checkout -- file 丢弃工作区的修改7.git reset HEAD file 可以把暂存区的修改撤销掉，重新放回工作区 理解工作区与暂存区的区别？1.工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录 版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。2.版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本 库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我 们自动创建了第一个分支master,以及指向master的一个指针HEAD。 git add 就是把文件从工作区修改添加到暂存区； 远程仓库 SSH Keys1.ssh-keygen -t rsa -C &quot;503610326@qq.com&quot; 用户目录会多一个.ssh目 录。id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。2.登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”, 填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。 关联和提交文件到远程仓库1.登录github，创建一个与本地同名的仓库2.在本地仓库运行命令git remote add origin http://...远程仓库的地址3.本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送 到远程。4.git push -u origin master 第一次要加-u 然后输入用户名，密码5.git push origin master 以后每一次提交到服务器6.git remote -v查看远程库信息 如何从远程库克隆1.在github上创建一个仓库2.本地 git clone https://...仓库名 本地就会生成目录了 管理分支1.git checkout -b dev 创建并切换分支 也可以分两步：git branch dev+git checkout dev2.git branch 查看当前分支3.git merge dev 合并分支 指定分支合并到当前分支4.git branch -d name 删除分支5.git merge --no-ff -m &quot;描述&quot; dev 用普通模式合并，合并后的历史有分支，能看出来曾经做过合并。6.git stash 隐藏分支7.git stash list 查看隐藏分支8.git stash apply 恢复隐藏分支 但不会删除 git stash drop 删除隐藏分支9.git stash pop 恢复隐藏分支并且删除10.git branch -D &lt;name&gt; 删除没有合并的分支11.git push origin branch-name 把本地分支推送到远程仓库12.推送失败，git pull origin branch-name拉去远程分支与本地合并，解决分支，继续提交13.git checkout -b dev origin/dev 在本地创建和远程分支对应的分支 分支管理策略1.git merge -no-ff -m &quot;注释&quot; dev 合并dev分支 保留dev分支信息(删除该分 区信息还可以查看到)2.分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发 布，或者说dev分支代码稳定后可以合并到主分支master上来。 Bug分支1.每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分 支删除掉。2.git stash 将当前的工作现场隐藏起来 等Bug分区修复好BUG。3.git stash list查看4.git stash apply恢复git stash drop 删除stash内容5.git stash pop回复并删除stash内容 多人协作1.当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支 对应起来了，并且远程库的默认名称是origin。2.git remote 查看远程库的信息 -v 查看详细信息3.git push origin master 推送到远程的分支上去4.一般是主分支推送到远程的]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用hexo在github上搭建免费个人博客]]></title>
    <url>%2F2016%2F07%2F09%2F%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[GitHub首先登陆GitHub网站，在github上建立一个repository，名字必须为xxx.github.io，xxx为你的账户名，如下图所示 安装软件依次下载并安装下面两个软件，一直点击下一步即可： Node.js Git 配置 SSH keys我们用SSH keys让本地git项目与远程的github建立联系,请看我博客git命令教程 Hexo在本地新建一个文件夹来存放hexo项目，进入该文件夹右击打开Git Bash here安装命令：1npm i -g hexo 初始化hexo:1hexo init 安装插件：1hexo install 1npm install --save hexo-deployer-git 安装后会出现以下目录：然后生成web项目：1hexo g 启动服务器预览效果(http://localhost:4000)：1hexo s 这还只是本地项目，现在要发布到github上面去，我们需要配置项目目录下的_config.yml文件，打开它找到最后一行，我们把github的配置信息填上去。这里gaojindeng是我的登录名，你只需要将它改成你github的登录名，原封不动地配置好就行了。我看到好多教程是第二张图那样配置，新版本是不能那样配的。我们开始发布博客吧！1hexo d 稍等一会就可以输入网址xxx.github.io访问你的博客啦~~~ 新建博文1hexo new "文章题目" 新建页面1hexo new page "页面名称" 快捷命令全称1234hexo g == hexo generatehexo d == hexo deployhexo s == hexo serverhexo n == hexo new 发博文123hexo ghexo d 其他头像存放路径： 主题的source 文件夹下 直接/*.jpg 就行]]></content>
      <categories>
        <category>建站相关</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
